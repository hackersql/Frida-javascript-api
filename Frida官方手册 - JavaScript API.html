<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <meta name="referrer" content="never" />
    <meta name="description" content="篇一&#xA;&#xA;&#xA;JavaScript API&#xA;目录&#xA;Global&#xA;console&#xA;rpc&#xA;Frida&#xA;Process&#xA;Module&#xA;ModuleMa" />
    <meta property="og:description" content="篇一&#xA;&#xA;&#xA;JavaScript API&#xA;目录&#xA;Global&#xA;console&#xA;rpc&#xA;Frida&#xA;Process&#xA;Module&#xA;ModuleMa" />
    <meta http-equiv="Cache-Control" content="no-transform"/>
    <meta http-equiv="Cache-Control" content="no-siteapp"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <title>Python爬虫之app逆向 frida javascript api手册 - Eeyhan - 博客园</title>
    <link id="favicon" rel="shortcut icon" href="//common.cnblogs.com/favicon.svg" type="image/svg+xml" />
    
    <link rel="stylesheet" href="/css/blog-common.min.css?v=x0sCXgfRZH24nF9pqBIDTBIzbO5BqnCcmdVV58d1xnI" />
    <link id="MainCss" rel="stylesheet" href="/skins/simplememory/bundle-simplememory.min.css?v=uknaX_hejnSu-njQgx4Hj1R0JiPLwUhFPUlwWNmWyB4" />
        <link id="highlighter-theme-cnblogs" type="text/css" rel="stylesheet" href="/css/hljs/cnblogs.css?v=5J1NDtbnnIr2Rc2SdhEMlMxD4l9Eydj88B31E7_NhS4" />
    <link type="text/css" rel="stylesheet" href="https://www.cnblogs.com/Eeyhan/custom.css?v=IvISXjzEB6qhrloW7pxGWgNDEIA=" />
    <link id="mobile-style" media="only screen and (max-width: 767px)" type="text/css" rel="stylesheet" href="/skins/SimpleMemory/bundle-simplememory-mobile.min.css?v=VoUgP5GKXZVYsJt7upN-vcbhaKWAIw6cMrl6YFjPcKs" />
    
    <link type="application/rss+xml" rel="alternate" href="https://www.cnblogs.com/Eeyhan/rss" />
    <link type="application/rsd+xml" rel="EditURI" href="https://www.cnblogs.com/Eeyhan/rsd.xml" />
    <link type="application/wlwmanifest+xml" rel="wlwmanifest" href="https://www.cnblogs.com/Eeyhan/wlwmanifest.xml" />
    <script>
        var currentBlogId = 385429;
        var currentBlogApp = 'Eeyhan';
        var isLogined = false;
        var isBlogOwner = false;
        var skinName = 'SimpleMemory';
        var visitorUserId = '';
        var hasCustomScript = false;
        try {
            if (hasCustomScript && document.referrer && document.referrer.indexOf('baidu.com') >= 0) {
                Object.defineProperty(document, 'referrer', { value: '' });
                Object.defineProperty(Document.prototype, 'referrer', { get: function(){ return ''; } });
            }
        } catch(error) { }
        window.cb_enable_mathjax = false;
        window.mathEngine = 0;
        window.codeHighlightEngine = 1;
        window.enableCodeLineNumber = false;
        window.codeHighlightTheme = 'cnblogs';
        window.darkModeCodeHighlightTheme = 'vs2015';
        window.isDarkCodeHighlightTheme = false;
        window.isDarkModeCodeHighlightThemeDark = true;
        window.isDisableCodeHighlighter = false;
        window.enableCodeThemeTypeFollowSystem = false;
    </script>
        <script>
            var currentPostDateAdded = '2020-08-01 14:53';
        </script>
    <script src="https://common.cnblogs.com/scripts/jquery-2.2.0.min.js"></script>
    <script src="/js/blog-common.min.js?v=CJqpEcB2VzA38UjNF1IXe3fHW_bnz9JDDOND4We0ej8"></script>
    
</head>
<body class="skin-simplememory no-navbar">
<a name="top"></a>
<div id="top_nav" class="navbar forpc navbar-custom">
    <nav id="nav_main" class="navbar-main">
        <ul id="nav_left" class="navbar-list navbar-left">
            <li class="navbar-branding">
                <a href="https://www.cnblogs.com/" title="开发者的网上家园" role="banner">
                    <img src="//common.cnblogs.com/logo.svg" alt="博客园Logo" />
                </a>
            </li>
            <li>
                <a href="/" onclick="countClicks('skin-navbar-sitehome')">首页</a>
            </li>
            <li>
                <a href="https://news.cnblogs.com/" onclick="countClicks('nav', 'skin-navbar-news')">新闻</a>
            </li>
            <li>
                <a href="https://q.cnblogs.com/" onclick="countClicks('nav', 'skin-navbar-q')">博问</a>
            </li>
            <li>
                <a id="nav_brandzone" href="https://brands.cnblogs.com/" onclick="countClicks('nav', 'skin-navbar-brands')">专区</a>
            </li>
            <li>
                <a href="https://ing.cnblogs.com/" onclick="countClicks('nav', 'skin-navbar-ing')">闪存</a>
            </li>
            <li>
                <a href="https://edu.cnblogs.com/" onclick="countClicks('nav', 'skin-navbar-edu')">班级</a>
            </li>
        </ul>
        <ul id="nav_right" class="navbar-list navbar-right">
            <li>
                <form id="zzk_search" class="navbar-search" action="https://zzk.cnblogs.com/s" method="get" role="search">
                    <input name="w" id="zzk_search_input" placeholder="代码改变世界" type="search" tabindex="3"/>
                    <button type="submit" id="zzk_search_button">
                        <img src="//common.cnblogs.com/images/blog/search.svg" alt="搜索" />
                    </button>
                </form>
            </li>
            <li id="navbar_login_status" class="navbar-list">
                <a class="navbar-user-info navbar-blog" href="https://i.cnblogs.com/EditPosts.aspx?opt=1" alt="写随笔" title="写随笔">
                    <img id="new_post_icon" class="navbar-icon" src="//common.cnblogs.com/images/blog/newpost.svg" alt="写随笔" />
                </a>
                <a id="navblog-myblog-icon" class="navbar-user-info navbar-blog" href="https://passport.cnblogs.com/GetBlogApplyStatus.aspx" alt="我的博客" title="我的博客">
                    <img id="myblog_icon" class="navbar-icon" src="//common.cnblogs.com/images/blog/myblog.svg" alt="我的博客" />
                </a>
                <a class="navbar-user-info navbar-message navbar-icon-wrapper" href="https://msg.cnblogs.com/" alt="短消息" title="短消息">
                    <img id="msg_icon" class="navbar-icon" src="//common.cnblogs.com/images/blog/message.svg" alt="短消息" />
                    <span id="msg_count" style="display: none"></span>
                </a>
                <a id="navbar_lite_mode_indicator" data-current-page="blog" style="display: none" href="javascript:void(0)" alt="简洁模式" title="简洁模式启用，您在访问他人博客时会使用简洁款皮肤展示">
                    <img class="navbar-icon" src="//common.cnblogs.com/images/blog/lite-mode-on.svg" alt="简洁模式" />
                </a>
                <div id="user_info" class="navbar-user-info dropdown">
                    <a class="dropdown-button" href="https://home.cnblogs.com/">
                        <img id="user_icon" class="navbar-avatar" src="//common.cnblogs.com/images/blog/avatar-default.svg" alt="用户头像" />
                    </a>
                    <div class="dropdown-menu">
                        <a id="navblog-myblog-text" href="https://passport.cnblogs.com/GetBlogApplyStatus.aspx">我的博客</a>
                        <a href="https://home.cnblogs.com/">我的园子</a>
                        <a href="https://account.cnblogs.com/settings/account">账号设置</a>
                        <a href="javascript:void(0)" id="navbar_lite_mode_toggle" title="简洁模式会使用简洁款皮肤显示所有博客">
    简洁模式 <img id="navbar_lite_mode_on" src="/images/lite-mode-check.svg" class="hide" /><span id="navbar_lite_mode_spinner" class="hide">...</span>
</a>
                        <a href="javascript:void(0)" onclick="account.logout();">退出登录</a>
                    </div>
                </div>
                <a class="navbar-anonymous" href="https://account.cnblogs.com/signup">注册</a>
                <a class="navbar-anonymous" href="javascript:void(0);" onclick="account.login()">登录</a>
            </li>
        </ul>
    </nav>
</div>



<!--done-->
<div id="home">
<div id="header">
	<div id="blogTitle">
        <a id="lnkBlogLogo" href="https://www.cnblogs.com/Eeyhan/"><img id="blogLogo" src="/skins/custom/images/logo.gif" alt="返回主页" /></a>		
		
<!--done-->
<h1><a id="Header1_HeaderTitle" class="headermaintitle HeaderMainTitle" href="https://www.cnblogs.com/Eeyhan/">geekbyte</a>
</h1>
<h2></h2>




		
	</div><!--end: blogTitle 博客的标题和副标题 -->
	<div id="navigator">
		
<ul id="navList">
<li><a id="blog_nav_sitehome" class="menu" href="https://www.cnblogs.com/">
博客园</a>
</li>
<li>
<a id="blog_nav_myhome" class="menu" href="https://www.cnblogs.com/Eeyhan/">
首页</a>
</li>
<li>

<a id="blog_nav_newpost" class="menu" href="https://i.cnblogs.com/EditPosts.aspx?opt=1">
新随笔</a>
</li>
<li>
<a id="blog_nav_contact" class="menu" href="https://msg.cnblogs.com/send/Eeyhan">
联系</a></li>
<li>

<!--<partial name="./Shared/_XmlLink.cshtml" model="Model" /></li>--></li>
<li>
<a id="blog_nav_admin" class="menu" href="https://i.cnblogs.com/">
管理</a>
</li>
</ul>


		<div class="blogStats">
			<div id="blog_stats_place_holder"><script>loadBlogStats();</script></div>
		</div><!--end: blogStats -->
	</div><!--end: navigator 博客导航栏 -->
</div><!--end: header 头部 -->
<div id="main">
	<div id="mainContent">
	<div class="forFlow">
		<div id="post_detail">
    <!--done-->
    <div id="topics">
        <div class="post">
            <h1 class = "postTitle">
                
<a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/Eeyhan/p/13414629.html">
    <span role="heading" aria-level="2">Python爬虫之app逆向 frida javascript api手册</span>
    
</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        
        篇一


JavaScript API
目录
Global
console
rpc
Frida
Process
Module
ModuleMa
    </div>
<div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<p><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">&nbsp;</span></p>
<h2><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">frida</span></h2>
<p><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">什么是frida不用多说了，前面我有篇文章&nbsp; &nbsp;<a class="postTitle2 vertical-middle" href="https://www.cnblogs.com/Eeyhan/p/12916162.html" target="_blank" rel="noopener">对app的反爬测试之apk逆向分析-frida绕过ssl pinning检测</a>&nbsp;&nbsp; &nbsp; 已经介绍过了，&nbsp; &nbsp;不过里面用到的js脚本，貌似挺屌的是吧，那么做开发的肯定知道，想一直用同一套js脚本hook各种app肯定是不行的，那么我们做开发的，肯定想自己写hook脚本，然后读了别人的脚本，发现看不太懂啊，很多方法啥意思都不知道，其实，那些hookj脚本是javascript语法，有点不同的是，里面调用了很多frida 的api，所以就不太容易看懂脚本啥意思，那么我们要想自己写脚本，肯定要学会那些api的使用了</span></p>
<p><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">&nbsp;</span></p>
<p><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">&nbsp;</span></p>
<h2><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">javascript api</span></h2>
<p><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">&nbsp;</span></p>
<p><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">以下内容转自看雪大佬&nbsp;&nbsp;安全鸟一起飞&nbsp; 的frida手册指南&nbsp;</span></p>
<p><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">&nbsp;</span></p>
<p><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">原文地址：</span></p>
<p><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px"><a href="https://zhuanlan.kanxue.com/article-342.htm" target="_blank" rel="noopener">Frida官方手册 - JavaScript API（篇一）</a></span></p>
<p><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px"><a href="https://zhuanlan.kanxue.com/article-414.htm" target="_blank" rel="noopener">Frida官方手册 - JavaScript API（篇二）</a></span></p>
<p><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px"><a href="https://zhuanlan.kanxue.com/article-4277.htm" target="_blank" rel="noopener">Frida官方手册 - JavaScript API（篇三）</a></span></p>
<p><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">&nbsp;</span></p>
<h2><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">篇一</span></h2>
<p><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">&nbsp;</span></p>
<h3><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">JavaScript API</span></h3>
<h4><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">目录</span></h4>
<ol>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">Global</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">console</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">rpc</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">Frida</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">Process</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">Module</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">ModuleMap</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">Memory</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">MemoryAccessMonitor</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">Thread</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">Int64</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">UInt64</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">NativePointer</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">NativeFunction</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">NativeCallback</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">SystemFunction</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">Socket</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">SocketListener</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">SocketConnection</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">IOStream</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">InputStream</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">OutputStream</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">UnixInputStream</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">UnixOutputStream</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">Win32InputStream</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">Win32OutputStream</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">File</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">SqliteDatabase</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">SqliteStatement</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">Interceptor</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">Stalker</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">ApiResolver</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">DebugSymbol</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">Instruction</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">ObjC</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">Java</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">WeakRef</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">X86Writer</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">X86Relocator</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">X86_enum_types</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">ArmWriter</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">ArmRelocation</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">ThumbWriter</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">ThumbRelocator</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">ARM_enum_types</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">Arm64Writer</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">Arm64Relocator</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">AArch64_enum_types</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">MipsWriter</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">MipsRelocator</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">Mips_enum_types</span></li>
</ol>
<h4><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">Global</span></h4>
<ul>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">hexdump(target[, options]):&nbsp;把一个&nbsp;ArrayBuffer&nbsp;或者&nbsp;NativePointer&nbsp;的target变量，附加一些&nbsp;options&nbsp;属性，按照指定格式进行输出，比如：</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px"><img src="https://zhuanlan.kanxue.com/upload/attach/201711/126904_wk8ibhuh3503yc1i.png" alt="" title=""></span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">int64(v):&nbsp;new Int64(v)&nbsp;的缩写格式</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">uint64(v):&nbsp;new UInt64(v)&nbsp;的缩写格式</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">ptr(s):&nbsp;new NativePointer(s)&nbsp;的缩写格式</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">NULL&nbsp;ptr(“0”)&nbsp;的缩写格式</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">recv([type, ]callback):&nbsp;注册一个回调，当下次有消息到来的时候会收到回调消息，可选参数&nbsp;type&nbsp;相当于一个过滤器，表示只接收这种类型的消息。需要注意的一点是， 这个消息回调是一次性的， 收到一个消息之后，如果需要继续接收消息，那就需要重新调用一个&nbsp;recv</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">send(message[, data]):&nbsp;从目标进程中往主控端发&nbsp;message（必须是可以序列换成Json的），如果你还有二进制数据需要附带发送（比如使用&nbsp;Memory.readByteArray&nbsp;拷贝的内存数据），就把这个附加数据填入&nbsp;data&nbsp;参数，但是有个要求，就是&nbsp;data&nbsp;参数必须是一个&nbsp;ArrayBuffer&nbsp;或者是一个整形数组（数值是 0-255）</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px"><img src="https://zhuanlan.kanxue.com/upload/attach/201711/126904_fwkpwgygq8k6i123.png" alt="" title=""></span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">setTimeout(fn, delay):&nbsp;在延迟&nbsp;delay&nbsp;毫秒之后，调用&nbsp;fn，这个调用会返回一个ID，这个ID可以传递给&nbsp;clearTimeout&nbsp;用来进行调用取消。</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">clearTimeout(id):&nbsp;取消通过&nbsp;setTimeout&nbsp;发起的延迟调用</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">setInterval(fn, delay):&nbsp;每隔&nbsp;delay&nbsp;毫秒调用一次&nbsp;fn，返回一个ID，这个ID可以传给&nbsp;clearInterval&nbsp;进行调用取消。</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">clearInterval(id):&nbsp;取消通过&nbsp;setInterval&nbsp;发起的调用</span></li>
</ul>
<h4><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">console</span></h4>
<ul>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">console.log(line), console.warn(line), console.error(line):&nbsp;向标准输入输出界面写入&nbsp;line&nbsp;字符串。 比如：使用&nbsp;Frida-Python&nbsp;的时候就输出到&nbsp;stdout&nbsp;或者&nbsp;stderr，使用&nbsp;frida-qml&nbsp;的时候则输出到&nbsp;qDebug，如果输出的是一个ArrayBuffer，会以默认参数自动调用&nbsp;hexdump&nbsp;进行格式化输出。</span></li>
</ul>
<h4><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">rpc</span></h4>
<ul>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">rpc.exports:&nbsp;可以在你的程序中导出一些&nbsp;RPC-Style&nbsp;API函数，Key指定导出的名称，Value指定导出的函数，函数可以直接返回一个值，也可以是异步方式以&nbsp;Promise&nbsp;的方式返回，举个例子：</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px"><img src="https://zhuanlan.kanxue.com/upload/attach/201711/126904_lsi58wsela36ghxq.png" alt="" title=""></span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">对于Python主控端可以使用下面这样的脚本使用导出的函数：</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px"><img src="https://zhuanlan.kanxue.com/upload/attach/201711/126904_hch0k9xhj12kbena.png" alt="" title=""></span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">在上面这个例子里面，我们使用&nbsp;script.on(‘message’, on_message)&nbsp;来监控任何来自目标进程的消息，消息监控可以来自&nbsp;script&nbsp;和&nbsp;session&nbsp;两个方面，比如，如果你想要监控目标进程的退出，可以使用下面这个语句&nbsp;session.on(‘detached’, my_function)</span></li>
</ul>
<h4><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">Frida</span></h4>
<ul>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">Frida.version:&nbsp;包含当前Frida的版本信息</span></li>
</ul>
<h4><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">Process</span></h4>
<ul>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">Process.arch:&nbsp;CPU架构信息，取值范围：ia32、x64、arm、arm64</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">Process.platform:&nbsp;平台信息，取值范围：windows、darwin、linux、qnx</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">Process.pageSize:&nbsp;虚拟内存页面大小，主要用来辅助增加脚本可移植性</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">Process.pointerSize:&nbsp;指针占用的内存大小，主要用来辅助增加脚本可移植性</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">Process.codeSigningPolicy:&nbsp;取值范围是&nbsp;optional&nbsp;或者&nbsp;required，后者表示Frida会尽力避免修改内存中的代码，并且不会执行未签名的代码。默认值是&nbsp;optional，除非是在&nbsp;Gadget&nbsp;模式下通过配置文件来使用&nbsp;required，通过这个属性可以确定&nbsp;Interceptor API&nbsp;是否有限制，确定代码修改或者执行未签名代码是否安全。(译者注：这个目前没有实验清楚，可以参考原文)</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">Process.isDebuggerAttached():&nbsp;确定当前是否有调试器附加</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">Process.getCurrentThreadId():&nbsp;获取当前线程ID</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">Process.enumerateThreads(callbacks):&nbsp;枚举所有线程，每次枚举到一个线程就执行回调类callbacks：<br>Process.enumerateThreadSync():&nbsp;enumerateThreads()的同步版本，返回线程对象数组</span>
<ul>
<li>onMatch: function(thread): 当枚举到一个线程的时候，就调用这个函数，其中thread参数包含 ：<br><ol>
<li>id，线程ID</li>
<li>state，线程状态，取之范围是&nbsp;running, stopped, waiting, uninterruptible, halted</li>
<li>context, 包含&nbsp;pc, sp，分别代表 EIP/RIP/PC 和 ESP/RSP/SP，分别对应于 ia32/x64/arm平台，其他的寄存器也都有，比如&nbsp;eax, rax, r0, x0&nbsp;等。</li>
<li>函数可以直接返回&nbsp;stop&nbsp;来停止枚举。</li>


</ol></li>
<li>onComplete: function():&nbsp;当所有的线程枚举都完成的时候调用。</li>


</ul>


</li>
<li></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">Process.findModuleByAddress(address), Process.getModuleByAddress(address), Process.findModuleByName(name), Process.getModuleByName(name):&nbsp;根据地址或者名称来查找模块，如果找不到这样的模块，find开头的函数返回&nbsp;null，get开头的函数会抛出异常。</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">Process.enumerateModules(callbacks):&nbsp;枚举已经加载的模块，枚举到模块之后调用回调对象：<br>Process.enumerateModulesSync():&nbsp;enumerateModules()&nbsp;函数的同步版本，返回模块对象数组</span>
<ul>
<li>onMatch: function(module): 枚举到一个模块的时候调用，module对象包含如下字段：<br><ol>
<li>name, 模块名</li>
<li>base, 基地址</li>
<li>size，模块大小</li>
<li>path，模块路径</li>
<li>函数可以返回&nbsp;stop&nbsp;来停止枚举 。</li>


</ol></li>
<li>onComplete: function(): 当所有的模块枚举完成的时候调用。</li>


</ul>


</li>
<li></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">Process.findRangeByAddress(address), Process.getRangeByAddress(address):&nbsp;返回一个内存块对象， 如果在这个address找不到内存块对象，那么&nbsp;findRangeByAddress()&nbsp;返回&nbsp;null&nbsp;而&nbsp;getRangeByAddress&nbsp;则抛出异常。</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">Process.numerateRanges(protection | specifier, callbacks):&nbsp;枚举指定&nbsp;protection&nbsp;类型的内存块，以指定形式的字符串给出：rwx，而&nbsp;rw-&nbsp;表示最少是可读可写，也可以用分类符，里面包含&nbsp;protection&nbsp;这个Key，取值就是前面提到的rwx，还有一个&nbsp;coalesce&nbsp;这个Key，表示是否要把位置相邻并且属性相同的内存块合并给出结果，枚举过程中回调&nbsp;callbacks&nbsp;对象：<br>Process.enumerateRangesSync(protection | specifier):&nbsp;enumerateRanges()函数的同步版本，返回内存块数组</span>
<ul>
<li>onMatch: function(range): 每次枚举到一个内存块都回调回来，其中Range对象包含如下属性：<br><ol>
<li>base：基地址</li>
<li>size：内存块大小</li>
<li>protection：保护属性</li>
<li>file：（如果有的话）内存映射文件：<br>4.1 path，文件路径<br>4.2 offset，文件内偏移</li>
<li>如果要停止枚举过程，直接返回&nbsp;stop&nbsp;即可</li>


</ol></li>
<li>onComplete: function(): 所有内存块枚举完成之后会回调</li>


</ul>


</li>
<li></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">Process.enumerateMallocRanges(callbacks):&nbsp;用于枚举在系统堆上申请的内存块</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">Process.enumerateMallocRangesSync(protection):&nbsp;Process.enumerateMallocRanges()&nbsp;的同步版本</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">Process.setExceptionHandler(callback):&nbsp;在进程内安装一个异常处理函数（Native Exception），回调函数会在目标进程本身的异常处理函数之前调用 ，回调函数只有一个参数&nbsp;details，包含以下几个属性：<br></span>
<ul>
<li>type，取值为下列之一：<br><ol>
<li>abort</li>
<li>access-violation</li>
<li>guard-page</li>
<li>illegal-instruction</li>
<li>stack-overflow</li>
<li>arithmetic</li>
<li>breakpoint</li>
<li>single-step</li>
<li>system</li>


</ol></li>
<li>address，异常发生的地址，NativePointer</li>
<li>memory，如果这个对象不为空，则会包含下面这些属性：<br><ol>
<li>operation: 引发一场的操作类型，取值范围是 read, write 或者 execute</li>
<li>address: 操作发生异常的地址，NativePointer</li>


</ol></li>
<li>context，包含&nbsp;pc&nbsp;和&nbsp;sp&nbsp;的NativePointer，分别代表指令指针和堆栈指针</li>
<li>nativeContext，基于操作系统定义的异常上下文信息的NativePointer，在&nbsp;context&nbsp;里面的信息不够用的时候，可以考虑用这个指针，但是一般不建议使用（译者注：估计是考虑到可移植性或者稳定性）</li>
<li>捕获到异常之后，怎么使用就看你自己了，比如可以把异常信息写到日志里面，然后发送个信息给主控端，然后同步等待主控端的响应之后处理，或者直接修改异常信息里面包含的寄存器的值，尝试恢复掉异常，继续执行。如果你处理了异常信息，那么这个异常回调里面你要返回&nbsp;true，Frida会把异常交给进程异常处理函数处理，如果到最后都没人去处理这个异常，就直接结束目标进程。</li>


</ul>


</li>


</ul>
<h4><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">Module</span></h4>
<ul>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">Module.emuerateImports(name, callbacks):&nbsp;枚举模块&nbsp;name&nbsp;的导入表，枚举到一个导入项的时候回调callbacks, callbacks包含下面2个回调：<br>Module.eumerateImportsSync(name):&nbsp;enumerateImports()的同步版本</span>
<ul>
<li>onMatch: function(imp):&nbsp;枚举到一个导入项到时候会被调用，imp包含如下的字段：<br><ol>
<li>type，导入项的类型， 取值范围是&nbsp;function或者variable</li>
<li>name，导入项的名称</li>
<li>module，模块名称</li>
<li>address，导入项的绝对地址</li>
<li>以上所有的属性字段，只有&nbsp;name&nbsp;字段是一定会有，剩余的其他字段不能保证都有，底层会尽量保证每个字段都能给出数据，但是不能保证一定能拿到数据，onMatch函数可以返回字符串&nbsp;stop&nbsp;表示要停止枚举。</li>


</ol></li>
<li>onComplete: function():&nbsp;当所有的导入表项都枚举完成的时候会回调</li>


</ul>


</li>
<li></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">Module.emuerateExports(name, callbacks):&nbsp;枚举指定模块&nbsp;name&nbsp;的导出表项，结果用&nbsp;callbacks&nbsp;进行回调：<br>Module.enumerateExportsSync():&nbsp;Module.enumerateExports()的同步版本</span>
<ul>
<li>onMatch: function(exp):&nbsp;其中 exp 代表枚举到的一个导出项，包含如下几个字段：<br><ol>
<li>type，导出项类型，取值范围是&nbsp;function或者variable</li>
<li>name，导出项名称</li>
<li>address，导出项的绝对地址，NativePointer</li>
<li>函数返回&nbsp;stop&nbsp;的时候表示停止枚举过程</li>


</ol></li>
<li>onComplete: function():&nbsp;枚举完成回调</li>


</ul>


</li>
<li></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">Module.enumerateSymbols(name, callbacks):&nbsp;枚举指定模块中包含的符号，枚举结果通过回调进行通知：<br><img src="https://zhuanlan.kanxue.com/upload/attach/201711/126904_qedhulv5pdycqyqk.png" alt="" title=""></span>
<ul>
<li>onMatch: function(sym):&nbsp;其中&nbsp;sym&nbsp;包含下面几个字段：<br>
<ul>
<li>isGlobal，布尔值，表示符号是否全局可见</li>
<li>type，符号的类型，取值是下面其中一种：<br><ol>
<li>unknown</li>
<li>undefined</li>
<li>absolute</li>
<li>section</li>
<li>prebound-undefined</li>
<li>indirect</li>


</ol></li>
<li>section，如果这个字段不为空的话，那这个字段包含下面几个属性：<br><ol>
<li>id，小节序号，段名，节名</li>
<li>protection，保护属性类型，&nbsp;rwx这样的属性</li>


</ol></li>
<li>name，符号名称</li>
<li>address，符号的绝对地址，NativePointer</li>
<li>这个函数返回&nbsp;stop&nbsp;的时候，表示要结束枚举过程</li>


</ul>


</li>
<li>Module.enumerateSymbolsSync(name):&nbsp;Module.enumerateSymbols()&nbsp;的同步版本</li>


</ul>


</li>
<li></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">Module.enumerateRanges(name, protection, callbacks):&nbsp;功能基本等同于&nbsp;Process.enumerateRanges()，只不过多了一个模块名限定了枚举的范围</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">Module.enumerateRangesSync(name, protection):&nbsp;Module.enumerateRanges()&nbsp;的同步版本</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">Module.findBaseAddress(name):&nbsp;获取指定模块的基地址</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">Module.findExportByName(module | null, exp):&nbsp;返回模块module&nbsp;内的导出项的绝对地址，如果模块名不确定，第一个参数传入 null，这种情况下会增大查找开销，尽量不要使用。</span></li>


</ul>
<h4><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">ModuleMap</span></h4>
<ul>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">new ModuleMap([filter]):&nbsp;可以理解为内存模块快照，主要目的是可以作为一个模块速查表，比如你可以用这个快照来快速定位一个具体的地址是属于哪个模块。创建ModuleMap的时候，就是对目标进程当前加载的模块的信息作一个快照，后续想要更新这个快照信息的时候，可以使用&nbsp;update&nbsp;进行更新。 这个&nbsp;filter&nbsp;参数是可选的，主要是用来过滤你关心的模块，可以用来缩小快照的范围（注意：filter是过滤函数，不是字符串参数），为了让模块进入这个快照里，过滤函数的返回值要设置为true，反之设为false，如果后续内存中的模块加载信息更新了， 还会继续调用这个filter函数。</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">has(address):&nbsp;检查&nbsp;address&nbsp;这个地址是不是包含在ModuleMap里面，返回bool值</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">find(address), get(address):&nbsp;返回&nbsp;address&nbsp;地址所指向的模块对象详细信息，如果不存在 find 返回null，get 直接会抛出异常，具体的返回的对象的详细信息，可以参考&nbsp;Process.enumerateModules()</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">findName(address), getName(address), findPath(address), getPath(address):&nbsp;功能跟&nbsp;find(), get()&nbsp;类似，但是只返回&nbsp;name&nbsp;或者&nbsp;path&nbsp;字段，可以省点开销</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">update():&nbsp;更新ModuleMap信息，如果有模块加载或者卸载，最好调用一次，免得使用旧数据。</span></li>


</ul>
<h4><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">Memory</span></h4>
<ul>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">Memory.scan(address, size, pattern, callbacks):&nbsp;在&nbsp;address&nbsp;开始的地址，size&nbsp;大小的内存范围内以&nbsp;pattern&nbsp;这个模式进行匹配查找，查找到一个内存块就回调callbacks，各个参数详细如下：<br>Memory.scanSync(address, size, pattern):&nbsp;内存扫描&nbsp;scan()&nbsp;的同步版本</span>
<ul>
<li>pattern&nbsp;比如使用13 37 ?? ff来匹配0x13开头，然后跟着0x37，然后是任意字节内容，接着是0xff这样的内存块</li>
<li>callbacks&nbsp;是扫描函数回调对象：<br><ol>
<li>onMatch: function(address, size):&nbsp;扫描到一个内存块，起始地址是address，大小size的内存块，返回&nbsp;stop&nbsp;表示停止扫描</li>
<li>onError: function(reason):&nbsp;扫描内存的时候出现内存访问异常的时候回调</li>
<li>onComplete: function():&nbsp;内存扫描完毕的时候调用</li>


</ol></li>


</ul>


</li>
<li></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">Memory.alloc(size):&nbsp;在目标进程中的堆上申请size大小的内存，并且会按照Process.pageSize对齐，返回一个NativePointer，并且申请的内存如果在JavaScript里面没有对这个内存的使用的时候会自动释放的。也就是说，如果你不想要这个内存被释放，你需要自己保存一份对这个内存块的引用。</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">Memory.copy(dust, src, n):&nbsp;就像是memcpy</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">Memory.dup(address, size):&nbsp;等价于&nbsp;Memory.alloc()和Memory.copy()的组合。</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">Memory.protect(address, size, protection):&nbsp;更新address开始，size大小的内存块的保护属性，protection&nbsp;的取值参考&nbsp;Process.enumerateRanges()，比如：Memory.protect(ptr(“0x123”, 4096, ‘rw-‘));</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">Memory.patchCode(address, size, apply):&nbsp;apply是一个回调函数，这个函数是用来在&nbsp;address&nbsp;开始的地址和&nbsp;size&nbsp;大小的地方开始Patch的时候调用，回调参数是一个NativePointer的可写指针，需要在apply回调函数里面要完成patch代码的写入，注意，这个可写的指针地址不一定和上面的address是同一个地址，因为在有的系统上是不允许直接写入代码段的，需要先写入到一个临时的地方，然后在影射到响应代码段上，（比如 iOS上， 会引发进程丢失 CS_VALID 状态），比如：</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px"><img src="https://zhuanlan.kanxue.com/upload/attach/201711/126904_4qu86ly5yjfpt8o5.png" alt="" title=""></span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">下面是接着是一些数据类型读写：<br></span><ol>
<li>Memory.readPointer(address)</li>
<li>Memory.writePointer(address, ptr)</li>
<li>Memory.readS8, Memory.readU8</li>
<li>…</li>


</ol></li>


</ul>
<h4><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">MemoryAccessMonitor</span></h4>
<ul>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px"><img src="https://zhuanlan.kanxue.com/upload/attach/201711/126904_83nohvzdtyot3bx2.png" alt="" title=""></span></li>
<li>
<p>MemoryAccessMonitor.enable(ranges, callbacks):&nbsp;监控一个或多个内存块的访问，在触发到内存访问的时候发出通知。ranges&nbsp;要么是一个单独的内存块，要么是一个内存块数组，每个内存块包含如下属性：</p>
<ul>
<li>base:&nbsp;触发内存访问的NativePointer地址</li>
<li>size:&nbsp;被触发访问的内存块的大小</li>
<li>callbacks:&nbsp;回调对象结构：</li>
<li>onAccess: function(details):&nbsp;发生访问的时候同步调用这个函数，details对象包含如下属性：<br><ol>
<li>operation: 触发内存访问的操作类型，取值范围是&nbsp;read, write&nbsp;或者&nbsp;execute</li>
<li>from: 触发内存访问的指令地址，NativePointer</li>
<li>address: 被访问的内存地址</li>
<li>rangeIndex: 被访问的内存块的索引，就是调用MemoryAccessMonitor.enable()的时候指定的内存块序号</li>
<li>pageIndex: 在被监控内存块范围内的页面序号</li>
<li>pagesCompleted: 到目前为止已经发生过内存访问的页面的个数（已经发生过内存访问的页面将不再进行监控）</li>
<li>pagesTotal: 初始指定的需要监控的内存页面总数</li>


</ol></li>


</ul>


</li>
<li>
<p><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">MemoryAccessMonitor.disable():&nbsp;停止监控页面访问操作</span></p>


</li>


</ul>
<h4><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">Thread</span></h4>
<ul>
<ul>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">Thread.backtrace([context, backtracer]):&nbsp;抓取当前线程的调用堆栈，并以&nbsp;NativePointer&nbsp;指针数组的形式返回。<br>Thread.sleep(delay):&nbsp;线程暂停&nbsp;delay&nbsp;秒执行</span><ol>
<li>如果你是在&nbsp;Interceptor.onEnter或者Interceptor.onLeave&nbsp;中调用这个函数的话，那就必须要把 this.context 作为参数传入，这样就能拿到更佳精准的堆栈调用信息，如果省略这个参数不传，那就意味着从当前堆栈的位置开始抓取，这样的抓取效果可能不会很好，因为有不少V8引擎的栈帧的干扰。</li>
<li>第二个可选参数&nbsp;backtracer，表示使用哪种类型的堆栈抓取算法，目前的取值范围是&nbsp;Backtracer.FUZZY&nbsp;和&nbsp;Backtracer.ACCURATE，目前后者是默认模式。精确抓取模式下，如果如果程序是调试器友好（比如是标准编译器编译的结果，没有什么反调试技巧）或者有符号表的支持，抓取效果是最好的，而模糊抓取模式下，抓取器会在堆栈上尝试抓取，并且会猜测里面包含的返回地址，也就是说中间可能包含一些错误的信息，但是这种模式基本能在任何二进制程序里面工作：</li>
<li><img src="https://zhuanlan.kanxue.com/upload/attach/201711/126904_384da7ggvahbgz1n.png" alt="" title=""></li>


</ol></li>
<li></li>


</ul>

</ul>
<p><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">&nbsp;</span></p>
<h2><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">篇二</span></h2>
<h3><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">JavaScript API</span></h3>
<h4><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">Int64</span></h4>
<ul>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">new Int64(v):&nbsp;以v为参数，创建一个Int64对象，v可以是一个数值，也可以是一个字符串形式的数值表示，也可以使用&nbsp;Int64(v)&nbsp;这种简单的方式。</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">add(rhs), sub(rhs), and(rhs), or(rhs), xor(rhs):&nbsp;Int64相关的加减乘除。</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">shr(n), shl(n):&nbsp;Int64相关的左移、右移操作</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">compare(rhs):&nbsp;Int64的比较操作，有点类似 String.localCompare()</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">toNumber():&nbsp;把Int64转换成一个实数</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">toString([radix = 10]):&nbsp;按照一定的数值进制把Int64转成字符串，默认是十进制</span></li>

</ul>
<h4><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">UInt64</span></h4>
<ul>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">可以直接参考Int64</span></li>

</ul>
<h4><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">NativePointer</span></h4>
<ul>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">可以直接参考Int64</span></li>

</ul>
<h4><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">NativeFunction</span></h4>
<ul>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">new NativeFunction(address, returnType, argTypes[, abi]):&nbsp;在address（使用NativePointer的格式）地址上创建一个NativeFunction对象来进行函数调用，returnType&nbsp;指定函数返回类型，argTypes&nbsp;指定函数的参数类型，如果不是系统默认类型，也可以选择性的指定&nbsp;abi&nbsp;参数，对于可变类型的函数，在固定参数之后使用&nbsp;“…”&nbsp;来表示。</span></li>
<li>
<p>类和结构体</p>
<ul>
<li>在函数调用的过程中，类和结构体是按值传递的，传递的方式是使用一个数组来分别指定类和结构体的各个字段，理论上为了和需要的数组对应起来，这个数组是可以支持无限嵌套的，结构体和类构造完成之后，使用NativePointer的形式返回的，因此也可以传递给Interceptor.attach()&nbsp;调用。</li>
<li>需要注意的点是， 传递的数组一定要和需要的参数结构体严格吻合，比如一个函数的参数是一个3个整形的结构体，那参数传递的时候一定要是&nbsp;[‘int’, ‘int’, ‘int’]，对于一个拥有虚函数的类来说，调用的时候，第一个参数一定是虚表指针。</li>

</ul>

</li>
<li>
<p>Supported Types</p>
<ul>
<li>void</li>
<li>pointer</li>
<li>int</li>
<li>uint</li>
<li>long</li>
<li>ulong</li>
<li>char</li>
<li>uchar</li>
<li>float</li>
<li>double</li>
<li>int8</li>
<li>uint8</li>
<li>int16</li>
<li>uint16</li>
<li>int32</li>
<li>uint32</li>
<li>int64</li>
<li>uint64</li>

</ul>

</li>
<li>
<p>Supported ABIs</p>
<ul>
<li>default</li>
<li>Windows 32-bit:<br>
<ul>
<li>sysv</li>
<li>stdcall</li>
<li>thiscall</li>
<li>fastcall</li>
<li>mscdecl</li>


</ul>


</li>
<li>Windows 64-bit:<br>
<ul>
<li>win64</li>


</ul>


</li>
<li>UNIX x86:<br>
<ul>
<li>sysv</li>
<li>unix64</li>


</ul>


</li>
<li>UNIX ARM:<br>
<ul>
<li>sysv</li>
<li>vfp</li>


</ul>


</li>


</ul>


</li>


</ul>
<h4><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">NativeCallback</span></h4>
<ul>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">new NativeCallback(func, returnType, argTypes[, abi]):&nbsp;使用JavaScript函数&nbsp;func&nbsp;来创建一个Native函数，其中returnType和argTypes分别指定函数的返回类型和参数类型数组。如果不想使用系统默认的&nbsp;abi&nbsp;类型，则可以指定&nbsp;abi&nbsp;这个参数。关于argTypes和abi类型，可以查看NativeFunction来了解详细信息，这个对象的返回类型也是NativePointer类型，因此可以作为&nbsp;Interceptor.replace&nbsp;的参数使用。</span></li>


</ul>
<h4><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">SystemFunction</span></h4>
<ul>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">new SystemFunction(address, returnType, argTypes[, abi]):&nbsp;功能基本和NativeFunction一致，但是使用这个对象可以获取到调用线程的last error状态，返回值是对平台相关的数值的一层封装，为value对象，比如是对这两个值的封装，&nbsp;errno(UNIX) 或者&nbsp;lastError(Windows)。</span></li>


</ul>
<h4><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">Socket</span></h4>
<h4><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">SocketListener</span></h4>
<h4><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">SocketConnection</span></h4>
<h4><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">IOStream</span></h4>
<h4><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">InputStream</span></h4>
<h4><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">OutputStream</span></h4>
<h4><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">UnixInputStream</span></h4>
<h4><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">UnixOutputStream</span></h4>
<h4><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">Win32InputStream</span></h4>
<h4><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">Win32OutputStream</span></h4>
<h4><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">File</span></h4>
<h4><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">SqliteDatabase</span></h4>
<h4><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">SqliteStatement</span></h4>
<h4><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">Interceptor</span></h4>
<ul>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">Interceptor.attach(target, callbacks):&nbsp;在target指定的位置进行函数调用拦截，target是一个NativePointer参数，用来指定你想要拦截的函数的地址，有一点需要注意，在32位ARM机型上，ARM函数地址末位一定是0（2字节对齐），Thumb函数地址末位一定1（单字节对齐），如果使用的函数地址是用Frida API获取的话， 那么API内部会自动处理这个细节（比如：Module.findExportByName()）。其中callbacks参数是一个对象，大致结构如下：<br>事实上Frida可以在代码的任意位置进行拦截，但是这样一来&nbsp;callbacks&nbsp;回调的时候，因为回调位置有可能不在函数的开头，这样onEnter这样的回调参数Frida只能尽量的保证（比如拦截的位置前面的代码没有修改过传入的参数），不能像在函数头那样可以确保正确。</span>
<ul>
<li>onEnter: function(args):&nbsp;被拦截函数调用之前回调，其中原始函数的参数使用args数组（NativePointer对象数组）来表示，可以在这里修改函数的调用参数。</li>
<li>onLeave: function(retval):&nbsp;被拦截函数调用之后回调，其中retval表示原始函数的返回值，retval是从NativePointer继承来的，是对原始返回值的一个封装，你可以使用retval.replace(1337)调用来修改返回值的内容。需要注意的一点是，retval对象只在 onLeave函数作用域范围内有效，因此如果你要保存这个对象以备后续使用的话，一定要使用深拷贝来保存对象，比如：ptr(retval.toString())。</li>


</ul>


</li>
<li></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">拦截器的attach调用返回一个监听对象，后续取消拦截的时候，可以作为&nbsp;Interceptor.detach()&nbsp;的参数使用。</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">还有一个比较方便的地方，那就是在回调函数里面，包含了一个隐藏的&nbsp;this&nbsp;的线程tls对象，方便在回调函数中存储变量，比如可以在 onEnter 中保存值，然后在 onLeave 中使用，看一个例子：</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px"><img src="https://zhuanlan.kanxue.com/upload/attach/201711/126904_pt07bmdzpkpvnsea.png" alt="" title=""></span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">另外，this&nbsp;对象还包含了一些额外的比较有用的属性：<br>Interceptor.detachAll():&nbsp;取消之前所有的拦截调用</span>
<ul>
<li>returnAddress:&nbsp;返回NativePointer类型的 address 对象</li>
<li>context:&nbsp;包含 pc，sp，以及相关寄存器比如 eax, ebx等，可以在回调函数中直接修改</li>
<li>errno:&nbsp;（UNIX）当前线程的错误值</li>
<li>lastError:&nbsp;(Windows) 当前线程的错误值</li>
<li>threadId:&nbsp;操作系统线程Id</li>
<li>depth:&nbsp;函数调用层次深度</li>
<li>看个例子：</li>
<li><img src="https://zhuanlan.kanxue.com/upload/attach/201711/126904_bu3pqx34pg2xj8al.png" alt="" title=""></li>
<li><img src="https://zhuanlan.kanxue.com/upload/attach/201711/126904_hukqu3msxqvwrd2q.png" alt="" title=""></li>


</ul>


</li>
<li></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">Interceptor.replace(target, replacement):&nbsp;函数实现代码替换，这种情况主要是你想要完全替换掉一个原有函数的实现的时候来使用，注意replacement参数使用JavaScript形式的一个NativeCallback来实现，后续如果想要取消这个替换效果，可以使用&nbsp;Interceptor.revert调用来实现，如果你还想在你自己的替换函数里面继续调用原始的函数，可以使用以 target 为参数的NativeFunction对象来调用，来看一个例子：</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px"><img src="https://zhuanlan.kanxue.com/upload/attach/201711/126904_ptr68t3qpmeuh8qj.png" alt="" title=""></span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">Interceptor.revert(target):&nbsp;还原函数的原始实现逻辑，即取消前面的&nbsp;Interceptor.replace调用</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">Interceptor.flush():&nbsp;确保之前的内存修改操作都执行完毕，并切已经在内存中发生作用，只要少数几种情况需要这个调用，比如你刚执行了&nbsp;attach()&nbsp;或者&nbsp;replace()&nbsp;调用，然后接着想要使用NativeFunction对象对函数进行调用，这种情况就需要调用flush。正常情况下，缓存的调用操作会在当前线程即将离开JavaScript运行时环境或者调用send()的时候自动进行flush操作，也包括那些底层会调用 send() 操作的函数，比如 RPC 函数，或者任何的 console API</span></li>


</ul>
<h4><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">Stalker</span></h4>
<ul>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">Stalker.follow([threadId, options]):&nbsp;开始监视线程ID为&nbsp;threadId（如果是本线程，可以省略）的线程事件，举个例子：</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px"><img src="https://zhuanlan.kanxue.com/upload/attach/201711/126904_mcpybrhk68mdrlfw.png" alt="" title=""></span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px"><img src="https://zhuanlan.kanxue.com/upload/attach/201711/126904_lu2xii1iohvxdqso.png" alt="" title=""></span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">Stalker.unfollow([threadId]):&nbsp;停止监控线程事件，如果是当前线程，则可以省略 threadId 参数</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">Stalker.parse(events[, options]):&nbsp;按照指定格式介些&nbsp;GumEvent二进制数据块，按照options的要求格式化输出，举个例子：</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px"><img src="https://zhuanlan.kanxue.com/upload/attach/201711/126904_ljqva6r3gjjhl7mq.png" alt="" title=""></span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">Stalker.garbageCollect():&nbsp;在调用Stalker.unfollow()之后，在一个合适的时候，释放对应的内存，可以避免多线程竞态条件下的内存释放问题。</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">Stalker.addCallProbe(address, callback):&nbsp;当address地址处的函数被调用的时候，调用callback对象（对象类型和Interceptor.attach.onEnter一致），返回一个Id，可以给后面的Stalker.removeCallProbe使用</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">Stalker.removeCallProbe():&nbsp;移除前面的&nbsp;addCallProbe&nbsp;调用效果。</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">Stalker.trustThreshold:&nbsp;指定一个整型x，表示可以确保一段代码在执行x次之后，代码才可以认为是可靠的稳定的， -1表示不信任，0表示持续信任，N表示执行N次之后才是可靠的，稳定的，默认值是1。</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">Stalker.queueCapacity:&nbsp;指定事件队列的长度，默认长度是16384</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">Stalker.queueDrainInterval:&nbsp;事件队列查询派发时间间隔，默认是250ms，也就是说1秒钟事件队列会轮询4次</span></li>


</ul>
<h4><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">ApiResolver</span></h4>
<ul>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">new ApiResolver(type):&nbsp;创建指定类型type的API查找器，可以根据函数名称快速定位到函数地址，根据当前进程环境不同，可用的ApiResolver类型也不同，到目前为止，可用的类型有：<br></span>
<ul>
<li>Module:&nbsp;枚举当前进程中已经加载的动态链接库的导入导出函数名称。</li>
<li>objc:&nbsp;定位已经加载进来的Object-C类方法，在macOS和iOS进程中可用，可以使用&nbsp;Objc.available&nbsp;来进行运行时判断，或者在&nbsp;try-catch&nbsp;块中使用&nbsp;new ApiResolver(‘objc’)&nbsp;来尝试创建。</li>
<li>解析器在创建的时候，会加载最小的数据，后续使用懒加载的方式来持续加载剩余的数据，因此最好是一次相关的批量调用使用同一个resolver对象，然后下次的相关操作，重新创建一个resolver对象，避免使用上个resolver的老数据。</li>


</ul>


</li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">enumerateMatches(query, callbacks):&nbsp;执行函数查找过程，按照参数query来查找，查找结果调用callbacks来回调通知：<br>enumerateMatchesSync(query):&nbsp;enumerateMatches()的同步版本，直接返回所有结果的数组形式</span>
<ul>
<li>onMatch: function(match):&nbsp;每次枚举到一个函数，调用一次，回调参数match包含name和address两个属性。</li>
<li>onComplete: function():&nbsp;整个枚举过程完成之后调用。</li>
<li>举个例子：</li>
<li><img src="https://zhuanlan.kanxue.com/upload/attach/201711/126904_imb25pmh42b1a19v.png" alt="" title=""></li>


</ul>


</li>
<li></li>


</ul>
<h4><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">DebugSymbol</span></h4>
<ul>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">DebugSymbol.fromAddress(address), DebugSymbol.fromName(name):&nbsp;在指定地址或者指定名称查找符号信息，返回的符号信息对象包含下面的属性：<br>DebugSymbol.getFunctionByName(name), DebugSymbol.findFunctionsNamed(name), DebugSymbol.findFunctionsMatching(glob):&nbsp;这三个函数，都是根据符号信息来查找函数，结果返回&nbsp;NativePointer&nbsp;对象。</span>
<ul>
<li>address:&nbsp;当前符号的地址，NativePointer</li>
<li>name:&nbsp;当前符号的名称，字符串形式</li>
<li>moduleName:&nbsp;符号所在的模块名称</li>
<li>fileName:&nbsp;符号所在的文件名</li>
<li>lineNumber:&nbsp;符号所在的文件内的行号</li>
<li>为了方便使用，也可以在这个对象上直接使用&nbsp;toString()&nbsp;，输出信息的时候比较有用，比如和&nbsp;Thread.backtrace&nbsp;配合使用，举个例子来看：</li>
<li><img src="https://zhuanlan.kanxue.com/upload/attach/201711/126904_g0qdcj6nxr5g7f0b.png" alt="" title=""></li>


</ul>


</li>
<li></li>


</ul>
<h4><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">Instruction</span></h4>
<ul>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">Instruction.parse(target):&nbsp;在&nbsp;target&nbsp;指定的地址处解析指令，其中target是一个NativePointer。注意，在32位ARM上，ARM函数地址需要是2字节对齐的，Thumb函数地址是1字节对齐的，如果你是使用Frida本身的函数来获取的target地址，Frida会自动处理掉这个细节，parse函数返回的对象包含如下属性：<br></span>
<ul>
<li>address:&nbsp;当前指令的EIP，NativePointer类型</li>
<li>next:&nbsp;下条指令的地址，可以继续使用parse函数</li>
<li>size:&nbsp;当前指令大小</li>
<li>mnemonic:&nbsp;指令助记符</li>
<li>opStr:&nbsp;字符串格式显示操作数</li>
<li>operands:&nbsp;操作数数组，每个操作数对象包含type和value两个属性，根据平台不同，有可能还包含一些额外属性</li>
<li>regsRead:&nbsp;这条指令显式进行读取的寄存器数组</li>
<li>regsWritten:&nbsp;这条指令显式的写入的寄存器数组</li>
<li>groups:&nbsp;该条指令所属的指令分组</li>
<li>toString():&nbsp;把指令格式化成一条人比较容易读懂的字符串形式</li>
<li>关于operands和groups的细节，请参考CapStone文档</li>


</ul>


</li>


</ul>
<h4><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">ObjC</span></h4>
<h4><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">Java</span></h4>
<ul>
<ul>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">Java.available:&nbsp;布尔型取值，表示当前进程中是否存在完整可用的Java虚拟机环境，Dalvik或者Art，建议在使用Java方法之前，使用这个变量来确保环境正常。</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">Java.enumerateLoadedClasses(callbacks):&nbsp;枚举当前进程中已经加载的类，每次枚举到加载的类回调callbacks:<br>Java.enumerateLoadedClassesSync():&nbsp;同步枚举所有已经加载的类</span>
<ul>
<li>onMatch: function(className):&nbsp;枚举到一个类，以类名称进行回调，这个类名称后续可以作为&nbsp;Java.use()&nbsp;的参数来获取该类的一个引用对象。</li>
<li>onComplete: function():&nbsp;所有的类枚举完毕之后调用</li>


</ul>


</li>
<li></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">Java.use(fn):&nbsp;把当前线程附加到Java VM环境中去，并且执行Java函数fn（如果已经在Java函数的回调中，则不需要再附加到VM），举个例子：</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px"><img src="https://zhuanlan.kanxue.com/upload/attach/201711/126904_7ig91y2pjc88v9gc.png" alt="" title=""></span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">Java.use(className):&nbsp;对指定的类名动态的获取这个类的JavaScript引用，后续可以使用$new()来调用类的构造函数进行类对象的创建，后续可以主动调用&nbsp;$dispose()&nbsp;来调用类的析构函数来进行对象清理（或者等待Java的垃圾回收，再或者是JavaScript脚本卸载的时候），静态和非静态成员函数在JavaScript脚本里面也都是可见的， 你可以替换Java类中的方法，甚至可以在里面抛出异常，比如：</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px"><img src="https://zhuanlan.kanxue.com/upload/attach/201711/126904_6y9oju0sdo3z3wzx.png" alt="" title=""></span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">Java.scheduleOnMainThread(fn):&nbsp;在虚拟机主线程上执行函数fn</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">Java.choose(className, callbacks):&nbsp;在Java的内存堆上扫描指定类名称的Java对象，每次扫描到一个对象，则回调callbacks:<br>Java.cast(handle, klass):&nbsp;使用对象句柄handle按照klass（Java.use方法返回）的类型创建一个对象的JavaScript引用，这个对象引用包含一个class属性来获取当前对象的类，也包含一个$className属性来获取类名称字符串，比如：</span>
<ul>
<li>onMatch: function(instance):&nbsp;每次扫描到一个实例对象，调用一次，函数返回stop结束扫描的过程</li>
<li>onComplete: function():&nbsp;当所有的对象都扫描完毕之后进行回调</li>


</ul>


</li>
<li></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px"><img src="https://zhuanlan.kanxue.com/upload/attach/201711/126904_rebi2a4rwc0iwzul.png" alt="" title=""></span></li>


</ul>

</ul>
<p><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">&nbsp;</span></p>
<h2><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">篇三</span></h2>
<h3><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">JavaScript API</span></h3>
<h4><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">WeakRef</span></h4>
<ul>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">WeakRef.bind(value, fn):&nbsp;监控value对象，当被监控的对象即将被垃圾回收或者脚本即将被卸载的时候，调用回调函数fn，bind返回一个唯一ID，后续可以使用这个ID进行&nbsp;WeakRef.unbind()调用来取消前面的监控。这个API还是很有用处的，比如你想要在JavaScript的某个对象销毁的时候跟着销毁一些本地资源，这种情况下，这个机制就比较有用了。</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">WeakRef.unbind(id):&nbsp;停止上述的对象监控，并且会立即调用一次f n</span></li>

</ul>
<h4><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">x86Writer</span></h4>
<ul>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">new X86Writer(codeAddress[, {pc: ptr(‘0x1234’)}]):&nbsp;创建一个x86机器码生成器，并且在codeAddress指向的内存进行写入，codeAddress是NativePointer类型，第二个参数是可选参数，用来指定程序的初始EIP。在iOS系统上，使用Memory.patchCode()的时候，指定初始EIP是必须的，因为内存写入是先写入到一个临时的位置，然后再映射到指定位置的内存</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">reset(codeAddress[, { pc: ptr(‘0x1234’) }]):&nbsp;取消codeAddress位置的上次的代码写入</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">dispose():&nbsp;立即进行X86相关的内存修改清理</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">flush():&nbsp;代码中标签引用的解析，操作缓存立即应用到内存中去。在实际的应用中，当生成一段代码片段的时候，就应该调用一次这个函数。多个相关联的函数片段在一起使用的时候，也应该调用一次，尤其是要在一起协同运行的几个函数片段。</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">base:&nbsp;输出结果的第一个字节码的内存位置，NativePointer类型</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">code:&nbsp;输出结果的下一个字节码的内存位置，NativePointer类型</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">pc:&nbsp;输出结果的指令指针的内存位置，NativePointer类型</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">offset:&nbsp;当前的偏移（JavaScript数值）</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">putLabel(id):&nbsp;在当前位置插入一个标签，标签用字符串id表示</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">putCallAddressWithArguments(fund, args):&nbsp;准备好一个调用C函数的上下文环境，其中args表示被调用函数的参数数组（JavaScript数组），数组里面可以是字符串形式指定的寄存器，可以是一个数值，也可以是一个指向立即数的NativePointer</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">putCallAddressWithAlignedArguments(func, args):&nbsp;跟上面一个函数差不多，但是参数数组是16字节对齐的</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">putCallRegWithArguments(reg, args):&nbsp;准备好一个调用C函数的上下文环境，其中args表示被调用函数的参数数组（JavaScript数组），数组里面可以是字符串形式指定的寄存器，可以是一个数值，也可以是一个指向立即数的NativePointer</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">putCallRegWithAlignedArguments(reg, args):&nbsp;参数数组16字节对齐</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">putCallRegOffsetPtrWithArguments(reg, offset, args):&nbsp;准备好一个调用C函数的上下文环境，其中args表示被调用函数的参数数组（JavaScript数组），数组里面可以是字符串形式指定的寄存器，可以是一个数值，也可以是一个指向立即数的NativePointer</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">putCallAddress(address):&nbsp;写入一个Call指令</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">putCallReg(reg):&nbsp;写入一个Call指令</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">putCallRegOffsetPtr(reg, offset):&nbsp;写入一个Call指令</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">putCallIndirect(addr):&nbsp;写入一个Call指令</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">putCallNearLabel(labelId):&nbsp;在前面定义的Label处创建一个Call 指令</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">putLeave():&nbsp;创建一个 LEAVE 指令</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">putRet():&nbsp;创建一个 RET 指令</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">putRetImm(immValue):&nbsp;创建一个RET指令</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">putJmpShortLabel(labelId):&nbsp;创建一个JMP指令，跳转到labelId标志的位置</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">putJmpNearLabel(labelId):&nbsp;创建一个JMP指令，跳转到labelId标志的位置</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">putJmpReg(reg):&nbsp;创建一个JMP指令</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">putJmpRegPtr(reg):&nbsp;创建一个JMP指令</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">putJmpRegOffsetPtr(reg, offset):&nbsp;创建一个JMP指令</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">putJmpNearPtr(address):&nbsp;创建一个JMP指令</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">putJccShort(labelId, target, hint):&nbsp;创建一个JCC指令</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">putJccNear(labelId, target, hint):&nbsp;在labelId处创建一个JCC指令</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">putAddRegImm(reg, immValue)</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">putAddRegReg</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">putAddRegNearPtr(dstReg, srcAddress)</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">putSubRegImm(reg, immValue)</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">putSubRegReg(dstReg, srcReg)</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">putSubRegNearPtr(dstReg, srcAddress)</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">putIncReg(reg)</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">putDecReg(reg)</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">putIncRegPtr(target, reg)</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">putDecRegPtr(target, reg)</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">putLockXaddRegPtrReg(dstReg, srcReg)</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">putLockIncImm32Ptr(target)</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">putLockDecImm32Ptr(target)</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">putAddRegReg(dstReg, srcReg)</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">putAddRegU32(reg, immValue)</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">putShlRegU8(reg, immValue)</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">putShrRegU8(reg, immValue)</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">putXorRegReg(dstReg, srcReg)</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">putMovRegReg(dstReg, srcReg)</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">putMovRegU32(dstReg, immValue)</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">putMovRegU64(dstReg, immValue)</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">putMovRegAddress(dstReg, immValue)</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">putMovRegPtrU32(dstReg, immValue)</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">putMovRegOffsetPtrU32(dstReg, dstOffset, immValue)</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">putMovRegPtrReg(dstReg, srcReg)</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">putMovRegOffsetPtrReg(dstReg, dstOffset, srcReg)</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">putMovRegRegPtr(dstReg, srcReg)</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">putMovRegRegOffsetPtr(dstReg, srcReg, srcOffset)</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">putMovRegBaseIndexScaleOffsetPtr(dstReg, baseReg, indexReg, scale, offset)</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">putMovRegNearPtr(dstReg, srcAddress)</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">putMovNearPtrReg(dstAddress, srcReg)</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">putMovFsU32PtrReg(fsOffset, srcReg)</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">putMovRegFsU32Ptr(dstReg, fsOffset)</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">putMovGsU32PtrReg(fsOffset, srcReg)</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">putMovqXmm0EspOffsetPtr(offset)</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">putMovqEaxOffsetPtrXmm0(offset)</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">putMovdquXmm0EspOffsetPtr(offset)</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">putMovdquEaxOffsetPtr(offset)</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">putLeaRegRegOffset(dstReg, srcReg, srcOffset)</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">putXchgRegRegPtr(leftReg, rightReg)</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">putPushU32(immValue)</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">putPushNearPtr(address)</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">putPushReg(reg)</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">putPopReg(reg)</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">putPushImmPtr(immPtr)</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">putPushax()</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">putPopax()</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">putPushfx()</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">putPopfx()</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">putTestRegReg(regA, regB)</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">putTestRegU32(reg, immValue)</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">putCmpRegI32(reg, immValue)</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">putCmpRegOffsetPtrReg(regA, offset, regB)</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">putCmpImmPtrImmU32(immPtr, immValue)</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">putCmpRegReg(regA, regB)</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">putClc()</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">putStc()</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">putCld()</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">putStd()</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">putCpuid()</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">putLfence()</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">putRdtsc()</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">putPause()</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">putNop()</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">putBreakpoint()</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">putPadding(n)</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">putNopPadding(n)</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">putU8(value)</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">putS8(value)</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">putBytes(data)&nbsp;从ArrayBuffer中拷贝原始数据</span></li>

</ul>
<h4><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">X86Relocator</span></h4>
<ul>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">new X86Relocator(inputCode, output):&nbsp;创建一个代码重定位器，用以进行代码从一个位置拷贝到另一个位置的时候进行代码重定位处理，源地址是&nbsp;inputCode的NativePointer，output表示结果地址，可以用X86Writer对象来指向目的内存地址</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">reset(inputCode, output):&nbsp;回收上述的X86Relocator对象</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">dispose():&nbsp;内存清理</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">input:&nbsp;最后一次读取的指令， 一开始是null，每次调用readOne()会自动改变这个属性</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">eob:&nbsp;表示当前是否抵达了块结尾，比如是否遇到了下列任何一个指令：CALL, JMP, BL, RET</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">eoi:&nbsp;表示input代表的属性是否结束，比如可能当前遇到了下列的指令：JMP, B, RET，这些指令之后可能没有有效的指令了</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">readOne():&nbsp;把一条指令读入relocator的内部缓存，返回目前已经读入缓存的总字节数，可以持续调用readOne函数来缓存指令，或者立即调用writeOne()或者skipOne()，也可以一直缓存到指定的点，然后一次性调用writeAll()。如果已经到了eoi，则函数返回0， 此时eoi属性也是true</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">peekNextWriteInsn():&nbsp;peek一条指令出来，以备写入或者略过</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">peekNextWriteSource():&nbsp;在指定地址peek一条指令出来，以备写入或者略过</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">skipOne():&nbsp;忽略下一条即将写入的指令</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">skipOneNoLabel():&nbsp;忽略下一条即将写入的指令，如果遇到内部使用的Label则不忽略，这个函数是对skipOne的优化，可以让重定位范围覆盖的更全面</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">writeOne():&nbsp;写入下条缓存指令</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">writeOneNoLabel()</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">writeAll():&nbsp;写入所有缓存的指令</span></li>

</ul>
<h4><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">x86枚举类型</span></h4>
<ul>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">寄存器：xar, xcx, xdx, xbx, tsp, xbp, xsi, xdi, sax, ecx, edx, ebx, esp, ebx, esi, edi, rax, rcx, rdx, rbx, rsp, rbp, rsi, rdi, r8, r9, r10, r11, r12, r13, r14, r15, r8d, r9d, r10d, r11d, r12d, r13d, r14d, r15d, xip, eip, rip</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">跳转指令：jo, jno, jb, jae, je, jne, jbe, ja, js, jns, jp, jnp, jl, jge, jle, jg, jcxz, jecxz, jrcxz</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">分支提示：no-hint, likely, unlikely</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">指针类型：byte, sword, qword</span></li>

</ul>
<h4><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">ArmWriter(参考X86Writer)</span></h4>
<ul>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">new ArmWriter(codeAddress[, {pc: ptr(‘0x1234’)}])</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">reset(codeAddress[, {pc: ptr(‘0x1234’)}])</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">dispose()</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">flush()</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">base</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">code</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">pc</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">offset</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">skip(nBytes)</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">putBImm(target)</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">putLdrRegAddress(reg, address)</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">putLdrRegU32(reg, val)</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">putAddRegRegImm(dstReg, srcReg, immVal)</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">putLdrRegRegImm(dstReg, srcReg, immVal)</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">putNop()</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">putBreakpoint()</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">putInstruction(insn)</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">putBytes(data)</span></li>

</ul>
<h4><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">ArmRelocator(参考X86Relocator)</span></h4>
<h4><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">ThumbRelocator(参考X86Relocator)</span></h4>
<h4><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">Arm enum types</span></h4>
<ul>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">寄存器：r0~r15, sp, lr, sb, sl, fp, ip, pc</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">条件码：eq, ne, hs, lo, mi, pl, vs, vc, hi, ls, ge, lt, gt, le, al</span></li>

</ul>
<h4><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">Arm64Writer(参考X86Writer)</span></h4>
<h4><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">Arm64Relocator(参考X86Relocator)</span></h4>
<h4><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">AArch64 enum types</span></h4>
<ul>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">寄存器：x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 x13 x14 x15 x16 x17 x18 x19 x20 x21 x22 x23 x24 x25 x26 x27 x28 x29 x30 w0 w1 w2 w3 w4 w5 w6 w7 w8 w9 w10 w11 w12 w13 w14 w15 w16 w17 w18 w19 w20 w21 w22 w23 w24 w25 w26 w27 w28 w29 w30 sp lr fp wsp wzr xzr nzcv ip0 ip1 s0 s1 s2 s3 s4 s5 s6 s7 s8 s9 s10 s11 s12 s13 s14 s15 s16 s17 s18 s19 s20 s21 s22 s23 s24 s25 s26 s27 s28 s29 s30 s31 d0 d1 d2 d3 d4 d5 d6 d7 d8 d9 d10 d11 d12 d13 d14 d15 d16 d17 d18 d19 d20 d21 d22 d23 d24 d25 d26 d27 d28 d29 d30 d31 q0 q1 q2 q3 q4 q5 q6 q7 q8 q9 q10 q11 q12 q13 q14 q15 q16 q17 q18 q19 q20 q21 q22 q23 q24 q25 q26 q27 q28 q29 q30 q31</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">条件码：eq ne hs lo mi pl vs vc hi ls ge lt gt le al nv</span></li>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">索引模式：post-adjust signed-offset pre-adjust</span></li>

</ul>
<h4><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">MipsWriter(参考X86Writer)</span></h4>
<h4><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">MipsRelocator(参考X86Relocator)</span></h4>
<h4><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">MIPS enum types</span></h4>
<ul>
<li><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">寄存器：v0 v1 a0 a1 a2 a3 t0 t1 t2 t3 t4 t5 t6 t7 s0 s1 s2 s3 s4 s5 s6 s7 t8 t9 k0 k1 gp sp fp s8 ra hi lo zero at 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31</span></li>

</ul>
<p><span style="font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">&nbsp;</span></p>
</div>
<div class="clear"></div>
<div id="blog_post_info_block" role="contentinfo">
    <div id="blog_post_info"></div>
    <div class="clear"></div>
    <div id="post_next_prev"></div>
</div>
            </div>
            <div class="postDesc">posted @ 
<span id="post-date">2020-08-01 14:53</span>&nbsp;
<a href="https://www.cnblogs.com/Eeyhan/">Eeyhan</a>&nbsp;
阅读(<span id="post_view_count">1312</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=13414629" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(13414629);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '13414629', targetLink: 'https://www.cnblogs.com/Eeyhan/p/13414629.html', title: 'Python爬虫之app逆向 frida javascript api手册' })">举报</a></div>
        </div>
	    
	    
    </div><!--end: topics 文章、评论容器-->
</div>

<script>
    var cb_entryId = 13414629, cb_entryCreatedDate = '2020-08-01 14:53', cb_postType = 1, cb_postTitle = 'Python爬虫之app逆向 frida javascript api手册';
    var allowComments = true, cb_blogId = 385429, cb_blogApp = 'Eeyhan', cb_blogUserGuid = 'f479cd25-329d-4e4d-fb0b-08d4ef52ecb5';
    mermaidRender.render()
    markdown_highlight()
    zoomManager.apply("#cnblogs_post_body img:not(.code_img_closed):not(.code_img_opened)");
    updatePostStats(
            [cb_entryId],
            function(id, count) { $("#post_view_count").text(count) },
            function(id, count) { $("#post_comment_count").text(count) })
</script>
<a id="!comments"></a>
<div id="blog-comments-placeholder"></div>
<div id="comment_form" class="commentform">
    <a name="commentform"></a>
    <div id="divCommentShow"></div>
    <div id="comment_nav"><span id="span_refresh_tips"></span><a href="javascript:void(0);" onclick="return RefreshCommentList();" id="lnk_RefreshComments" runat="server" clientidmode="Static">刷新评论</a><a href="#" onclick="return RefreshPage();">刷新页面</a><a href="#top">返回顶部</a></div>
    <div id="comment_form_container"></div>
    <div class="ad_text_commentbox" id="ad_text_under_commentbox"></div>
        <div id="cnblogs_ch"></div>
    <div id="opt_under_post"></div>
    <div id="cnblogs_c1" class="under-post-card">
            <div id='div-gpt-ad-1592365906576-0' style='width: 300px; height: 250px;'></div>
    </div>
    <div id="under_post_card1"></div>
    <div id="under_post_card2"></div>
    <div id="HistoryToday" class="under-post-card"></div>
    <script type="text/javascript">
        var commentManager = new blogCommentManager();
        commentManager.renderComments(0);
        fixPostBody();

            window.tocManager.displayDisableTocTips = false;
            window.tocManager.generateToc();
            
                setTimeout(function() { countViews(cb_blogId, cb_entryId); }, 50);
            
            deliverT2();
            deliverC1C2();
            loadNewsAndKb();
            
                LoadPostCategoriesTags(cb_blogId, cb_entryId);
            
            LoadPostInfoBlock(cb_blogId, cb_entryId, cb_blogApp, cb_blogUserGuid);
            GetPrevNextPost(cb_entryId, cb_blogId, cb_entryCreatedDate, cb_postType);
            loadOptUnderPost();
            GetHistoryToday(cb_blogId, cb_blogApp, cb_entryCreatedDate);
                </script>
</div>

	</div><!--end: forFlow -->
	</div><!--end: mainContent 主体内容容器-->
	<div id="sideBar">
		<div id="sideBarMain">
			<div id="sidebar_news" class="newsItem">
            <script>loadBlogNews();</script>
</div>
<div id="sidebar_c3"></div>
			<div id="blog-calendar" style="display:none"></div><script>loadBlogDefaultCalendar();</script>			
			<div id="leftcontentcontainer">
				<div id="blog-sidecolumn"></div>
                    <script>loadBlogSideColumn();</script>
			</div>			
		</div><!--end: sideBarMain -->
	</div><!--end: sideBar 侧边栏容器 -->
	<div class="clear"></div>
	</div><!--end: main -->
	<div class="clear"></div>
	<div id="footer">
		<!--done-->
Copyright &copy; 2022 Eeyhan
<br /><span id="poweredby">Powered by .NET 6 on Kubernetes</span>



	</div><!--end: footer -->
</div><!--end: home 自定义的最大容器 -->





<input type="hidden" id="antiforgery_token" value="CfDJ8EOBBtWq0dNFoDS-ZHPSe52k1eR5gtPY8dpDkSfxDByaWlSiUg-iW_GgbzG3JNnceMlzgZuIEk9tCyPUDVtBXkPAlR7IAm6lwZN7Cxd-fqDL-ZCav7n7CO481Tx5WK-Lp8w6L8333twDHAEGfu2udOI"/>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-476124-1"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    var kv = getGACustom();
    if (kv) {
        gtag('set', kv);
    }
    gtag('config', 'UA-476124-1');
</script>
<script defer src="https://hm.baidu.com/hm.js?866c9be12d4a814454792b1fd0fed295"></script>
</body>
</html>