
// 非 npm 包 frida-gum 18.1 的类型定义
// 项目：https://github.com/frida/frida
// 定义：Ole André Vadla Ravnås <https://github.com/oleavr>
// 弗朗切斯科·塔马尼 <https://github.com/mrmacete>
// 定义：https://github.com/DefinitelyTyped/DefinitelyTyped
// 最低 TypeScript 版本：4.1

/**
* 返回提供的 ArrayBuffer 或 NativePointerValue 目标的十六进制转储。
*
* @param target 要转储的 ArrayBuffer 或 NativePointerValue。
* @param options 自定义输出的选项。
*/
声明 函数 hexdump （目标：ArrayBuffer  |  NativePointerValue ， 选项？：HexdumpOptions ）：字符串；

接口 HexdumpOptions  {
    /**
     * 指定开始转储的字节偏移量。默认为 0。
     */
    偏移量？：数字 |  未定义；

    /**
     * 限制要转储的字节数。
     */
    长度？：数字 |  未定义；

    /**
     * 是否应包含标题。默认为真。
     */
    标头？：布尔值 |  未定义；

    /**
     * 是否应该使用 ANSI 颜色。默认为假。
     */
    ansi ?:布尔值 |  未定义；
}

/**
* `new Int64(value)` 的简写。
*/
声明 函数 int64 （值：字符串 | 数字）：Int64 ；

/**
* `new UInt64(value)` 的简写。
*/
声明 函数 uint64 （值：字符串 | 数字）：UInt64 ；

/**
* `new NativePointer(value)` 的简写。
*/
声明 函数 ptr （值：字符串 | 数字）：NativePointer ；

/**
* `ptr("0")` 的简写。
*/
声明 const  NULL : NativePointer ;

/**
* 请求在从基于 Frida 的应用程序收到的下一条消息上调用回调。
*
* 这只会给你一条消息，所以你需要再次调用 `recv()` 来接收下一条。
*/
声明 函数 recv （回调：MessageCallback ）：MessageRecvOperation ；

/**
* 请求回调在收到给定"类型"的下一条消息时调用
* 基于 Frida 的应用程序。
*
* 这只会给你一条消息，所以你需要再次调用 `recv()` 来接收下一条。
*/
声明 函数 recv （类型：字符串， 回调：MessageCallback ）：MessageRecvOperation ；

接口 MessageCallback  {  （消息：任意， 数据：ArrayBuffer  |  null ）：无效； }

接口 MessageRecvOperation  {
    /**
     * 在收到消息并返回回调之前阻塞。
     */
    等待（）：无效；
}

/**
* 向基于 Frida 的应用程序发送 JSON 可序列化消息，
* 包含（可选）一些原始二进制数据。后者很有用
* 如果您使用 `NativePointer#readByteArray()` 转储了一些内存。
*
* @param message 任何 JSON 可序列化值。
* @param data 原始二进制数据。
*/
声明 函数 发送（消息：任何， 数据？：ArrayBuffer  |  number [ ]  |  null ）：void；

/**
* 在 `delay` 毫秒后调用 `func`，或者如果省略：只要 Frida 的
* JavaScript 线程空闲。任何额外的 `params` 都会被传递。
*
* 返回一个 id，可以传递给 `clearTimeout()` 来取消它。
*/
声明 函数 setTimeout ( func : ScheduledCallback ,  delay ?: number , ... params : any [ ] ) : TimeoutId ;

/**
* 取消之前安排的`setTimeout()`。
*/
声明 函数 clearTimeout （id：TimeoutId ）：void；

/**
* `setTimeout()` 返回的不透明 ID。将其传递给 `clearTimeout()` 以取消挂起的 `setTimeout()`。
*/
类型 TimeoutId  =  number ;

/**
* 每隔 `delay` 毫秒调用 `func`，可选地传递给它提供的参数。
* 返回一个可以传递给 clearInterval() 以取消它的 id。
*/
声明 函数 setInterval ( func : ScheduledCallback ,  delay : number , ... params : any [ ] ) : IntervalId ;

/**
* 取消之前安排的`setInterval()`。
*/
声明 函数 clearInterval ( id : IntervalId ) : void ;

/**
* `setInterval()` 返回的不透明 ID。将其传递给 `clearInterval()` 以取消挂起的 `setInterval()`。
*/
类型 IntervalId  =  number ;

/**
* 调度 `func` 在 Frida 的 JavaScript 线程上被调用，可选地传递给它提供的参数。
* 返回一个可以传递给 clearImmediate() 以取消它的 id。
*/
声明 函数 setImmediate ( func : ScheduledCallback , ... params : any [ ] ) : ImmediateId ;

/**
* 取消之前安排的 `clearImmediate()`。
*/
声明 函数 clearImmediate ( id : ImmediateId ) : void ;

/**
* `setImmediate()` 返回的不透明 ID。将其传递给 `clearImmediate()` 以取消挂起的 `setImmediate()`。
*/
类型 ImmediateId  =  number ;

类型 ScheduledCallback  =  ( ... params : any [ ] )  =>  void ;

声明 命名空间 RPC  {
    /**
     * 您可以替换或插入以向您的应用程序公开 RPC 样式 API 的空对象。
     * 键指定方法名称，值是您导出的函数。这个函数可以返回
     * 一个用于立即将其返回给调用者的普通值，或者一个用于异步返回的 Promise。
     */
    让 出口：RpcExports ；
}

接口 RpcExports  {
    [名称：字符串]：AnyFunction ；
}

类型 AnyFunction  =  ( ... args : any [ ] )  =>  any ;

声明 命名空间 弗里达 {
    /**
     * 当前的 Frida 版本。
     */
    常量 版本：字符串；

    /**
     * Frida 私有堆的当前大小（以字节为单位），由所有脚本和 Frida 自己的运行时共享。
     * 这对于密切关注您的仪器使用的内存占总消耗的内存量很有用
     *托管过程。
     */
    常量 堆大小：数字；
}

声明 命名空间 脚本 {
    /**
     * 正在使用的运行时。
     */
    常量 运行时：脚本运行时；

    /**
     * 在下一个滴答时运行 `func`，即当前本机线程退出时
     * JavaScript 运行时。任何额外的"参数"都会传递给它。
     */
    函数 nextTick ( func : ScheduledCallback , ...参数: any [ ] ) : void ;

    /**
     * 暂时阻止当前脚本被卸载。
     * 这是引用计数的，所以必须有一个匹配的 `unpin()`
     * 稍后发生。
     *
     * 通常用于 `Script.bindWeak()` 的回调中，当你需要时
     * 在另一个线程上安排清理。
     */
    功能 引脚（）：无效；

    /**
     * 反转之前的 `pin()`，因此可以卸载当前脚本。
     */
    函数 unpin ( ) : void ;

    /**
     * 开始监控 `target` 的生命周期。尽快调用"回调"
     * 值已被垃圾回收，或脚本即将获取
     * 卸载。
     *
     * 当您在需要释放的地方构建语言绑定时很有用
     * 不再需要 JS 值时的原生资源。
     *
     * 请注意，`callback` 不是意外捕获的闭包
     * `target` 并使其在其预期寿命之后保持活动状态。
     *
     * @param target 堆分配的 JavaScript 值来监控生命周期。
     * @param callback 当 `t​​arget` 被 GCed 时调用的函数。
     */
    函数 bindWeak （目标：任何， 回调：WeakRefCallback ）：WeakRefId ；

    /**
     * 停止监视传递给 `Script.bindWeak()` 的值并调用
     * 立即回调。
     *
     * @param id ID 由先前调用 `Script.bindWeak()` 返回。
     */
    函数 unbindWeak ( id : WeakRefId ) : void ;

    /**
     * 安装或卸载用于解决尝试的处理程序
     * 访问不存在的全局变量。
     *
     * 用于实现可能获取未知标识符的 REPL
     * 懒惰地从数据库中获取。
     *
     * @param handler 要安装的处理程序，或 `null` 卸载
     * 以前安装的处理程序。
     */
    函数 setGlobalAccessHandler （处理程序：GlobalAccessHandler  |  null ）：无效；
}

类型 ScriptRuntime  =  "DUK"  |  "V8" ；

键入 WeakRefCallback  =  ( )  =>  void；

/**
* `Script.bindWeak()` 返回的不透明 ID。将其传递给`Script.unbindWeak()`
* 停止监控目标值。
*/
类型 WeakRefId  =  number ;

接口 GlobalAccessHandler  {
    /**
     * 查询存在哪些额外的全局变量。
     */
    枚举( ) :字符串[ ] ;

    /**
     * 每当尝试访问不存在的全局变量时调用
     * 制成。返回 `undefined` 以将变量视为不存在。
     *
     * @param property 正在访问的不存在的全局名称。
     */
    获取（属性：字符串）：任何；
}

声明 命名空间 进程 {
    /**
     * 当前进程的PID。
     */
    常量 id：数字；

    /**
     * 当前进程的架构。
     */
    常量 拱：架构；

    /**
     * 当前进程的平台。
     */
    常量 平台：平台；

    /**
     * 虚拟内存页的大小（以字节为单位）。这用于使您的脚本更具可移植性。
     */
    常量 pageSize : number ;

    /**
     * 指针的大小（以字节为单位）。这用于使您的脚本更具可移植性。
     */
    常量 指针大小：数字；

    /**
     * Frida 是否会避免修改内存中的现有代码，并且不会尝试运行未签名的代码。
     * 目前此属性将始终设置为可选，除非您正在使用小工具并已配置
     * 它假定代码签名是必需的。该属性允许您确定拦截器是否
     * API 不受限制，修改代码或运行未签名代码是否安全。
     */
    常量 codeSigningPolicy : CodeSigningPolicy ;

    /**
     * 确定当前是否附加了调试器。
     */
    函数 isDebuggerAttached ( ) : boolean ;

    /**
     * 获取此线程的操作系统特定 ID。
     */
    函数 getCurrentThreadId ( ) : ThreadId ;

    /**
     * 枚举所有线程。
     */
    函数 enumerateThreads ( ) : ThreadDetails [ ] ;

    /**
     * 按地址查找模块。如果未找到，则返回 null。
     */
    函数 findModuleByAddress （地址：NativePointerValue ）：模块 |  空；

    /**
     * 按地址查找模块。如果未找到则抛​​出异常。
     */
    函数 getModuleByAddress （地址：NativePointerValue ）：模块；

    /**
     * 按名称查找模块。如果未找到，则返回 null。
     */
    函数 findModuleByName （名称：字符串）：模块 |  空；

    /**
     * 按名称查找模块。如果未找到则抛​​出异常。
     */
    函数 getModuleByName （名称：字符串）：模块；

    /**
     * 枚举当前加载的模块。
     */
    函数 enumerateModules ( ) :模块[ ] ;

    /**
     * 按地址查找内存范围。如果未找到，则返回 null。
     */
    函数 findRangeByAddress （地址：NativePointerValue ）：RangeDetails  |  空；

    /**
     * 按地址查找内存范围。如果未找到则抛​​出异常。
     */
    函数 getRangeByAddress （地址：NativePointerValue ）：RangeDetails ；

    /**
     * 枚举满足"说明符"的内存范围。
     *
     * @param specifier 要包含的范围类型。
     */
    函数 enumerateRanges （说明符：PageProtection  |  EnumerateRangesSpecifier ）：RangeDetails [ ] ；

    /**
     * 就像`enumerateRanges()`，但用于系统堆已知的单个内存分配。
     */
    函数 enumerateMallocRanges ( ) : RangeDetails [ ] ;

    /**
     * 安装一个进程范围的异常处理回调，它有机会
     * 在托管进程本身之前处理本机异常。
     *
     * 由您的回调决定如何处理异常。
     * 例如：
     * - 记录问题。
     * - 通过 `send()` 通知您的应用程序，然后通过阻塞 `recv()` 确认发送的数据
     * 收到。
     * - 修改寄存器和内存以从异常中恢复。
     *
     * 如果你确实处理了异常，你应该返回 `true`，在这种情况下
     * Frida 将立即恢复线程。如果你不返回`true`，
     * Frida 会将异常转发给宿主进程的异常
     * 处理程序，如果有，或者让操作系统终止进程。
     */
    函数 setExceptionHandler （回调：ExceptionHandlerCallback ）：无效；
}

声明 类 模块 {
    /**
     * 规范的模块名称。
     */
    名称：字符串；

    /**
     * 基址。
     */
    基：本地指针；

    /**
     * 大小以字节为单位。
     */
    大小：数字；

    /**
     * 完整的文件系统路径。
     */
    路径：字符串；

    /**
     * 枚举模块的导入。
     */
    enumerateImports ( ) : ModuleImportDetails [ ] ;

    /**
     * 枚举模块的导出。
     */
    enumerateExports ( ) : ModuleExportDetails [ ] ;

    /**
     * 枚举模块的符号。
     */
    enumerateSymbols ( ) : ModuleSymbolDetails [ ] ;

    /**
     * 枚举具有 `name` 的模块的内存范围，如 `Process#enumerateModules()` 中所示。
     *
     * @param protection 要包含的范围的最小保护。
     */
    enumerateRanges （保护：PageProtection ）：RangeDetails [ ] ;

    /**
     * 查找名为 `exportName` 的导出的绝对地址。
     *
     * 如果导出不存在，则返回 null。
     *
     * @param exportName 导出名称以查找地址。
     */
    findExportByName ( exportName : string ) : NativePointer  |  空；

    /**
     * 查找名为 `exportName` 的导出的绝对地址。
     *
     * 如果导出不存在，则抛出异常。
     *
     * @param exportName 导出名称以查找地址。
     */
    getExportByName ( exportName : string ) : NativePointer ;

    /**
     * 加载指定的模块。
     */
    静态 负载（名称：字符串）：模块；

    /**
     * 确保指定模块的初始化程序已运行。这在早期仪器中很重要，
     * 即代码在进程生命周期的早期运行，以便能够安全地与 API 交互。
     *
     * 一个这样的用例是与给定模块提供的 ObjC 类交互。
     */
    静态 确保初始化（名称：字符串）：无效；

    /**
     * 查找 `name` 模块的基地址。如果未加载模块，则返回 null。
     *
     * @param name 模块名称或路径。
     */
    静态 findBaseAddress （名称：字符串）：NativePointer  |  空；

    /**
     * 查找 `name` 模块的基地址。如果未加载模块，则引发异常。
     *
     * @param name 模块名称或路径。
     */
    静态 getBaseAddress （名称：字符串）：NativePointer ；

    /**
     * 在 `moduleName` 中查找名为 `exportName` 的导出的绝对地址。如果模块未知，您可以
     * 传递 null 而不是其名称，但这可能是一个代价高昂的搜索，应该避免。
     *
     * 如果模块或导出不存在，则返回 null。
     *
     * @param moduleName 模块名称或路径。
     * @param exportName 导出名称以查找地址。
     */
    静态 findExportByName ( moduleName : string  |  null ,  exportName : string ) : NativePointer  |  空；

    /**
     * 在 `moduleName` 中查找名为 `exportName` 的导出的绝对地址。如果模块未知，您可以
     * 传递 null 而不是其名称，但这可能是一个代价高昂的搜索，应该避免。
     *
     * 如果模块或导出不存在，则抛出异常。
     *
     * @param moduleName 模块名称或路径。
     * @param exportName 导出名称以查找地址。
     */
    静态 getExportByName ( moduleName : string  |  null ,  exportName : string ) : NativePointer ;
}

声明 类 ModuleMap  {
    /**
     * 创建一个新的模块映射，优化以确定给定内存地址属于哪个模块（如果有）。
     * 创建时对当前加载的模块进行快照，可以通过调用 `update()` 进行刷新。
     *
     * `filter` 参数是可选的，允许您传递用于过滤模块列表的函数。
     * 如果您只关心应用程序本身拥有的模块，这很有用，并且可以让您快速
     * 检查地址是否属于其模块之一。过滤器函数给出了模块的详细信息，并且必须
     * 为应该保留在地图中的每个模块返回 true。每次加载的每个模块都会调用它
     *地图已更新。
     *
     * @param filter 过滤函数来决定哪些模块保留在地图中。
     */
    构造函数（过滤器？：ModuleMapFilter ）；

    /**
     * 确定 `address` 是否属于任何包含的模块。
     *
     * @param address 可能属于地图中某个模块的地址。
     */
    有（地址：NativePointerValue ）：布尔值；

    /**
     * 按地址查找模块。如果未找到，则返回 null。
     *
     * @param address 可能属于地图中某个模块的地址。
     */
    查找（地址：NativePointerValue ）：模块 |  空；

    /**
     * 按地址查找模块。如果未找到则抛​​出异常。
     *
     * @param address 可能属于地图中某个模块的地址。
     */
    获取（地址：NativePointerValue ）：模块；

    /**
     * 和 `find()` 类似，但只返回 `name` 字段，这意味着当您不需要
     * 其他详情。如果未找到，则返回 null。
     *
     * @param address 可能属于地图中某个模块的地址。
     */
    findName （地址：NativePointerValue ）：字符串 |  空；

    /**
     * 就像 `get()`，但只返回 `name` 字段，这意味着当您不需要
     * 其他详情。如果未找到则抛​​出异常。
     *
     * @param address 可能属于地图中某个模块的地址。
     */
    getName （地址：NativePointerValue ）：字符串；

    /**
     * 和 `find()` 一样，但只返回 `path` 字段，这意味着当你不需要
     * 其他详情。如果未找到，则返回 null。
     *
     * @param address 可能属于地图中某个模块的地址。
     */
    findPath （地址：NativePointerValue ）：字符串 |  空；

    /**
     * 就像 `get()`，但只返回 `path` 字段，这意味着当您不需要
     * 其他详情。如果未找到则抛​​出异常。
     *
     * @param address 可能属于地图中某个模块的地址。
     */
    getPath （地址：NativePointerValue ）：字符串；

    /**
     * 更新地图。
     *
     * 您应该在加载或卸载模块后调用它，以避免对陈旧数据进行操作。
     */
    更新（）：无效；

    /**
     * 获取地图中当前的模块。返回的数组是一个深拷贝，并且不会在一个
     * 调用`update()`。
     */
    值（）：模块[ ] ；
}

类型 ModuleMapFilter  =  ( m : Module )  =>  boolean ;

声明 命名空间 内存 {
    /**
     * 在"address"和"size"给定的内存范围内扫描内存以查找"pattern"的出现。
     *
     * @param address 要扫描的起始地址。
     * @param size 要扫描的字节数。
     * @param pattern 匹配模式，详见 `MatchPattern`。
     * @param callbacks 带有回调的对象。
     */
    函数 扫描（地址：NativePointerValue ， 大小：数字 |  UInt64 ， 模式：字符串 |  MatchPattern ，
        回调: MemoryScanCallbacks ) : Promise < void > ;

    /**
     * `scan()` 的同步版本。
     *
     * @param address 要扫描的起始地址。
     * @param size 要扫描的字节数。
     * @param pattern 匹配模式，详见 `MatchPattern`。
     */
    函数 scanSync （地址：NativePointerValue ， 大小：数字 |  UInt64 ， 模式：字符串 |  MatchPattern ）：MemoryScanMatch [ ] ；

    /**
     * 在 Frida 的私有堆上分配 `size` 字节的内存，或者，如果 `size` 是 Process#pageSize 的倍数，
     * 一个或多个由操作系统管理的原始内存页。返回时会释放分配的内存
     * NativePointer 值被垃圾收集。这意味着您需要在指针的同时保留对它的引用
     * 被 JavaScript 运行时之外的代码使用。
     *
     * @param size 要分配的字节数。
     * @param options 自定义内存分配的选项。
     */
    函数 分配（大小：数字 |  UInt64 ， 选项？：MemoryAllocOptions ）：NativePointer ；

    /**
     * 在 Frida 的私有堆上分配、编码和写出 `str` 作为 UTF-8 字符串。
     * 有关其生命周期的详细信息，请参阅 Memory#alloc()。
     *
     * @param str 要分配的字符串。
     */
    函数 allocUtf8String ( str : string ) : NativePointer ;

    /**
     * 在 Frida 的私有堆上分配、编码和写出 `str` 作为 UTF-16 字符串。
     * 有关其生命周期的详细信息，请参阅 Memory#alloc()。
     *
     * @param str 要分配的字符串。
     */
    函数 allocUtf16String ( str : string ) : NativePointer ;

    /**
     * 在 Frida 的私有堆上分配、编码和写出 `str` 作为 ANSI 字符串。
     * 有关其生命周期的详细信息，请参阅 Memory#alloc()。
     *
     * @param str 要分配的字符串。
     */
    函数 allocAnsiString ( str : string ) : NativePointer ;

    /**
     * 就像 memcpy。
     *
     * @param dst 目标地址。
     * @param src 源地址。
     * @param n 要复制的字节数。
     */
    函数 副本（dst：NativePointerValue ， src：NativePointerValue ， n：数字 |  UInt64 ）：void；

    /**
     * Memory#alloc() 后跟 Memory#copy() 的简写。有关生命周期的详细信息，请参阅 Memory#alloc()。
     *
     * @param address 要复制的地址。
     * @param size 要复制的字节数。
     */
    函数 dup （地址：NativePointerValue ， 大小：数字 |  UInt64 ）：NativePointer ；

    /**
     * 更改内存区域的页面保护。
     *
     * @param address 起始地址。
     * @param size 字节数。必须是 Process#pageSize 的倍数。
     * @param protection 所需的页面保护。
     */
    功能 保护（地址：NativePointerValue ， 大小：数字 |  UInt64 ， 保护：PageProtection ）：布尔值；

    /**
     * 安全地修改 `address` 处的 `size` 字节。提供的函数 `apply` 使用可写指针调用
     * 您必须在返回之前编写所需的修改。不要对这个存在做任何假设
     * 与地址相同的位置，因为某些系统需要在修改之前将修改写入临时位置
     * 被映射到原始内存页面之上的内存（例如在 iOS 上，直接在内存中修改
     * 代码可能会导致进程丢失其 CS_VALID 状态）。
     *
     * @param address 要修改的起始地址。
     * @param size 要修改的字节数。
     * @param apply 应用所需更改的函数。
     */
    函数 patchCode （地址：NativePointerValue ， 大小：数字 |  UInt64 ， 应用：MemoryPatchApplyCallback ）：void；
}

接口 内存范围 {
    /**
     * 基址。
     */
    基：本地指针；

    /**
     * 大小以字节为单位。
     */
    大小：数字；
}

/**
* 监视一个或多个内存范围的访问，并在第一个通知
* 访问每个包含的内存页。
*
* 目前仅适用于 Windows。我们很乐意支持这一点
* 平台也是如此，所以如果您觉得这很有用并想提供帮助，请
* 保持联系。
*/
声明 命名空间 MemoryAccessMonitor  {
    /**
     * 开始监视一个或多个内存范围的访问，并通知
     * 每个包含的内存页的第一次访问。
     *
     * @param range 一个或多个要监控的范围。
     * @param callbacks 在访问时通知回调。
     */
    功能 启用（范围：MemoryAccessRange  |  MemoryAccessRange [ ] ， 回调：MemoryAccessCallbacks ）：无效；

    /**
     * 停止监视传递给的剩余内存范围
     * `MemoryAccessMonitor.enable()`。
     */
    功能 禁用（）：无效；
}

接口 MemoryAccessRange  {
    /**
     * 基址。
     */
    基：本地指针；

    /**
     * 大小以字节为单位。
     */
    大小：数字；
}

/**
* 在内存访问时同步通知回调。
*/
接口 MemoryAccessCallbacks  {
    onAccess : (详细信息: MemoryAccessDetails )  =>  void ;
}

接口 MemoryAccessDetails  {
    /**
     * 触发访问的操作类型。
     */
    操作：记忆操作；

    /**
     * 执行访问的指令地址。
     */
    来自：本地指针；

    /**
     * 正在访问的地址。
     */
    地址：本地指针；

    /**
     * 提供给的范围内访问范围的索引
     * `MemoryAccessMonitor.enable()`。
     */
    范围索引：数字；

    /**
     * 指定范围内访问的内存页的索引。
     */
    页面索引：数字；

    /**
     * 到目前为止已访问的总页数，因此是
     * 不再被监控。
     */
    pagesCompleted : number ;

    /**
     * 最初监控的总页数。
     */
    pagesTotal：数量；
}

声明 命名空间 线程 {
    /**
     * 为给定线程的 `context` 生成回溯。
     *
     * 如果你从拦截器的 `onEnter` 或 `onLeave` 回调中调用它
     * 你应该为可选的 `context` 参数提供 `this.context`，
     * 因为它会给你一个更准确的回溯。省略 `context` 意味着
     * 回溯将从当前堆栈位置生成，其中
     * 由于 JavaScript VM 的原因，可能无法为您提供非常好的回溯
     * 潜在的 JITed 堆栈帧。
     *
     * @param context 用于生成回溯的 CPU 上下文。
     * @param backtracer 要使用的回溯类型。必须是
     * `Backtracer.FUZZY` 或 `Backtracer.ACCURATE`,
     * 如果未指定，则后者是默认值。
     */
    函数 回溯（上下文？：CpuContext ， 回溯？：回溯）：NativePointer [ ] ；

    /**
     * 暂停当前线程的执行 `delay` 秒。
     *
     * 例如 `0.05` 休眠 50 毫秒。
     *
     * @param delay 以秒为单位的延迟。
     */
    功能 睡眠（延迟：数字）：无效；
}

// tslint:disable-next-line:no-unnecessary-class
声明 类 回溯 {
    /**
     * 准确的回溯追踪器依赖于调试器友好的二进制文件或
     * 做好调试信息的存在，但避免虚假
     * 积极的一面。
     */
    静态 准确：回溯；

    /**
     * 模糊回溯器对堆栈进行取证以便猜测
     * 返回地址，这意味着你会得到误报，但它
     * 适用于任何二进制文件。
     */
    静态 模糊：回溯；
}

类型 架构 =
    |  "ia32"
    |  "x64"
    |  "手臂"
    |  "arm64"
    |  "米普斯"
    ;

类型 平台 =
    |  "视窗"
    |  《达尔文》
    |  "Linux"
    |  "qnx"
    ;

类型 CodeSigningPolicy  =  "可选"  |  "必需" ；

/**
* 以字符串形式给出：rwx，其中 rw- 表示"可读和可写"。
*/
类型 PageProtection  = 字符串；

类型 ThreadId  =  number ;

类型 线程状态 =
    |  "跑步"
    |  "停止"
    |  "等待"
    |  "不间断"
    |  "停止"
    ;

接口 ThreadDetails  {
    /**
     * 特定于操作系统的 ID。
     */
    id :线程ID ;

    /**
     *状态快照。
     */
    状态：线程状态；

    /**
     * CPU 寄存器的快照。
     */
    上下文：CpuContext ；
}

接口 KernelModuleDetails  {
    /**
     * 规范的模块名称。
     */
    名称：字符串；

    /**
     * 基址。
     */
    基数：UInt64 ；

    /**
     * 大小以字节为单位。
     */
    大小：数字；
}

接口 ModuleImportDetails  {
    /**
     * 导入类型（如果有）。
     */
    类型？：模块导入类型 |  未定义；

    /**
     * 导入的符号名称。
     */
    名称：字符串；

    /**
     * 模块名称（如果有）。
     */
    模块？：字符串 |  未定义；

    /**
     * 绝对地址，如果有的话。
     */
    地址?: NativePointer  |  未定义；

    /**
     * 存储导入的内存位置（如果有）。
     */
    插槽?: NativePointer  |  未定义；
}

接口模块 导出详细信息 {
    /**
     * 出口的种类。
     */
    类型：模块导出类型；

    /**
     * 导出的符号名称。
     */
    名称：字符串；

    /**
     * 绝对地址。
     */
    地址：本地指针；
}

接口 ModuleSymbolDetails  {
    /**
     * 符号是否全局可见。
     */
    isGlobal：布尔值；

    /**
     * 符号的种类。
     */
    类型：模块符号类型；

    /**
     * 此符号位于哪个部分（如果有）。
     */
    section ?: ModuleSymbolSectionDetails  |  未定义；

    /**
     * 符号名称。
     */
    名称：字符串；

    /**
     * 绝对地址。
     */
    地址：本地指针；

    /**
     * 以字节为单位的大小（如果可用）。
     */
    尺寸？：数字 |  未定义；
}

类型 ModuleImportType  =  "函数"  |  "变量" ；

类型 ModuleExportType  =  "函数"  |  "变量" ；

类型 ModuleSymbolType  =
    // 常见的
    |  "未知"
    |  "部分"

    // 马赫-O
    |  "不明确的"
    |  "绝对"
    |  "预绑定未定义"
    |  "间接"

    // 精灵
    |  "目的"
    |  "功能"
    |  "文件"
    |  "常见的"
    |  "tls"
    ;

接口 ModuleSymbolSectionDetails  {
    /**
     * 部分索引、部分名称（如果适用）和部分名称 - 与 r2 的部分 ID 格式相同。
     */
    id：字符串；

    /**
     *部分的内存保护。
     */
    保护：页面保护；
}

接口 范围详细信息 {
    /**
     * 基址。
     */
    基：本地指针；

    /**
     * 大小以字节为单位。
     */
    大小：数字；

    /**
     * 保护。
     */
    保护：页面保护；

    /**
     * 文件映射详细信息（如果有）。
     */
    文件？：文件映射 |  未定义；
}

接口 内核范围详细信息 {
    /**
     * 基址。
     */
    基数：UInt64 ；

    /**
     * 大小以字节为单位。
     */
    大小：数字；

    /**
     * 保护。
     */
    保护：页面保护；
}

接口 KernelModuleRangeDetails  {
    /**
     * 姓名。
     */
    名称：字符串；

    /**
     * 基址。
     */
    基数：UInt64 ；

    /**
     * 大小以字节为单位。
     */
    大小：数字；

    /**
     * 保护。
     */
    保护：页面保护；
}

接口 文件映射 {
    /**
     * 完整的文件系统路径。
     */
    路径：字符串；

    /**
     * 磁盘上映射文件的偏移量，以字节为单位。
     */
    偏移量：数字；

    /**
     * 磁盘上映射文件的大小，以字节为单位。
     */
    大小：数字；
}

接口 EnumerateRangesSpecifier  {
    /**
     * 需要包含在结果中的最低保护。
     */
    保护：页面保护；

    /**
     * 是否应该合并具有相同保护的相邻范围。默认值为假。
     */
    合并：布尔值；
}

type  ExceptionHandlerCallback  =  （异常：ExceptionDetails ） =>  boolean  |  无效;

接口 异常详细信息 {
    /**
     * 发生的异常类型。
     */
    类型：异常类型；

    /**
     * 发生异常的地址。
     */
    地址：本地指针；

    /**
     * 内存操作详细信息（如果相关）。
     */
    内存？：ExceptionMemoryDe​​tails  |  未定义；

    /**
     * CPU 寄存器。您还可以通过分配给这些键来更新寄存器值。
     */
    上下文：CpuContext ；

    /**
     * 操作系统和特定于体系结构的 CPU 上下文结构的地址。
     *
     * 这仅作为 `context` 没有提供足够详细信息的边缘情况的最后手段公开。
     * 然而，我们不鼓励使用它，而是提交一个拉取请求来添加所需的缺失位
     * 用于您的用例。
     */
    nativeContext : NativePointer ;
}

类型 异常类型 =
    |  "中止"
    |  "访问冲突"
    |  "保护页"
    |  "非法指令"
    |  "堆栈溢出"
    |  "算术"
    |  "断点"
    |  "一小步"
    |  "系统"
    ;

接口 ExceptionMemoryDe​​tails  {
    /**
     * 触发异常的操作类型。
     */
    操作：记忆操作；

    /**
     * 发生异常时访问的地址。
     */
    地址：本地指针；
}

类型 MemoryOperation  =  "读取"  |  "写"  |  "执行" ；

接口 EnumerateCallbacks < T >  {
    onMatch : (项目: T )  => 无效 |  枚举动作；
    onComplete : ( )  => 无效；
}

类型 EnumerateAction  =  "停止" ;

接口 MemoryScanCallbacks  {
    /**
     * 在发现的每个事件中调用。
     *
     * @param address 找到匹配项的内存地址。
     * @param size 这个匹配的大小。
     */
    onMatch：（地址：NativePointer ，大小：数字） = > void | 枚举动作；     

    /**
     * 当扫描时出现内存访问错误时调用。
     *
     * @param reason 为什么内存访问失败。
     */
    onError ?: ( (原因:字符串)  =>  void )  |  未定义；

    /**
     * 当内存范围被完全扫描时调用。
     */
    onComplete ?: ( )  =>  void ;
}

接口 MemoryScanMatch  {
    /**
     * 找到匹配的内存地址。
     */
    地址：本地指针；

    /**
     * 这场比赛的大小。
     */
    大小：数字；
}

接口 KernelMemoryScanCallbacks  {
    /**
     * 在发现的每个事件中调用。
     *
     * @param address 找到匹配项的内存地址。
     * @param size 这个匹配的大小。
     */
    onMatch：（地址：UInt64 ，大小：数字） = > void | 枚举动作；     

    /**
     * 当扫描时出现内存访问错误时调用。
     *
     * @param reason 为什么内存访问失败。
     */
    onError ?: ( (原因:字符串)  =>  void )  |  未定义；

    /**
     * 当内存范围被完全扫描时调用。
     */
    onComplete ?: ( )  =>  void ;
}

接口 KernelMemoryScanMatch  {
    /**
     * 找到匹配的内存地址。
     */
    地址：UInt64 ；

    /**
     * 这场比赛的大小。
     */
    大小：数字；
}

类型 MemoryAllocOptions  = 记录<任何， 从不>  |  MemoryAllocNearOptions ;

接口 MemoryAllocNearOptions  {
    /**
     * 尝试分配附近的内存地址。
     */
    附近：NativePointer ；

    /**
     * 到给定内存地址的最大距离，以字节为单位。
     */
    最大距离：数字；
}

类型 MemoryPatchApplyCallback  =  （代码：NativePointer ） =>  void；

/**
* 表示有符号的 64 位值。
*/
声明 类 Int64  {
    /**
     * 从 `v` 创建一个新的 Int64，它是一个包含十进制值或十六进制值的字符串
     * 如果以"0x"或数字为前缀。为简洁起见，您可以使用 int64(v) 简写。
     */
    构造函数（v：字符串 | 数字 |  Int64 ）；

    /**
     * 创建一个新的 Int64，其值为 `this` + `v`。
     */
    添加（v：Int64  | 数字 | 字符串）：Int64 ；

    /**
     * 创建一个新的 Int64，其值为 `this` - `v`。
     */
    子（v：Int64  | 数字 | 字符串）：Int64 ；

    /**
     * 创建一个新的 Int64，其值为 `this` & `v`。
     */
    和( v : Int64  |  number  |  string ) : Int64 ;

    /**
     * 创建一个新的 Int64，其值为 `this` | `v`。
     */
    或（v：Int64  |  number  |  string ）：Int64 ；

    /**
     * 创建一个新的 Int64，其值为 `this` ^ `v`。
     */
    xor ( v : Int64  |  number  |  string ) : Int64 ;

    /**
     * 创建一个新的 Int64，其值为 `this` << `v`。
     */
    shl ( v : Int64  |  number  |  string ) : Int64 ;

    /**
     * 创建一个新的 Int64，其值为 `this` >> `v`。
     */
    shr ( v : Int64  |  number  |  string ) : Int64 ;

    /**
     * 创建一个新的 Int64，其值为 ~`this`。
     */
    不是（）：Int64 ；

    /**
     * 与 String#localeCompare() 一样返回整数比较结果。
     */
    比较（v：Int64  | 数字 | 字符串）：数字；

    /**
     * 返回一个布尔值，指示 `v` 是否等于 `this`。
     */
    等于（v：Int64  |  number  |  string ）：布尔值；

    /**
     * 转换为数字。
     */
    toNumber ( ) :数字;

    /**
     * 转换为字符串，可选择使用自定义 `radix`。
     */
    toString （基数？：数字）：字符串；

    /**
     * 转换为 JSON 可序列化值。与`toString()` 相同。
     */
    toJSON ( ) :字符串;

    /**
     * 转换为数字。与 `toNumber()` 相同。
     */
    valueOf ( ) :数字;
}

/**
* 表示无符号 64 位值。
*/
声明 类 UInt64  {
    /**
     * 从 `v` 创建一个新的 UInt64，它是一个包含十进制值或十六进制值的字符串
     * 如果以"0x"或数字为前缀。为简洁起见，您可以使用 uint64(v) 简写。
     */
    构造函数（v：字符串 | 数字 |  UInt64 ）；

    /**
     * 创建一个新的 UInt64，其值为 `this` + `v`。
     */
    添加（v：UInt64  | 数字 | 字符串）：UInt64 ；

    /**
     * 创建一个新的 UInt64，其值为 `this` - `v`。
     */
    子（v：UInt64  | 数字 | 字符串）：UInt64 ；

    /**
     * 创建一个新的 UInt64，其值为 `this` & `v`。
     */
    和（v：UInt64  |  number  |  string ）：UInt64 ；

    /**
     * 创建一个新的 UInt64，其值为 `this` | `v`。
     */
    或（v：UInt64  |  number  |  string ）：UInt64 ；

    /**
     * 创建一个新的 UInt64，其值为 `this` ^ `v`。
     */
    异或（v：UInt64  | 数字 | 字符串）：UInt64 ；

    /**
     * 创建一个新的 UInt64，其值为 `this` << `v`。
     */
    shr （v：UInt64  | 数字 | 字符串）：UInt64 ；

    /**
     * 创建一个新的 UInt64，其值为 `this` >> `v`。
     */
    shl （v：UInt64  | 数字 | 字符串）：UInt64 ；

    /**
     * 创建一个新的 UInt64，其值为 ~`this`。
     */
    不是（）：UInt64 ；

    /**
     * 与 String#localeCompare() 一样返回整数比较结果。
     */
    比较（v：UInt64  | 数字 | 字符串）：数字；

    /**
     * 返回一个布尔值，指示 `v` 是否等于 `this`。
     */
    等于（v：UInt64  |  number  |  string ）：布尔值；

    /**
     * 转换为数字。
     */
    toNumber ( ) :数字;

    /**
     * 转换为字符串，可选择使用自定义 `radix`。
     */
    toString （基数？：数字）：字符串；

    /**
     * 转换为 JSON 可序列化值。与`toString()` 相同。
     */
    toJSON ( ) :字符串;

    /**
     * 转换为数字。与 `toNumber()` 相同。
     */
    valueOf ( ) :数字;
}

/**
* 表示一个本机指针值，其大小取决于 Process#pointerSize。
*/
声明 类 NativePointer  {
    /**
     * 从 `v` 创建一个新的 NativePointer，它是一个包含十进制内存地址的字符串，
     * 或十六进制（如果前缀为"0x"）或数字。为简洁起见，您可以使用 ptr(v) 简写。
     */
    构造函数（v：字符串 | 数字 |  UInt64  |  Int64  |  NativePointerValue ）；

    /**
     * 返回一个布尔值，让您可以方便地检查指针是否为 `NULL`。
     */
    isNull ( )：布尔值；

    /**
     * 创建一个新的 NativePointer，其值为 `this` + `v`。
     */
    添加（v：NativePointerValue  |  UInt64  |  Int64  |  number  |  string ）：NativePointer ；

    /**
     * 创建一个新的 NativePointer，其值为 `this` - `v`。
     */
    sub ( v : NativePointerValue  |  UInt64  |  Int64  |  number  |  string ) : NativePointer ;

    /**
     * 创建一个新的 NativePointer，其值为 `this` & `v`。
     */
    和（v：NativePointerValue  |  UInt64  |  Int64  |  number  |  string ）：NativePointer ；

    /**
     * 创建一个新的 NativePointer，其值为 `this` | `v`。
     */
    或（v：NativePointerValue  |  UInt64  |  Int64  |  number  |  string ）：NativePointer ；

    /**
     * 创建一个新的 NativePointer，其值为 `this` ^ `v`。
     */
    xor ( v : NativePointerValue  |  UInt64  |  Int64  |  number  |  string ) : NativePointer ;

    /**
     * 创建一个新的 NativePointer，其值为 `this` << `v`。
     */
    shr ( v : NativePointerValue  |  UInt64  |  Int64  |  number  |  string ) : NativePointer ;

    /**
     * 创建一个新的 NativePointer，其值为 `this` >> `v`。
     */
    shl ( v : NativePointerValue  |  UInt64  |  Int64  |  number  |  string ) : NativePointer ;

    /**
     * 创建一个新的 NativePointer，其值为 ~`this`。
     */
    not ( ) : NativePointer ;

    /**
     * 通过获取 `this` 的位并添加来创建一个新的 NativePointer
     * 指针认证位，创建签名指针。这是一个
     * 如果当前进程不支持指针，则无操作
     * 身份验证，返回 `this` 而不是新值。
     *
     * @param key 要使用的密钥。默认为 `ia`。
     * @param data 要使用的数据。默认为"0"。
     */
    符号（键？：PointerAuthenticationKey ， 数据？：NativePointerValue  |  UInt64  |  Int64  |  number  |  string ）：NativePointer ；

    /**
     * 通过获取 `this` 和
     * 删除它的指针认证位，创建一个原始指针。
     * 如果当前进程不支持指针，这是一个空操作
     * 身份验证，返回 `this` 而不是新值。
     *
     * @param key 用于签署 `this` 的密钥。默认为 `ia`。
     */
    剥离（键？：PointerAuthenticationKey ）：NativePointer ；

    /**
     * 通过使用 `this` 并将其与
     * 一个常量，它又可以作为 `data` 传递给`sign()`。
     *
     * @param smallInteger 要混合的值。
     */
    混合（smallInteger：数字）：NativePointer ；

    /**
     * 返回一个布尔值，指示 `v` 是否等于 `this`；即它包含相同的内存地址。
     */
    等于（v：NativePointerValue  |  UInt64  |  Int64  |  number  |  string ）：布尔值；

    /**
     * 与 String#localeCompare() 一样返回整数比较结果。
     */
    比较（v：NativePointerValue  |  UInt64  |  Int64  | 数字 | 字符串）：数字；

    /**
     * 转换为有符号的 32 位整数。
     */
    toInt32 ( )：数字；

    /**
     * 转换为无符号 32 位整数。
     */
    toUInt32 ( )：数字；

    /**
     * 转换为以"0x"为前缀的十六进制字符串，除非是 `radix`
     * 已指定。
     */
    toString （基数？：数字）：字符串；

    /**
     * 转换为 JSON 可序列化值。与`toString()` 相同。
     */
    toJSON ( ) :字符串;

    /**
     * 返回一个字符串，其中包含与此指针原始值的"Memory#scan()"兼容的匹配模式。
     */
    toMatchPattern ( ) :字符串;

    readPointer ( ) : NativePointer ;
    readS8 ( )：数字；
    readU8 ( )：数字；
    readS16 ( )：数字；
    readU16 ( )：数字；
    readS32 ( )：数字；
    readU32 ( )：数字；
    readS64 ( ) : Int64 ;
    readU64 ( ) : UInt64 ;
    readShort ( )：数字；
    readUShort ( )：数字；
    readInt ( ) :数字;
    readUInt ( ) :数字;
    readLong ( ) :数字 |  整数64 ；
    readULong ( ) :数字 |  UInt64 ;
    readFloat ( )：数字；
    readDouble ( )：数字；
    readByteArray （长度：数字）：ArrayBuffer  |  空；
    readCString （大小？：数字）：字符串 |  空；
    readUtf8String （大小？：数字）：字符串 |  空；
    readUtf16String （长度？：数字）：字符串 |  空；
    readAnsiString （大小？：数字）：字符串 |  空；

    writePointer （值：NativePointerValue ）：NativePointer ；
    writeS8 （值：数字 |  Int64 ）：NativePointer ；
    writeU8 （值：数字 |  UInt64 ）：NativePointer ；
    writeS16 （值：数字 |  Int64 ）：NativePointer ；
    writeU16 （值：数字 |  UInt64 ）：NativePointer ；
    writeS32 （值：数字 |  Int64 ）：NativePointer ；
    writeU32 （值：数字 |  UInt64 ）：NativePointer ；
    writeS64 （值：数字 |  Int64 ）：NativePointer ；
    writeU64 （值：数字 |  UInt64 ）：NativePointer ；
    writeShort ( value : number  |  Int64 ) : NativePointer ;
    writeUShort ( value : number  |  UInt64 ) : NativePointer ;
    writeInt （值：数字 |  Int64 ）：NativePointer ；
    writeUInt （值：数字 |  UInt64 ）：NativePointer ；
    writeLong （值：数字 |  Int64 ）：NativePointer ；
    writeULong （值：数字 |  UInt64 ）：NativePointer ；
    writeFloat （值：数字）：NativePointer ；
    writeDouble （值：数字）：NativePointer ；
    writeByteArray ( value : ArrayBuffer  |  number [ ] ) : NativePointer ;
    writeUtf8String （值：字符串）：NativePointer ；
    writeUtf16String （值：字符串）：NativePointer ；
    writeAnsiString （值：字符串）：NativePointer ；
}

类型 PointerAuthenticationKey  =  "ia"  |  "我"  |  "达"  |  "分贝" ；

接口 对象包装器 {
    句柄：NativePointer ；
}

接口 ArrayBufferConstructor  {
    /**
     * 创建一个由现有内存区域支持的 ArrayBuffer。不像
     * NativePointer `read*()` 和 `write*()` API，没有验证
     * 在访问时执行，这意味着错误的指针会使进程崩溃。
     *
     * @param address 区域的基地址。传递 `NULL` 将导致
     * 在一个空的缓冲区中。
     * @param size 区域的大小。传递 `0` 将导致为空
     * 缓冲。
     */
    wrap （地址：NativePointerValue ， 大小：数字）：ArrayBuffer ；
}

接口 ArrayBuffer  {
    /**
     * 获取指向 ArrayBuffer 后备存储的基地址的指针。
     * 调用者有责任在
     * 后备存储仍在使用中。
     */
    unwrap ( ) : NativePointer ;
}

类型 NativePointerValue  =  NativePointer  |  对象包装器；

声明 const  NativeFunction : NativeFunctionConstructor ;

接口 NativeFunctionConstructor  {
    new  < RetType 扩展 NativeFunctionReturnType ,  ArgTypes 扩展 NativeFunctionArgumentType [ ]  |  [ ] > (
        地址: NativePointerValue ,
        retType：RetType ，
        参数类型：参数类型，
        abiOrOptions ?: NativeABI  |  NativeFunctionOptions ,
    ) :原生函数<
        GetNativeFunctionReturnValue < RetType > ,
        ResolveVariadic <提取< GetNativeFunctionArgumentValue < ArgTypes > ， 未知[ ] > >
    > ;
    只读 原型：NativeFunction < void ,  [ ] > ;
}

接口 NativeFunction < RetType 扩展 NativeFunctionReturnValue ,  ArgTypes 扩展 NativeFunctionArgumentValue [ ]  |  [ ] >
    扩展 NativePointer  {
    ( ... args : ArgTypes ) : RetType ;
    应用（thisArg：NativePointerValue  |  null  |  undefined ， args：ArgTypes ）：RetType ；
    调用（thisArg？：NativePointerValue  |  null ， ... args：ArgTypes ）：RetType ；
}

声明 const  SystemFunction : SystemFunctionConstructor ;

接口 SystemFunctionConstructor  {
    new  < RetType 扩展 NativeFunctionReturnType ,  ArgTypes 扩展 NativeFunctionArgumentType [ ]  |  [ ] > (
        地址: NativePointerValue ,
        retType：RetType ，
        参数类型：参数类型，
        abiOrOptions ?: NativeABI  |  NativeFunctionOptions ,
    ) :系统函数<
        GetNativeFunctionReturnValue < RetType > ,
        ResolveVariadic <提取< GetNativeFunctionArgumentValue < ArgTypes > ， 未知[ ] > >
    > ;
    只读 原型：SystemFunction < void ,  [ ] > ;
}

接口 SystemFunction < RetType 扩展 NativeFunctionReturnValue ,  ArgTypes 扩展 NativeFunctionArgumentValue [ ]  |  [ ] >
    扩展 NativePointer  {
    ( ... args : ArgTypes ) : SystemFunctionResult < RetType > ;
    应用（thisArg：NativePointerValue  |  null  |  undefined ， args：ArgTypes ）：SystemFunctionResult < RetType > ；
    调用（thisArg？：NativePointerValue  |  null ， ... args：ArgTypes ）：SystemFunctionResult < RetType > ；
}

类型 SystemFunctionResult <值 扩展 NativeFunctionReturnValue >  =
    |  WindowsSystemFunctionResult <值>
    |  UnixSystemFunctionResult <值>
    ;

接口 WindowsSystemFunctionResult <值 扩展 NativeFunctionReturnValue >  {
    价值：价值；
    上一个错误：数字；
}

接口 UnixSystemFunctionResult <值 扩展 NativeFunctionReturnValue >  {
    价值：价值；
    错误号：数字；
}

声明 类 NativeCallback <
    RetType 扩展 了 NativeCallbackReturnType ，
    ArgTypes 扩展 NativeCallbackArgumentType [ ]  |  [ ] ,
> 扩展 NativePointer  {
    构造函数(
        函数: NativeCallbackImplementation <
            GetNativeCallbackReturnValue < RetType > ,
            提取< GetNativeCallbackArgumentValue < ArgTypes > ， 未知[ ] >
        > ,
        retType：RetType ，
        参数类型：参数类型，
        abi ?: NativeABI ,
    ) ;
}

类型 NativeCallbackImplementation <
    RetType 扩展 了 NativeCallbackReturnValue ，
    ArgTypes 扩展 NativeCallbackArgumentValue [ ]  |  [ ] ,
>  =  ( this : CallbackContext  |  InvocationContext , ... args : ArgTypes )  =>  RetType ;

接口 回调上下文 {
    /**
     * 退货地址。
     */
    返回地址：本地指针；

    /**
     * CPU 寄存器，但与 `InvocationContext` 不同，这是只读且仅
     * 包含 `Thread.backtrace()` 所需的最低限度 - 所有其他
     * 归零。
     */
    上下文：CpuContext ；
}

类型 可变参数 =  "..." ;

type  ResolveVariadic < List  extends  any [ ] >  =  List  extends  [ Variadic , ...infer Tail ]
    ? [ ...数组<尾[ 0 ] > ]
    :列表 扩展 [ infer Head , ...infer Tail ]
    ? [头， ... ResolveVariadic <尾> ]
    : [ ] ;

类型 RecursiveValuesOf < T >  =  T [ keyof  T ]  |  数组< RecursiveValuesOf < T >> ; _

类型 RecursiveKeysOf < T >  =  keyof  T  |  数组< RecursiveKeysOf < T >> | _  [ ] ; 

type  GetValue < Map ,  Value ,  Type ,  T  extends  Type >  =  Type [ ]  extends  T
    ? 价值
    : T 扩展 keyof 映射
    ? 地图[ T ]
    : {  [ P  in  keyof  T ] : T [ P ] 扩展 类型？GetValue <地图, 值, 类型,  T [ P ] > :从不 } ;

// tslint:disable-next-line:interface-over-type-literal
类型 BaseNativeTypeMap  =  {
    整数：数字；
    uint：数字；
    长：数字；
    乌龙：数字；
    字符：数字；
    uchar：数字；
    浮动：数字；
    双：数字；
    int8：数字；
    uint8：数字；
    int16：数字；
    uint16：数字；
    int32：数字；
    uint32：数字；
    布尔：数字；
} ;

类型 NativeFunctionArgumentTypeMap  =  BaseNativeTypeMap  &  {
    无效：未定义；
    指针：NativePointerValue ；
    size_t :数字 |  UInt64 ;
    ssize_t :数字 |  整数64 ；
    int64 :数字 |  整数64 ；
    uint64 :数字 |  UInt64 ;
    "..."：可变参数；
} ;

类型 NativeFunctionArgumentValue  =  RecursiveValuesOf < NativeFunctionArgumentTypeMap > ;

类型 NativeFunctionArgumentType  =  RecursiveKeysOf < NativeFunctionArgumentTypeMap > ;

类型 GetNativeFunctionArgumentValue < T 扩展 NativeFunctionArgumentType >  =  GetValue <
    NativeFunctionArgumentTypeMap ,
    NativeFunctionArgumentValue ,
    NativeFunctionArgumentType ,
    吨
> ;

类型 NativeFunctionReturnTypeMap  =  BaseNativeTypeMap  &  {
    // tslint:disable-next-line:void-return
    无效：无效；
    指针：本地指针；
    size_t : UInt64 ;
    ssize_t : Int64 ;
    int64 : Int64 ;
    uint64 : UInt64 ;
} ;

类型 NativeFunctionReturnValue  =  RecursiveValuesOf < NativeFunctionReturnTypeMap > ;

类型 NativeFunctionReturnType  =  RecursiveKeysOf < NativeFunctionReturnTypeMap > ;

type  GetNativeFunctionReturnValue < T 扩展 NativeFunctionReturnType >  =  GetValue <
    NativeFunctionReturnTypeMap ,
    NativeFunctionReturnValue ,
    NativeFunctionReturnType ,
    吨
> ;

类型 NativeCallbackArgumentTypeMap  =  BaseNativeTypeMap  &  {
    无效：未定义；
    指针：本地指针；
    size_t : UInt64 ;
    ssize_t : Int64 ;
    int64 : Int64 ;
    uint64 : UInt64 ;
} ;

类型 NativeCallbackArgumentValue  =  RecursiveValuesOf < NativeCallbackArgumentTypeMap > ;

类型 NativeCallbackArgumentType  =  RecursiveKeysOf < NativeCallbackArgumentTypeMap > ;

类型 GetNativeCallbackArgumentValue < T 扩展 NativeCallbackArgumentType >  =  GetValue <
    NativeCallbackArgumentTypeMap ,
    NativeCallbackArgumentValue ,
    NativeCallbackArgumentType ,
    吨
> ;

类型 NativeCallbackReturnTypeMap  =  BaseNativeTypeMap  &  {
    // tslint:disable-next-line:void-return
    无效：无效；
    指针：NativePointerValue ；
    size_t :数字 |  UInt64 ;
    ssize_t :数字 |  整数64 ；
    int64 :数字 |  整数64 ；
    uint64 :数字 |  UInt64 ;
} ;

类型 NativeCallbackReturnValue  =  RecursiveValuesOf < NativeCallbackReturnTypeMap > ;

类型 NativeCallbackReturnType  =  RecursiveKeysOf < NativeCallbackReturnTypeMap > ;

类型 GetNativeCallbackReturnValue < T 扩展 NativeCallbackReturnType >  =  GetValue <
    NativeCallbackReturnTypeMap ,
    NativeCallbackReturnValue ,
    NativeCallbackReturnType ,
    吨
> ;

输入 NativeABI  =
    |  "默认"
    |  "系统"
    |  "标准调用"
    |  "这个电话"
    |  "快速呼叫"
    |  "mscdecl"
    |  "win64"
    |  "unix64"
    |  "vfp"
    ;

接口 NativeFunctionOptions  {
    abi ?: NativeABI  |  未定义；
    调度？：调度行为 |  未定义；
    异常？：异常行为 |  未定义；
    陷阱？：代码陷阱 |  未定义；
}

类型 SchedulingBehavior  =  "合作"  |  "独家" ；

类型 ExceptionsBehavior  =  "偷"  |  "传播" ；

类型 CodeTraps  =  "默认"  |  "全部" ；

类型 CpuContext  =  PortableCpuContext  |  Ia32Cpu上下文 |  X64Cpu上下文 |  ArmCpu上下文 |  Arm64Cpu上下文 |  MipsCpuContext ;

接口 PortableCpuContext  {
    个人计算机：本地指针；
    sp : NativePointer ;
}

接口 Ia32CpuContext 扩展 PortableCpuContext  {
    eax : NativePointer ;
    ecx : NativePointer ;
    edx : NativePointer ;
    ebx : NativePointer ;
    esp : NativePointer ;
    ebp : NativePointer ;
    esi：本地指针；
    edi : NativePointer ;

    eip：本地指针；
}

接口 X64CpuContext 扩展 PortableCpuContext  {
    rax : NativePointer ;
    rcx : NativePointer ;
    rdx : NativePointer ;
    rbx : NativePointer ;
    rsp：本地指针；
    rbp：本地指针；
    rsi：本地指针；
    rdi：本地指针；

    r8：本地指针；
    r9：本地指针；
    r10：本地指针；
    r11：本地指针；
    r12：本地指针；
    r13：本地指针；
    r14：本地指针；
    r15：本地指针；

    rip : NativePointer ;
}

接口 ArmCpuContext 扩展 PortableCpuContext  {
    r0：本地指针；
    r1：本地指针；
    r2：本地指针；
    r3：本地指针；
    r4：本地指针；
    r5：本地指针；
    r6：本地指针；
    r7：本地指针；

    r8：本地指针；
    r9：本地指针；
    r10：本地指针；
    r11：本地指针；
    r12：本地指针；

    lr：本地指针；
}

接口 Arm64CpuContext 扩展 PortableCpuContext  {
    x0：本地指针；
    x1：本地指针；
    x2：本地指针；
    x3：本地指针；
    x4：本地指针；
    x5：本地指针；
    x6：本地指针；
    x7：本地指针；
    x8：本地指针；
    x9：本地指针；
    x10：本地指针；
    x11：本地指针；
    x12：本地指针；
    x13：本地指针；
    x14：本地指针；
    x15：本地指针；
    x16：本地指针；
    x17：本地指针；
    x18：本地指针；
    x19：本地指针；
    x20：本地指针；
    x21：本地指针；
    x22：本地指针；
    x23：本地指针；
    x24：本地指针；
    x25：本地指针；
    x26：本地指针；
    x27：本地指针；
    x28：本地指针；

    fp：本地指针；
    lr：本地指针；
}

接口 MipsCpuContext 扩展 PortableCpuContext  {
    gp：本地指针；
    fp：本地指针；
    ra : NativePointer ;

    嗨：本地指针；
    lo : NativePointer ;

    在：本地指针；

    v0：本地指针；
    v1：本地指针；

    a0：本地指针；
    a1：本地指针；
    a2：本地指针；
    a3：本地指针；

    t0：本地指针；
    t1：本地指针；
    t2：本地指针；
    t3：本地指针；
    t4：本地指针；
    t5：本地指针；
    t6：本地指针；
    t7：本地指针；
    t8：本地指针；
    t9：本地指针；

    s0：本地指针；
    s1：本地指针；
    s2：本地指针；
    s3：本地指针；
    s4：本地指针；
    s5：本地指针；
    s6：本地指针；
    s7：本地指针；

    k0：本地指针；
    k1：本地指针；
}

// tslint:disable:no-unnecessary-class
声明 类 MatchPattern  {
    /**
     * 编译匹配模式以用于例如 `Memory.scan()`。
     *
     * @param pattern 匹配"13 37 ?? ff" 匹配 0x13 后跟 0x37 后跟任何字节
     * 后跟 0xff，或"/Some\s*Pattern/"，用于匹配正则表达式。
     *
     * 对于更高级的匹配，还可以指定 r2 样式的掩码。
     * 掩码是针对针和干草堆的按位与运算。指定掩码追加
     * 针后的 `:` 字符，后跟使用相同语法的掩码。
     * 例如："13 37 13 37 : 1f ff ff f1"。
     * 为方便起见，还可以指定半字节级别的通配符，例如"?3 37 13 ?7"，
     * 在幕后被翻译成面具。
     */
    构造函数（模式：字符串）；
}

/**
* TCP 和 UNIX 套接字。
*/
声明 命名空间 套接字 {
    /**
     * 打开一个 TCP 或 UNIX 监听套接字。
     *
     * 默认监听 IPv4 和 IPv6（如果支持），并随机绑定所有接口
     * 选定的端口。
     */
    函数 监听（选项？：SocketListenOptions ）：Promise < SocketListener > ；

    /**
     * 连接到 TCP 或 UNIX 服务器。
     */
    函数 连接（选项：SocketConnectOptions ）：Promise < SocketConnection > ；

    /**
     * 检查 OS 套接字 `handle` 并返回其类型，如果无效或未知，则返回 `null`。
     */
    函数 类型（句柄：数字）：SocketType  |  空；

    /**
     * 检查 OS 套接字 `handle` 并返回其本地地址，如果无效或未知，则返回 `null`。
     */
    函数 localAddress （句柄：数字）：SocketEndpointAddress  |  空；

    /**
     * 检查 OS 套接字 `handle` 并返回其对等地址，如果无效或未知，则返回 `null`。
     */
    函数 peerAddress （句柄：数字）：SocketEndpointAddress  |  空；
}

/**
* 由 `Socket.listen()` 创建的监听器。
*/
类型 SocketListener  =  TcpListener  |  Unix监听器；

接口 BaseListener  {
    /**
     * 关闭监听器，释放与之相关的资源。一旦监听器关闭，所有其他操作
     * 将失败。允许多次关闭侦听器并且不会导致错误。
     */
    关闭（）：承诺<无效> ；

    /**
     * 等待下一个客户端连接。
     */
    接受（）：承诺< SocketConnection > ;
}

接口 TcpListener 扩展 BaseListener  {
    /**
     * 正在监听的 IP 端口。
     */
    端口：号码；
}

接口 UnixListener 扩展 BaseListener  {
    /**
     * 正在监听的路径。
     */
    路径：字符串；
}

声明 抽象 类 SocketConnection 扩展 IOStream  {
    /**
     * 如果 `noDelay` 为 `true`，则禁用 Nagle 算法，否则启用它。Nagle 算法已启用
     * 默认情况下，如果您希望优化低延迟而不是
     * 高吞吐量。
     */
    setNoDelay ( noDelay : boolean ) : Promise < void > ;
}

声明 抽象 类 IOStream  {
    /**
     * 要读取的 `InputStream`。
     */
    输入：输入流；

    /**
     * 要写入的 `OutputStream`。
     */
    输出：输出流；

    /**
     * 关闭流，释放与其相关的资源。这也将关闭单个输入和输出
     * 流。一旦流关闭，所有其他操作都将失败。允许多次关闭流
     * 并且不会导致错误。
     */
    关闭（）：承诺<无效> ；
}

声明 抽象 类 InputStream  {
    /**
     * 关闭流，释放与其相关的资源。一旦流关闭，所有其他操作都将失败。
     * 允许多次关闭流，不会导致错误。
     */
    关闭（）：承诺<无效> ；

    /**
     * 从流中读取最多 `size` 字节。生成的缓冲区最长为 `size` 字节。流的结尾是
     * 通过空缓冲区发出信号。
     */
    读取（大小：数字）：承诺< ArrayBuffer > ；

    /**
     * 继续从流中读取，直到完全消耗了 `size` 字节。结果缓冲区正好
     * `size` 字节长。过早的错误或流结束导致带有 `partialData` 属性的`Error` 对象
     * 包含不完整的数据。
     */
    readAll ( size : number ) : Promise < ArrayBuffer > ;
}

声明 抽象 类 OutputStream  {
    /**
     * 关闭流，释放与其相关的资源。一旦流关闭，所有其他操作都将失败。
     * 允许多次关闭流，不会导致错误。
     */
    关闭（）：承诺<无效> ；

    /**
     * 尝试将 `data` 写入流。返回写入流的"数据"字节数。
     */
    write ( data : ArrayBuffer  |  number [ ] ) : Promise < number > ;

    /**
     * 继续写入流，直到所有"数据"都被写入。过早的错误或流结束导致
     * 带有 `partialSize` 属性的 `Error` 对象，指定将多少字节的 `data` 写入流
     * 在错误发生之前。
     */
    writeAll ( data : ArrayBuffer  |  number [ ] ) : Promise < void > ;

    /**
     * 尝试将 `size` 字节写入流，从 `address` 读取它们。返回写入的字节数
     * 到流。过早的错误或流结束导致带有 `partialSize` 属性的`Error` 对象
     * 指定在错误发生之前将多少字节的 `data` 写入流。
     */
    writeMemoryRegion （地址：NativePointerValue ， 大小：数字）：Promise <数字> ；
}

/**
* 由文件描述符支持的输入流。
*
* 仅适用于类 UNIX 操作系统。
*/
声明 类 UnixInputStream 扩展 InputStream  {
    /**
     * 从指定的文件描述符`fd`创建一个新的输入流。
     *
     * @param fd 要读取的文件描述符。
     * @param options 自定义流的选项。
     */
    构造函数（fd：数字， 选项？：UnixStreamOptions ）；
}

/**
* 由文件描述符支持的输出流。
*
* 仅适用于类 UNIX 操作系统。
*/
声明 类 UnixOutputStream 扩展 OutputStream  {
    /**
     * 从指定的文件描述符`fd`创建一个新的输出流。
     *
     * @param fd 要写入的文件描述符。
     * @param options 自定义流的选项。
     */
    构造函数（fd：数字， 选项？：UnixStreamOptions ）；
}

/**
* 由 Windows 文件句柄支持的输入流。
*
* 仅适用于 Windows。
*/
声明 类 Win32InputStream 扩展 InputStream  {
    /**
     * 从指定的 Windows 文件句柄创建一个新的输入流。
     *
     * @param处理要读取的 Windows 文件 `HANDLE`。
     * @param options 自定义流的选项。
     */
    构造函数（句柄：NativePointerValue ， 选项？：WindowsStreamOptions ）；
}

/**
* 由 Windows 文件句柄支持的输出流。
*
* 仅适用于 Windows。
*/
声明 类 Win32OutputStream 扩展 OutputStream  {
    /**
     * 从指定的 Windows 文件句柄创建一个新的输出流。
     *
     * @param处理要写入的 Windows 文件 `HANDLE`。
     * @param options 自定义流的选项。
     */
    构造函数（句柄：NativePointerValue ， 选项？：WindowsStreamOptions ）；
}

接口 UnixStreamOptions  {
    /**
     * 流关闭时是否应该关闭文件描述符，
     * 通过 `close()` 或未来的垃圾收集。
     */
    自动关闭？：布尔值 |  未定义；
}

接口 WindowsStreamOptions  {
    /**
     * 流关闭时是否应关闭 Windows `HANDLE`，
     * 通过 `close()` 或未来的垃圾收集。
     */
    自动关闭？：布尔值 |  未定义；
}

输入 地址家庭 =
    |  "Unix"
    |  "ipv4"
    |  "ipv6"
    ;

类型 SocketType  =
    |  "tcp"
    |  "udp"
    |  "tcp6"
    |  "udp6"
    |  "Unix：流"
    |  "unix：dgram"
    ;

类型 UnixSocketType  =
    |  "匿名的"
    |  "小路"
    |  "抽象的"
    |  "抽象填充"
    ;

类型 SocketListenOptions  =  TcpListenOptions  |  UnixListenOptions ;

接口 TcpListenOptions 扩展 BaseListenOptions  {
    /**
     * 地址家庭。忽略在 ipv4 和 ipv6 上侦听 - 如果操作系统支持。
     */
    家庭？："ipv4"  |  "ipv6"  |  未定义；

    /**
     * 要监听的主机或 IP 地址。省略侦听所有接口。
     */
    主机？：字符串 |  未定义；

    /**
     * 监听的端口。忽略在随机选择的端口上侦听。
     */
    端口？：号码 |  未定义；
}

接口 UnixListenOptions 扩展 BaseListenOptions  {
    /**
     * 地址家庭。
     */
    家庭："unix" ；

    /**
     * 要监听的 UNIX 套接字类型。默认为 UnixSocketType.Path。
     */
    类型？：UnixSocketType  |  未定义；

    /**
     * 要监听的 UNIX 套接字路径。
     */
    路径：字符串；
}

接口 BaseListenOptions  {
    /**
     * 收听积压。默认为 10。
     */
    积压？：数量 |  未定义；
}

类型 SocketConnectOptions  =  TcpConnectOptions  |  Unix连接选项；

接口 TcpConnectOptions  {
    /**
     * 地址家庭。省略根据指定的主机来确定。
     */
    家庭？："ipv4"  |  "ipv6"  |  未定义；

    /**
     * 要连接的主机或 IP 地址。默认为"本地主机"。
     */
    主机？：字符串 |  未定义；

    /**
     * 要连接的 IP 端口。
     */
    端口：号码；

    /**
     * 是否创建 TLS 连接。默认为"假"。
     */
    tls ?:布尔值 |  未定义；
}

接口 UnixConnectOptions  {
    /**
     * 地址家庭。
     */
    家庭："unix" ；

    /**
     * 要连接的 UNIX 套接字类型。默认为 UnixSocketType.Path。
     */
    类型？：UnixSocketType  |  未定义；

    /**
     * 要连接的 UNIX 套接字的路径。
     */
    路径：字符串；

    /**
     * 是否创建 TLS 连接。默认为"假"。
     */
    tls ?:布尔值 |  未定义；
}

类型 SocketEndpointAddress  =  TcpEndpointAddress  |  Unix端点地址；

接口 TcpEndpointAddress  {
    /**
     * IP地址。
     */
    ip：字符串；

    /**
     * 港口。
     */
    端口：号码；
}

接口 UnixEndpointAddress  {
    /**
     * UNIX 套接字路径。
     */
    路径：字符串；
}

/**
* 提供基本的文件系统访问。
*/
声明 类 文件 {
    /**
     * 传递给 `seek()` 以指定偏移量是相对于起点的
     * 文件。
     */
    静态 SEEK_SET : number ;

    /**
     * 传递给 `seek()` 以指定偏移量是相对于当前的
     * 文件位置。
     */
    静态 SEEK_CUR : number ;

    /**
     * 传递给 `seek()` 以指定偏移量是相对于结尾的
     * 文件。
     */
    静态 SEEK_END : number ;

    /**
     * 在 `filePath` 打开二进制文件，将其所有内容读入一个
     * ArrayBuffer，然后关闭文件。
     *
     * @param filePath 要读取的文件。
     */
    静态 readAllBytes （文件路径：字符串）：ArrayBuffer ；

    /**
     * 在 `filePath` 打开 UTF-8 编码的文本文件，读取其所有文本
     * 转换成字符串，然后关闭文件。
     *
     * @param filePath 要读取的文件。
     */
    静态 readAllText （文件路径：字符串）：字符串；

    /**
     * 在 `filePath` 创建一个新文件，将指定的字节写入其中，然后
     * 然后关闭文件。目标文件被覆盖，以防它已经
     * 存在。
     *
     * @param filePath 要写入的文件。
     * @param bytes 要写入文件的字节数。
     */
    静态 writeAllBytes （文件路径：字符串， 字节：ArrayBuffer  |  number [ ] ）：void；

    /**
     * 在 `filePath` 创建一个新文件，将指定的文本写入其中
     * 编码为 UTF-8，然后关闭文件。目标文件是
     * 如果它已经存在，则覆盖它。
     *
     * @param filePath 要写入的文件。
     * @param text 要写入文件的字符串。
     */
    静态 writeAllText （文件路径：字符串， 文本：字符串）：无效；

    /**
     * 在 `filePath` 打开或创建文件， `mode` 指定如何
     * 它应该被打开。例如 `"wb"` 打开文件进行写入
     * 在二进制模式下。这与 C 中的 `fopen()` 格式相同
     * 标准库。
     *
     * @param filePath 要打开或创建的文件的路径。
     * @param mode 要使用的模式。
     */
    构造函数（文件路径：字符串， 模式：字符串）；

    /**
     * 返回当前文件位置，以字节为单位。
     */
    告诉（）：数字；

    /**
     * 将当前文件位置更改为指定的 `offset`，以字节为单位。
     * 返回结果偏移量。
     *
     * @param offset 要查找的字节偏移量。
     * @param wherece 偏移量相对于什么（默认值：`File.SEEK_SET`）。
     */
    寻找（偏移：数字， 从哪里来？：数字）：数字；

    /**
     * 从文件中读取最多 `n` 个字节，或者文件的其余部分，如果
     * 未指定。当文件结束时返回一个空缓冲区
     * 到达。
     *
     * @param n 要读取的最大字节数。
     */
    readBytes ( n ?: number ) : ArrayBuffer ;

    /**
     * 从文件中读取最多 `n` 个字节到一个字符串中。如果 `n` 被省略，
     * 文件的其余部分被读取。结束时返回一个空字符串
     * 文件已到达。
     *
     * 确保数据是有效的 UTF-8，否则抛出错误。
     *
     * @param n 要读取的最大字节数。
     */
    readText ( n ?: number ) :字符串;

    /**
     * 从文件中读取一行文本，包括换行符。退货
     * 到达文件末尾时的空字符串。
     *
     * 确保数据是有效的 UTF-8，否则抛出错误。
     */
    readLine ( ) :字符串；

    /**
     * 将"数据"同步写入文件。
     *
     * @param data 要写入的数据。
     */
    写（数据：字符串 |  ArrayBuffer  | 数字[ ] ）：无效；

    /**
     * 将任何缓冲数据刷新到底层文件。
     */
    冲洗（）：无效；

    /**
     * 关闭文件。完成后应该调用此函数
     * 文件，除非当对象是
     * 垃圾收集或脚本被卸载。
     */
    关闭（）：无效；
}

/**
* 提供对校验和算法的访问。
*/
声明 类 校验和 {
    /**
     * 计算指定"数据"的校验和。将校验和返回为
     * 全小写十六进制字符串。摘要的长度取决于
     * 校验和的类型。
     *
     * @param type 所需的校验和类型。
     * @param data 计算校验和的数据。
     */
    静态 计算（类型：ChecksumType ， 数据：字符串 |  ArrayBuffer  |  number [ ] ）：字符串；

    /**
     * 创建一个用于计算数据流校验和的实例。
     * 以"打开"状态开始，数据通过一个或多个调用输入
     * 到`update()`。完成后，调用 `getString()` 或 `getDigest()`
     * 获得计算的校验和。这也将实例移动到"关闭"
     * state，这意味着 `update()` 可能不再被调用。（创建一个新的
     * 为后续数据计算校验和的实例。）
     *
     * @param type 要计算的校验和的类型。
     */
    构造函数（类型：ChecksumType ）；

    /**
     * 将"数据"输入校验和实例。校验和必须仍然打开，
     * 即 `getString()` 或 `getDigest()` 必须尚未被调用。
     *
     * @param data 用于计算校验和的数据。
     */
    更新（数据：字符串 |  ArrayBuffer  |  number [ ] ）：校验和；

    /**
     * 以全小写十六进制字符串的形式获取摘要。的长度
     * 摘要取决于校验和的类型。
     *
     * 一旦调用了这个方法，校验和就不能再更新了
     * 使用`update()`。
     */
    获取字符串（）：字符串；

    /**
     * 将摘要作为原始二进制向量获取。摘要的大小取决于
     * 关于校验和的类型。
     *
     * 一旦调用了这个方法，校验和就不能再更新了
     * 使用`update()`。
     */
    getDigest ( ) :数组缓冲区；
}

类型 校验和类型 =
    |  "md5"
    |  "沙1"
    |  "sha256"
    |  "sha384"
    |  "sha512"
    ;

/**
* 提供对 SQLite 数据库的读/写访问。对持久性有用
* 并在代理中嵌入缓存。
*/
声明 类 SqliteDatabase  {
    /**
     * 在文件系统的 `path` 打开 SQLite v3 数据库。数据库
     * 默认情况下会以读写方式打开，并返回 `SqliteDatabase`
     * 对象将允许您对其执行查询。抛出异常，如果
     * 无法打开数据库。
     *
     * @param path 数据库的文件系统路径。
     * @param options 自定义如何打开数据库的选项。
     */
    静态 打开（路径：字符串， 选项？：SqliteOpenOptions ）：SqliteDatabase ；

    /**
     * 就像 `open()` 一样，但是数据库的内容是作为一个
     * 包含其数据的字符串，Base64 编码。我们建议使用 gzip 压缩
     * Base64 编码之前的数据库，但这是可选的并且可以检测到
     * 通过寻找 gzip 魔术标记。数据库以读写方式打开，
     * 但 100% 在内存中，从不接触文件系统。抛出一个
     * 如果数据库格式错误，则异常。
     *
     * 这对于需要捆绑预计算缓存的代理很有用
     * 数据，例如用于指导动态分析的静态分析数据。
     *
     * @param encodedContents Base64 编码的数据库内容。
     */
    静态 openInline （编码内容：字符串）：SqliteDatabase ；

    /**
     * 关闭数据库。完成后应该调用此函数
     * 数据库，除非您对在对象存在时发生这种情况感到满意
     * 垃圾收集或脚本被卸载。
     */
    关闭（）：无效；

    /**
     * 执行原始 SQL 查询。如果查询无效，则引发异常。
     *
     * 查询的结果被忽略，所以这应该只用于查询
     * 用于设置数据库，例如创建表。
     *
     * @param sql SQL 查询的文本表示。
     */
    执行（sql：字符串）：无效；

    /**
     * 将提供的 SQL 编译成 `SqliteStatement` 对象。抛出一个
     * 如果查询无效则异常。
     *
     * @param sql SQL 查询的文本表示。
     */
    准备（sql：字符串）：SqliteStatement ；

    /**
     * 将数据库转储到编码为 Base64 的 gzip 压缩 blob。
     *
     * 这对于在代理代码中内联缓存很有用，由
     * 调用 `SqliteDatabase.openInline()`。
     */
    转储（）：字符串；
}

接口 SqliteOpenOptions  {
    标志？：SqliteOpenFlag [ ]  |  未定义；
}

类型 SqliteOpenFlag  =
    |  "只读"
    |  "读写"
    |  "创造"
    ;

/**
* 预编译的 SQL 语句。
*/
声明 类 SqliteStatement  {
    /**
     * 将整数 `value` 绑定到 `index`。
     *
     * @param index 基于 1 的索引。
     * @param value 要绑定的整数值。
     */
    bindInteger （索引：数字， 值：数字）：无效；

    /**
     * 将浮点 `value` 绑定到 `index`。
     *
     * @param index 基于 1 的索引。
     * @param value 要绑定的浮点值。
     */
    bindFloat （索引：数字， 值：数字）：无效；

    /**
     * 将文本 `value` 绑定到 `index`。
     * @param index 基于 1 的索引。
     * @param value 要绑定的文本值。
     */
    bindText （索引：数字， 值：字符串）：无效；

    /**
     * 将 blob `bytes` 绑定到 `index`。
     *
     * @param index 基于 1 的索引。
     * @param bytes 要绑定的 Blob 值。
     */
    bindBlob （索引：数字， 字节：ArrayBuffer  |  number [ ]  |  string ）：void；

    /**
     * 将 `null` 值绑定到 `index`。
     *
     * @param index 基于 1 的索引。
     */
    bindNull （索引：数字）：无效；

    /**
     * 要么开始一个新的查询并获得第一个结果，要么移动到
     * 下一个。
     *
     * 返回一个数组，其中包含按指定顺序排列的值
     * 查询，或者当达到最后一个结果时为 `null`。你应该打电话
     * 如果您打算再次使用此对象，请在此时执行"reset()"。
     */
    步骤( ) :任何[ ]  |  空；

    /**
     * 重置内部状态以允许后续查询。
     */
    重置（）：无效；
}

/**
* 通过内联挂钩拦截执行。
*/
声明 命名空间 拦截器 {
    /**
     * 在 `target` 处拦截对函数/指令的调用。这很重要
     * 如果 `target` 不是第一个，则指定 `InstructionProbeCallback`
     * 函数指令。
     *
     * @param target 要拦截的函数/指令的地址。
     * @param callbacksOrProbe 回调或指令级探测回调。
     * @param data 暴露给 `NativeInvocationListenerCallbacks` 的用户数据
     * 通过`GumInvocationContext *`。
     */
    函数 附加（目标：NativePointerValue ， callbacksOrProbe：InvocationListenerCallbacks  |  InstructionProbeCallback ，
        数据？：NativePointerValue ）：InvocationListener ；

    /**
     * 分离所有以前附加的侦听器。
     */
    函数 detachAll ( ) : void ;

    /**
     * 将 `target` 的函数替换为 `replacement` 的实现。
     *
     * 可以使用例如 `NativeCallback` 或 `CModule` 来实现。
     *
     * @param target 要替换的函数地址。
     * @param replacement 替换实现。
     * @param data 用户数据通过
     * `GumInvocationContext *`，使用获得
     *`gum_interceptor_get_current_invocation()`。
     */
    函数 替换（目标：NativePointerValue ， 替换：NativePointerValue ，
        数据？：NativePointerValue ）：无效；

    /**
     * 在 `target` 恢复先前替换的函数。
     */
    函数 还原（目标：NativePointerValue ）：无效；

    /**
     * 确保任何未决更改已提交到内存。
     */
    函数 冲洗（）：无效；
}

声明 类 InvocationListener  {
    /**
     * 分离之前通过 `Interceptor#attach()` 附加的监听器。
     */
    分离（）：无效；
}

/**
* 在函数调用之前和之后同步调用的回调。
*/
类型 InvocationListenerCallbacks  =  ScriptInvocationListenerCallbacks  |  NativeInvocationListenerCallbacks ;

接口 ScriptInvocationListenerCallbacks  {
    /**
     * 当线程即将进入目标函数时同步调用。
     */
    onEnter ?: ( ( this : InvocationContext ,  args : InvocationArguments )  =>  void )  |  未定义；

    /**
     * 当线程即将离开目标函数时同步调用。
     */
    onLeave ?: ( ( this : InvocationContext ,  retval : InvocationReturnValue )  =>  void )  |  未定义；
}

接口 NativeInvocationListenerCallbacks  {
    /**
     * 当线程即将进入目标函数时同步调用。
     *
     * 通常使用 `CModule` 实现。
     *
     * 签名：`void onEnter (GumInvocationContext * ic)`
     */
    onEnter ?: NativePointer  |  未定义；

    /**
     * 当线程即将离开目标函数时同步调用。
     *
     * 通常使用 `CModule` 实现。
     *
     * 签名：`void onLeave (GumInvocationContext * ic)`
     */
    onLeave ?: NativePointer  |  未定义；
}

/**
* 指令即将执行时调用的回调。
*/
类型 InstructionProbeCallback  =  ( this : InvocationContext ,  args : InvocationArguments )  =>  void ;

/**
* 提供对参数列表的访问的虚拟数组。与参数的数量及其类型无关。
*/
类型 InvocationArguments  =  NativePointer [ ] ;

/**
* 即将返回的值。
*/
声明 类 InvocationReturnValue 扩展 NativePointer  {
    /**
     * 替换本应返回的返回值。
     */
    替换（值：NativePointerValue ）：无效；
}

类型 InvocationContext  =  PortableInvocationContext  |  WindowsInvocationContext  |  UnixInvocationContext ;

接口 PortableInvocationContext  {
    /**
     * 退货地址。
     */
    返回地址：本地指针；

    /**
     * CPU 寄存器。您还可以通过分配给这些键来更新寄存器值。
     */
    上下文：CpuContext ；

    /**
     * 操作系统线程 ID。
     */
    线程标识：线程标识；

    /**
     * 相对于其他调用的调用深度。
     */
    深度：数字；

    /**
     * 用户定义的调用数据。如果您想在 `onEnter` 中读取参数并在 `onLeave` 中对其进行操作，这很有用。
     */
    [ x：字符串]：任意；
}

接口 WindowsInvocationContext 扩展 PortableInvocationContext  {
    /**
     * 当前操作系统错误值（您可以替换它）。
     */
    上一个错误：数字；
}

接口 UnixInvocationContext 扩展 PortableInvocationContext  {
    /**
     * 当前 errno 值（您可以替换它）。
     */
    错误号：数字；
}

/**
* 在每个线程的基础上执行。
*/
声明 命名空间 潜行者 {
    /**
     * 将内存范围标记为排除。这意味着 Stalker 不会跟随
     * 在遇到对此类范围内的指令的调用时执行。
     *因此，您将能够观察/修改输入的参数，并且
     * 返回值返回，但不会看到说明
     * 发生在之间。
     *
     * 有助于提高性能和降低噪音。
     *
     * @param range 要排除的范围。
     */
    功能 排除（范围：MemoryRange ）：无效；

    /**
     * 在给定线程的执行之后开始。
     *
     * @param threadId 执行后开始的线程ID，或者
     * 如果省略，则为当前线程。
     * @param options 自定义检测的选项。
     */
    函数 跟随（threadId？：ThreadId ， 选项？：StalkerOptions ）：void；

    /**
     * 在给定线程执行后停止。
     *
     * @param threadId 执行后停止的线程 ID，或
     * 如果省略，则为当前线程。
     */
    函数 取消关注（threadId？：ThreadId ）：void；

    /**
     * 解析由 `Gum.Event` 值组成的二进制 blob。
     *
     * @param events 包含零个或多个 `Gum.Event` 值的二进制 blob。
     * @param options 用于自定义输出的选项。
     */
    函数 解析（事件：ArrayBuffer ， 选项？：StalkerParseOptions ）：StalkerEventFull [ ]  |  StalkerEventBare [ ] ;

    /**
     * 清除所有缓冲的事件。当您不想等待时很有用
     * 直到下一个 `queueDrainInterval` 滴答声。
     */
    函数 冲洗（）：无效；

    /**
     * 在 `unfollow()` 之后在安全点释放累积的内存。这是
     * 需要避免刚刚取消关注的线程的竞争条件
     * 执行它的最后一条指令。
     */
    函数 垃圾收集（）：无效；

    /**
     * 使给定基本块的当前线程的翻译代码无效。
     * 在提供转换回调并希望动态处理时很有用
     *为给定的基本块调整仪器。这是更多
     * 比取消关注和重新关注线程更有效，这将
     * 丢弃所有缓存的翻译并要求所有遇到的基本块
     * 从头开始​​编译。
     *
     * @param address 要失效的基本块的起始地址。
     */
    函数 无效（地址：NativePointerValue ）：无效；

    /**
     * 使给定基本块的特定线程的翻译代码无效。
     * 在提供转换回调并希望动态处理时很有用
     *为给定的基本块调整仪器。这是更多
     * 比取消关注和重新关注线程更有效，这将
     * 丢弃所有缓存的翻译并要求所有遇到的基本块
     * 从头开始​​编译。
     *
     * @param threadId 应该使其某些代码无效的线程。
     * @param address 要失效的基本块的起始地址。
     */
    函数 无效（threadId：ThreadId ， 地址：NativePointerValue ）：void；

    /**
     * 当调用 `address` 时同步调用 `callback`。
     * 返回一个可以稍后传递给 `removeCallProbe()` 的 id。
     *
     * @param address 监控跟踪调用的函数地址。
     * @param callback 被跟踪时同步调用的函数
     * 线程即将调用 `address` 处的函数。
     * @param data 要传递给 `StalkerNativeCallProbeCallback` 的用户数据。
     */
    函数 addCallProbe （地址：NativePointerValue ， 回调：StalkerCallProbeCallback ，
        数据？：NativePointerValue ）：StalkerCallProbeId ；

    /**
     * 移除由 `addCallProbe()` 添加的调用探针。
     *
     * @param callbackId 要移除的探测 ID。
     */
    函数 removeCallProbe ( callbackId : StalkerCallProbeId ) : void ;

    /**
     * 一段代码在假定之前需要执行多少次
     * 可以相信它不会发生变异。指定 -1 表示不信任（慢），指定 0 表示
     * 从一开始就信任代码，N 到信任代码之后
     * 执行 N 次。
     *
     * 默认为 1。
     */
    让 trustThreshold : number ;

    /**
     * 事件队列的事件数容量。
     *
     * 默认为 16384 个事件。
     */
    让 queueCapacity : number ;

    /**
     * 每次事件队列耗尽之间的时间（以毫秒为单位）。
     *
     * 默认为 250 毫秒，这意味着事件队列被耗尽了 4
     * 每秒次数。您也可以将此属性设置为零以禁用
     * 定期排空，当你愿意时调用 `Stalker.flush()`
     * 喜欢排队被排空。
     */
    让 queueDrainInterval : number ;
}

/**
* 自定义 Stalker 仪器的选项。
*
* 请注意，提供的回调对性能有重大影响。
* 如果您只需要定期通话摘要但不关心原始
* 事件，或者相反，确保你省略了你的回调
* 不需要；即避免将您的逻辑放在"onCallSummary"中并离开
* `onReceive` 在那里作为一个空回调。
*/
接口 StalkerOptions  {
    /**
     * 应该生成哪些事件（如果有）并定期传送给
     * `onReceive()` 和/或 `onCallSummary()`。
     */
    事件？：{
        /**
         * 是否为 CALL/BLR 指令生成事件。
         */
        调用?:布尔值 |  未定义；

        /**
         * 是否为 RET 指令生成事件。
         */
        ret ?:布尔值 |  未定义；

        /**
         * 是否为所有指令生成事件。
         *
         * 不推荐，因为它可能包含大量数据。
         */
        执行？：布尔值 |  未定义；

        /**
         * 是否在执行基本块时生成事件。
         *
         * 用于记录粗略的执行跟踪。
         */
        块？：布尔值 |  未定义；

        /**
         * 是否在编译基本块时生成事件。
         *
         * 对覆盖有用。
         */
        编译？：布尔值 |  未定义；
    }  |  未定义；

    /**
     * 定期接收批量事件的回调。
     *
     * @param events 由一个或多个 `Gum.Event` 结构组成的二进制 blob。
     * 有关格式的详细信息，请参阅 `gumevent.h`。
     * 使用 `Stalker.parse()` 来检查数据。
     */
    onReceive ?: ( (事件: ArrayBuffer )  =>  void )  |  未定义；

    /**
     * 定期接收 `call` 事件摘要的回调
     * 发生在每个时间窗口。
     *
     * 你通常会实现这个而不是 `onReceive()`
     * 效率，即当您只想知道调用了哪些目标时
     * 和多少次，但不关心调用的顺序
     *发生在。
     *
     * @param summary 调用目标到调用次数的键值映射，in
     * 当前时间窗口。
     */
    onCallSummary ?: ( (摘要: StalkerCallSummary )  =>  void )  |  未定义；

    /**
     * 在事件发生时处理事件的 C 回调，允许同步
     * 在本机代码中处理事件----通常使用实现
     * 模块。
     *
     * 这在想要实现自定义过滤和/或排队时很有用
     * 提高性能的逻辑，或者牺牲性能来换取
     *可靠的事件传递。
     *
     * 请注意，这排除了 `onReceive()` 和 `onCallSummary()` 的使用。
     */
    onEvent ?: StalkerNativeEventCallback  |  未定义；

    /**
     * 每当 Stalker 编译时转换每个基本块的回调
     * 想要重新编译即将执行的基本代码块
     * 通过跟踪线程。
     */
    变换？：StalkerTransformCallback  |  未定义；

    /**
     * 用户数据被传递给 `StalkerNativeEventCallback` 和 `StalkerNativeTransformCallback`。
     */
    数据？：NativePointerValue  |  未定义；
}

接口 StalkerParseOptions  {
    /**
     * 是否包含每个事件的类型。默认为"真"。
     */
    注释？：布尔值 |  未定义；

    /**
     * 是否将指针值格式化为字符串而不是 `NativePointer`
     * 值，即如果你只是要`send()` 结果，开销会更少
     * 而不是真正解析数据代理端。
     */
    stringify ?:布尔值 |  未定义；
}

接口 StalkerCallSummary  {
    [目标：字符串]：数字；
}

类型 StalkerCallProbeCallback  =  StalkerScriptCallProbeCallback  |  StalkerNativeCallProbeCallback ;

/**
* 当调用给定地址时同步调用。
*/
键入 StalkerScriptCallProbeCallback  =  ( args : InvocationArguments )  =>  void ;

/**
* 当调用给定地址时同步调用。
*
* 签名：`void onCall (GumCallSite * site, gpointer user_data)`
*/
键入 StalkerNativeCallProbeCallback  =  NativePointer ；

输入 StalkerCallProbeId  =  number ;

类型 StalkerEventType  =
    |  "称呼"
    |  "退"
    |  "执行"
    |  "堵塞"
    |  "编译"
    ;

类型 StalkerEventFull  =  StalkerCallEventFull  |  StalkerRetEventFull  |  StalkerExecEventFull  |
    StalkerBlockEventFull  |  StalkerCompileEventFull ;
类型 StalkerEventBare  =  StalkerCallEventBare  |  StalkerRetEventBare  |  StalkerExecEventBare  |
    StalkerBlockEventBare  |  StalkerCompileEventBare ;

类型 StalkerCallEventFull  =  [  "调用" ,  NativePointer  |  字符串， 本地指针 |  字符串， 数字 ] ；
类型 StalkerCallEventBare  =  [          NativePointer  |  字符串， 本地指针 |  字符串， 数字 ] ；

类型 StalkerRetEventFull  =  [  "ret" ,  NativePointer  |  字符串， 本地指针 |  字符串， 数字 ] ；
类型 StalkerRetEventBare  =  [         NativePointer  |  字符串， 本地指针 |  字符串， 数字 ] ；

类型 StalkerExecEventFull  =  [  "exec" ,  NativePointer  |  字符串 ] ;
类型 StalkerExecEventBare  =  [          NativePointer  |  字符串 ] ;

类型 StalkerBlockEventFull  =  [  "块" ,  NativePointer  |  字符串， 本地指针 |  字符串 ] ;
类型 StalkerBlockEventBare  =  [           NativePointer  |  字符串， 本地指针 |  字符串 ] ;

类型 StalkerCompileEventFull  =  [  "编译" ,  NativePointer  |  字符串， 本地指针 |  字符串 ] ;
类型 StalkerCompileEventBare  =  [             NativePointer  |  字符串， 本地指针 |  字符串 ] ;

/**
* 签名：`void process (const GumEvent * event, GumCpuContext * cpu_context, gpointer user_data)`
*/
输入 StalkerNativeEventCallback  =  NativePointer ；

输入 StalkerTransformCallback  =
    |  StalkerX86TransformCallback
    |  StalkerArm32TransformCallback
    |  StalkerArm64TransformCallback
    |  StalkerNativeTransformCallback
    ;

类型 StalkerX86TransformCallback  =  （迭代器：StalkerX86Iterator ） => 无效；
类型 StalkerArm32TransformCallback  =  （迭代器：StalkerArmIterator  |  StalkerThumbIterator ） => 无效；
类型 StalkerArm64TransformCallback  =  （迭代器：StalkerArm64Iterator ） => 无效；

/**
* 签名：`void transform (GumStalkerIterator * iterator, GumStalkerOutput * output, gpointer user_data)`
*/
输入 StalkerNativeTransformCallback  =  NativePointer ；

接口 StalkerX86Iterator 扩展 X86Writer  {
    next ( ) : X86 指令 |  空；
    保持（）：无效；
    putCallout （标注：StalkerCallout ， 数据？：NativePointerValue ）：无效；
}

接口 StalkerArmIterator 扩展 ArmWriter  {
    next ( ) :手臂指令 |  空；
    保持（）：无效；
    putCallout （标注：StalkerCallout ， 数据？：NativePointerValue ）：无效；
}

接口 StalkerThumbIterator 扩展 ThumbWriter  {
    next ( ) :手臂指令 |  空；
    保持（）：无效；
    putCallout （标注：StalkerCallout ， 数据？：NativePointerValue ）：无效；
}

接口 StalkerArm64Iterator 扩展 Arm64Writer  {
    next ( ) : Arm64 指令 |  空；
    保持（）：无效；
    putCallout （标注：StalkerCallout ， 数据？：NativePointerValue ）：无效；
}

类型 StalkerCallout  =  StalkerScriptCallout  |  StalkerNativeCallout ;

类型 StalkerScriptCallout  =  (上下文: CpuContext )  =>  void ;

/**
* 签名：`void onAesEnc (GumCpuContext * cpu_context, gpointer user_data)`
*/
输入 StalkerNativeCallout  =  NativePointer ；

/**
* 使用 glob 提供高效的 API 解析，让您快速
* 按名称查找函数，允许使用 glob。
*/
声明 类 ApiResolver  {
    /**
     * 创建给定"类型"的新解析器。
     *
     * 确切地说，哪些解析器可用取决于当前
     * 当前进程中加载​​的平台和运行时。
     *
     * 解析器将加载创建时所需的最少数据量，
     * 并根据收到的查询延迟加载其余部分。就这样
     * 建议对一批查询使用同一个实例，但是
     * 为以后的批次重新创建它，以避免查看过时的数据。
     *
     * @param type 要创建的解析器的类型。
     */
    构造函数（类型：ApiResolverType ）；

    /**
     * 执行特定于解析器的查询。
     *
     * @param query 解析器特定的查询，可选地以`/i`作为后缀
     * 执行不区分大小写的匹配。
     */
    enumerateMatches （查询：字符串）：ApiResolverMatch [ ] ；
}

接口 ApiResolverMatch  {
    /**
     * 找到的函数的规范名称。
     */
    名称：字符串；

    /**
     * 加载给定函数的内存地址。
     */
    地址：本地指针；
}

类型 ApiResolverType  =
    /**
     * 解决共享库的导出和导入功能
     * 当前加载。
     *
     * 始终可用。
     *
     * 示例查询：`"exports:*!open*"`
     * 可以解析为：`"/usr/lib/libSystem.B.dylib!opendir$INODE64"`
     * 后缀 `/i` 以执行不区分大小写的匹配。
     */
    |  "模块"

    /**
     * 解析当前加载的类的 Objective-C 方法。
     *
     * 在 macOS 和 iOS 的具有 Objective-C 的进程中可用
     * 运行时加载。使用 `ObjC.available` 在运行时检查，或包装
     * 你的 `new ApiResolver(ApiResolverType.ObjC)` 在 try-catch 中调用。
     *
     * 示例查询：`"-[NSURL* *HTTP*]"`
     * 可以解析为：`"-[NSURLRequest valueForHTTPHeaderField:]"`
     * 后缀 `/i` 以执行不区分大小写的匹配。
     */
    |  "对象"
    ;

声明 类 DebugSymbol  {
    /**
     * 此符号的地址。
     */
    地址：本地指针；

    /**
     * 符号的名称，如果未知，则为 `null`。
     */
    名称：字符串 |  空；

    /**
     * 拥有此符号的模块名称，如果未知，则为 `null`。
     */
    模块名称：字符串 |  空；

    /**
     * 拥有此符号的文件名，如果未知，则为 `null`。
     */
    文件名：字符串 |  空；

    /**
     * `fileName` 中的行号，如果未知，则为 `null`。
     */
    行号：数字 |  空；

    /**
     * 查找 `address` 的调试信息。
     *
     * @param address 要查找详细信息的地址。
     */
    静态 fromAddress （地址：NativePointerValue ）：DebugSymbol ；

    /**
     * 查找 `name` 的调试信息。
     *
     * @param name 要查找详细信息的名称。
     */
    静态 fromName （名称：字符串）：DebugSymbol ；

    /**
     * 解析函数名并返回其地址。返回第一个 if
     * 发现不止一个函数。如果名称不能，则抛出异常
     * 得到解决。
     *
     * @param name 解析地址的函数名。
     */
    静态 getFunctionByName （名称：字符串）：NativePointer ；

    /**
     * 解析函数名并返回其地址。
     *
     * @param name 解析地址的函数名。
     */
    静态 findFunctionsNamed ( name : string ) : NativePointer [ ] ;

    /**
     * 解析匹配 `glob` 的函数名称并返回它们的地址。
     *
     * @param glob Glob 匹配函数来解析地址。
     */
    静态 findFunctionsMatching ( glob : string ) : NativePointer [ ] ;

    /**
     * 加载特定模块的调试符号。
     *
     * @param path 要为其加载符号的模块路径。
     */
    静态 负载（路径：字符串）：无效；

    /**
     * 转换为人类可读的字符串。
     */
    toString ( ) :字符串;
}

/**
* 将 C 源代码编译为机器码，直接存入内存。也可能是
* 从预编译的共享库构建。
*
* 用于实现热回调，例如对于 `Interceptor` 和 `Stalker`，
* 但在需要启动新线程以调用函数时也很有用
* 在一个紧密的循环中，例如用于模糊测试。
*
* 全局函数自动导出为 `NativePointer` 属性
* 与 C 源代码中的名称完全相同。这意味着您可以将它们传递给
* `Interceptor` 和 `Stalker`，或使用 `NativeFunction` 调用它们。
*
* 除了访问 Gum、GLib 和标准 C API 的精选子集，
* 被映射的代码也可以通过
* 暴露给它的符号。这些可以在创建时插入，例如共享
* 使用 `Memory.alloc()` 或 `NativeCallback` 值分配的内存
* 接收来自 C 模块的回调。
*
* 要执行初始化和清理，您可以使用
* 以下姓名和签名：
*
*`无效初始化（无效）`
* `void finalize (void)`
*
* 注意所有数据都是只读的，所以应该声明可写的全局变量
* `extern`，使用例如`Memory.alloc()`分配，并作为符号传入
* 通过构造函数的第二个参数。
*/
声明 类 CModule  {
    /**
     * 从提供的"代码"创建一个新的 C 模块。
     *
     * @param code 要编译的 C 源代码，或预编译的共享库。
     * @param symbols 暴露给 C 模块的符号。将它们声明为"外部"。
     * 例如，这可能是使用分配的一个或多个内存块
     * `Memory.alloc()`, 和/或 `NativeCallback` 用于接收的值
     * 来自 C 模块的回调。
     * @param options 用于自定义构造的选项。
     */
    构造函数（代码：字符串 |  ArrayBuffer ， 符号？：CSymbols ， 选项？：CModuleOptions ）；

    /**
     * 急切地从内存中取消映射模块。对短期模块有用
     * 不希望等待未来的垃圾回收时。
     */
    处置（）：无效；

    只读 [名称：字符串]：任意；

    静态内置 函数：CModuleBuiltins ；
}

接口 CModuleOptions  {
    工具链？：CModuleToolchain  |  未定义；
}

/**
* 从 C 源代码构建 CModule 时使用的工具链。
*
* `internal`：使用静态链接到运行时的 TinyCC。
* 从不接触文件系统，即使在沙盒进程中也能正常工作。
* 然而，生成的代码没有优化，因为 TinyCC 优化了
* 编译器占用空间小，编译时间短。
* `external`：使用目标系统提供的工具链，假设是
* 可访问我们正在内部执行的进程。
* `any`：如果 TinyCC 支持 `Process.arch`，则与 `internal` 相同，并且
* `外部`否则。
*/
类型 CModuleToolchain  =  "任何"  |  "内部"  |  "外部" ；

接口 CSymbols  {
    [名称：字符串]：NativePointerValue ；
}

/**
* 从 C 源代码构建 CModule 时存在内置函数。
*
* 这通常由诸如`frida-create`之类的脚手架工具使用
* 设置与 CModule 使用的内容相匹配的构建环境。
*/
接口 CModuleBuiltins  {
    定义：CModuleDefines ；
    标头：CModuleHeaders ；
}

/**
* 预处理器在从 C 源代码构造 CModule 时定义存在。
*
* 到 GCC 风格的命令行参数的映射取决于值的类型：
* `string`: `-Dname=value`
* `true`: `-Dname`
*/
接口 CModuleDefines  {
    只读 [名称:字符串] :字符串 |  真；
}

/**
* 从 C 源代码构造 CModule 时出现 C 头文件。
*
* `name`是一个相对文件系统路径，值是文件系统的内容
* 标题。
*/
接口 CModuleHeaders  {
    只读 [名称：字符串]：字符串；
}

声明 类 指令 {
    /**
     * 解析内存中"目标"地址处的指令。
     *
     * 请注意，在 32 位 ARM 上，此地址必须有其最低有效位
     * ARM 函数设置为 0，Thumb 函数设置为 1。弗里达照顾
     * 如果您从 Frida API 获取地址，则为您提供此详细信息，用于
     * 示例`Module.getExportByName()`。
     *
     * @param target 包含要解析的指令的内存位置。
     */
    静态 解析（目标：NativePointerValue ）：指令 |  X86使用说明 |  手臂使用说明 |  Arm64使用说明 |  Mips指令；

    /**
     * 本指令的地址 (EIP)。
     */
    地址：本地指针；

    /**
     * 指向下一条指令的指针，所以你可以`parse()`它。
     */
    下一个：本地指针；

    /**
     * 本指令的大小。
     */
    大小：数字；

    /**
     * 指令助记符。
     */
    助记符：字符串；

    /**
     * 指令操作数的字符串表示。
     */
    opStr：字符串；

    /**
     * 该指令所属的组名。
     */
    组：字符串[ ] ；

    /**
     * 转换为人类可读的字符串。
     */
    toString ( ) :字符串;
}

声明 类 X86Instruction 扩展 指令 {
    /**
     * 描述每个操作数的对象数组。
     */
    操作数：X86Operand [ ] ；

    /**
     * 该指令隐式或显式访问的寄存器。
     */
    regsAccessed : RegsAccessed < X86Register > ;

    /**
     * 该指令隐式读取的寄存器。
     */
    regsRead : X86Register [ ] ;

    /**
     * 该指令隐式写入的寄存器。
     */
    regsWritten : X86Register [ ] ;
}

声明 类 ArmInstruction 扩展 指令 {
    /**
     * 描述每个操作数的对象数组。
     */
    操作数：ArmOperand [ ] ;

    /**
     * 该指令隐式或显式访问的寄存器。
     */
    regsAccessed : RegsAccessed < ArmRegister > ;

    /**
     * 该指令隐式读取的寄存器。
     */
    regsRead : ArmRegister [ ] ;

    /**
     * 该指令隐式写入的寄存器。
     */
    regsWritten : ArmRegister [ ] ;
}

声明 类 Arm64Instruction 扩展 指令 {
    /**
     * 描述每个操作数的对象数组。
     */
    操作数：Arm64Operand [ ] ；

    /**
     * 该指令隐式或显式访问的寄存器。
     */
    regsAccessed : RegsAccessed < Arm64Register > ;

    /**
     * 该指令隐式读取的寄存器。
     */
    regsRead : Arm64Register [ ] ;

    /**
     * 该指令隐式写入的寄存器。
     */
    regsWritten : Arm64Register [ ] ;
}

声明 类 MipsInstruction 扩展 指令 {
    /**
     * 描述每个操作数的对象数组。
     */
    操作数：MipsOperand [ ] ;

    /**
     * 该指令隐式或显式访问的寄存器。
     */
    regsAccessed : RegsAccessed < MipsRegister > ;

    /**
     * 该指令隐式读取的寄存器。
     */
    regsRead : MipsRegister [ ] ;

    /**
     * 该指令隐式写入的寄存器。
     */
    regsWritten : MipsRegister [ ] ;
}

接口 RegsAccessed < T >  {
    阅读：T [ ] ;
    写：T [ ] ;
}

类型 OperandAccess  =  ""  |  "r"  |  "w"  |  "rw" ;

类型 X86Operand  =  X86RegOperand  |  X86ImmOperand  |  X86MemOperand ;

类型 X86OperandType  =  "reg"  |  "嗯"  |  "记忆" ；

接口 X86BaseOperand  {
    大小：数字；
    访问：操作数访问；
}

接口 X86RegOperand 扩展 X86BaseOperand  {
    类型："注册" ；
    值：X86寄存器；
}

接口 X86ImmOperand 扩展 X86BaseOperand  {
    类型："imm" ；
    值：数字 |  整数64 ；
}

接口 X86MemOperand 扩展 X86BaseOperand  {
    类型："内存" ；
    价值：{
        段?: X86Register  |  未定义；
        base ?: X86Register  |  未定义；
        索引?: X86Register  |  未定义；
        规模：数字；
        显示：数字；
    } ;
}

类型 ArmOperand  =  ArmRegOperand  |  ArmImm 操作数 |  ArmMemOperand  |
    ArmFp操作数 |  ArmCimmOperand  |  ArmPimm 操作数 |  ArmSetendOperand  |
    ArmSysregOperand ;

类型 ArmOperandType  =
    |  "注册"
    |  "嗯"
    |  "记忆"
    |  "fp"
    |  "西姆"
    |  "皮姆"
    |  "设置"
    |  "系统注册"
    ;

接口 ArmBaseOperand  {
    转移？：{
        类型：ArmShifter ；
        值：数字；
    }  |  未定义；
    向量索引？：数字 |  未定义；
    减去：布尔值；
    访问：操作数访问；
}

接口 ArmRegOperand 扩展 ArmBaseOperand  {
    类型："注册" ；
    值: ArmRegister ;
}

接口 ArmImmOperand 扩展 ArmBaseOperand  {
    类型："imm" ；
    值：数字；
}

接口 ArmMemOperand 扩展 ArmBaseOperand  {
    类型："内存" ；
    价值：{
        基地?: ArmRegister  |  未定义；
        索引?: ArmRegister  |  未定义；
        规模：数字；
        显示：数字；
    } ;
}

接口 ArmFpOperand 扩展 ArmBaseOperand  {
    类型："fp" ；
    值：数字；
}

接口 ArmCimmOperand 扩展 ArmBaseOperand  {
    类型："cimm" ；
    值：数字；
}

接口 ArmPimmOperand 扩展 ArmBaseOperand  {
    类型："皮姆" ；
    值：数字；
}

接口 ArmSetendOperand 扩展 ArmBaseOperand  {
    类型："setend" ；
    值：字节序；
}

接口 ArmSysregOperand 扩展 ArmBaseOperand  {
    类型："系统注册" ；
    值: ArmRegister ;
}

类型 Arm64Operand  =  Arm64RegOperand  |  Arm64ImmOperand  |  Arm64MemOperand  |
    Arm64Fp操作数 |  Arm64CimmOperand  |  Arm64RegMrsOperand  |  Arm64RegMsrOperand  |
    Arm64PstateOperand  |  Arm64SysOperand  |  Arm64PrefetchOperand  |  Arm64BarrierOperand ;

类型 Arm64OperandType  =
    |  "注册"
    |  "嗯"
    |  "记忆"
    |  "fp"
    |  "西姆"
    |  "注册太太"
    |  "注册-msr"
    |  "pstate"
    |  "系统"
    |  "预取"
    |  "障碍"
    ;

接口 Arm64BaseOperand  {
    转移？：{
        类型：Arm64Shifter ；
        值：数字；
    }  |  未定义；
    分机？：Arm64Extender  |  未定义；
    vas ?: Arm64Vas  |  未定义；
    向量索引？：数字 |  未定义；
    访问：操作数访问；
}

接口 Arm64RegOperand 扩展 Arm64BaseOperand  {
    类型："注册" ；
    值：ARM64寄存器；
}

接口 Arm64ImmOperand 扩展 Arm64BaseOperand  {
    类型："imm" ；
    值：Int64 ；
}

接口 Arm64MemOperand 扩展 Arm64BaseOperand  {
    类型："内存" ；
    价值：{
        base ?: Arm64Register  |  未定义；
        索引?: Arm64Register  |  未定义；
        显示：数字；
    } ;
}

接口 Arm64FpOperand 扩展 Arm64BaseOperand  {
    类型："fp" ；
    值：数字；
}

接口 Arm64CimmOperand 扩展 Arm64BaseOperand  {
    类型："cimm" ；
    值：Int64 ；
}

接口 Arm64RegMrsOperand 扩展 Arm64BaseOperand  {
    类型："reg-mrs" ；
    值：ARM64寄存器；
}

接口 Arm64RegMsrOperand 扩展 Arm64BaseOperand  {
    类型："reg-msr" ；
    值：ARM64寄存器；
}

接口 Arm64PstateOperand 扩展 Arm64BaseOperand  {
    类型："pstate" ；
    值：数字；
}

接口 Arm64SysOperand 扩展 Arm64BaseOperand  {
    类型："系统" ；
    值：数字；
}

接口 Arm64PrefetchOperand 扩展 Arm64BaseOperand  {
    类型："预取" ；
    值：数字；
}

接口 Arm64BarrierOperand 扩展 Arm64BaseOperand  {
    类型："障碍" ；
    值：数字；
}

类型 Arm64Shifter  =
    |  "lsl"
    |  "msl"
    |  "lsr"
    |  "asr"
    |  "罗"
    ;

类型 Arm64Extender  =
    |  "uxtb"
    |  "第"
    |  "uxtw"
    |  "xtx"
    |  "sxtb"
    |  "第"
    |  "sxtw"
    |  "sxx"
    ;

类型 Arm64Vas  =
    |  "8b"
    |  "16b"
    |  "4小时"
    |  "8小时"
    |  "2s"
    |  "4s"
    |  "1d"
    |  "二维"
    |  "1q"
    ;

类型 MipsOperand  =  MipsRegOperand  |  MipsImmOperand  |  MipsMemOperand ;

类型 MipsOperandType  =  "reg"  |  "嗯"  |  "记忆" ；

接口 MipsRegOperand  {
    类型："注册" ；
    值：MipsRegister ；
}

接口 MipsImmOperand  {
    类型："imm" ；
    值：数字；
}

接口 MipsMemOperand  {
    类型："内存" ；
    价值：{
        base ?: MipsRegister  |  未定义；
        显示：数字；
    } ;
}

类型 Endian  =  "是"  |  "乐" ；

声明 命名空间 内核 {
    /**
     * 内核 API 是否可用。
     */
    常量 可用：布尔值；

    /**
     * 内核的基地址。可以用任何非零 UInt64 覆盖。
     */
    让 基地：UInt64 ；

    /**
     * 内核页面的大小（以字节为单位）。
     */
    常量 pageSize : number ;

    /**
     * 枚举当前加载的内核模块。
     */
    函数 enumerateModules ( ) : KernelModuleDetails [ ] ;

    /**
     * 枚举所有匹配"说明符"的内核内存范围。
     *
     * @param specifier 要包含的范围类型。
     */
    函数 enumerateRanges （说明符：PageProtection  |  EnumerateRangesSpecifier ）：KernelRangeDetails [ ] ；

    /**
     * 枚举内核模块的所有范围。
     *
     * @param name 模块的名称，或者 `null` 表示内核本身的模块。
     * @param protection 包括至少具有此保护的范围。
     */
    函数 enumerateModuleRanges （名称：字符串 |  null ， 保护：PageProtection ）：KernelModuleRangeDetails [ ] ；

    /**
     * 分配内核内存。
     *
     * @param size 分配的大小（以字节为单位）（将四舍五入为内核页面大小的倍数）。
     */
    函数 分配（大小：数字 |  UInt64 ）：UInt64 ；

    /**
     * 更改内核内存区域的页面保护。
     *
     * @param address 起始地址。
     * @param size 字节数。必须是 Process#pageSize 的倍数。
     * @param protection 所需的页面保护。
     */
    功能 保护（地址：UInt64 ， 大小：数字 |  UInt64 ， 保护：PageProtection ）：布尔值；

    /**
     * 在 `address` 和 `size` 给定的内存范围内扫描内核内存以查找 `pattern` 的出现。
     *
     * @param address 要扫描的起始地址。
     * @param size 要扫描的字节数。
     * @param pattern 匹配模式，详见 `MatchPattern`。
     * @param callbacks 带有回调的对象。
     */
    函数 扫描（地址：UInt64 ， 大小：数字 |  UInt64 ， 模式：字符串 |  MatchPattern ，
        回调: KernelMemoryScanCallbacks ) : Promise < void > ;

    /**
     * `scan()` 的同步版本。
     *
     * @param address 要扫描的起始地址。
     * @param size 要扫描的字节数。
     * @param pattern 匹配模式，详见 `Memory.scan()`。
     */
    函数 scanSync （地址：UInt64 ， 大小：数字 |  UInt64 ， 模式：字符串 |  MatchPattern ）：KernelMemoryScanMatch [ ] ；

    函数 readS8 （地址：UInt64 ）：数字；
    函数 readU8 （地址：UInt64 ）：数字；
    函数 readS16 （地址：UInt64 ）：数字；
    函数 readU16 （地址：UInt64 ）：数字；
    函数 readS32 （地址：UInt64 ）：数字；
    函数 readU32 （地址：UInt64 ）：数字；
    函数 readS64 （地址：UInt64 ）：Int64 ；
    函数 readU64 （地址：UInt64 ）：UInt64 ；
    函数 readShort （地址：UInt64 ）：数字；
    函数 readUShort （地址：UInt64 ）：数字；
    函数 readInt （地址：UInt64 ）：数字；
    函数 readUInt （地址：UInt64 ）：数字；
    函数 readLong （地址：UInt64 ）：数字 |  整数64 ；
    函数 readULong （地址：UInt64 ）：数字 |  UInt64 ;
    函数 readFloat （地址：UInt64 ）：数字；
    函数 readDouble （地址：UInt64 ）：数字；
    函数 readByteArray （地址：UInt64 ， 长度：数字）：ArrayBuffer  |  空；
    函数 readCString （地址：UInt64 ， 大小：数字）：字符串 |  空；
    函数 readUtf8String （地址：UInt64 ， 大小：数字）：字符串 |  空；
    函数 readUtf16String （地址：UInt64 ， 长度：数字）：字符串 |  空；

    函数 writeS8 （地址：UInt64 ， 值：数字 |  Int64 ）：无效；
    函数 writeU8 （地址：UInt64 ， 值：数字 |  UInt64 ）：无效；
    函数 writeS16 （地址：UInt64 ， 值：数字 |  Int64 ）：无效；
    函数 writeU16 （地址：UInt64 ， 值：数字 |  UInt64 ）：无效；
    函数 writeS32 （地址：UInt64 ， 值：数字 |  Int64 ）：无效；
    函数 writeU32 （地址：UInt64 ， 值：数字 |  UInt64 ）：void；
    函数 writeS64 （地址：UInt64 ， 值：数字 |  Int64 ）：无效；
    函数 writeU64 （地址：UInt64 ， 值：数字 |  UInt64 ）：void；
    函数 writeShort （地址：UInt64 ， 值：数字 |  Int64 ）：无效；
    函数 writeUShort （地址：UInt64 ， 值：数字 |  UInt64 ）：无效；
    函数 writeInt （地址：UInt64 ， 值：数字 |  Int64 ）：无效；
    函数 writeUInt （地址：UInt64 ， 值：数字 |  UInt64 ）：无效；
    函数 writeLong （地址：UInt64 ， 值：数字 |  Int64 ）：无效；
    函数 writeULong （地址：UInt64 ， 值：数字 |  UInt64 ）：无效；
    函数 writeFloat （地址：UInt64 ， 值：数字）：void；
    函数 writeDouble （地址：UInt64 ， 值：数字）：void；
    函数 writeByteArray （地址：UInt64 ， 值：ArrayBuffer  |  number [ ] ）：void；
    函数 writeUtf8String （地址：UInt64 ， 值：字符串）：void；
    函数 writeUtf16String （地址：UInt64 ， 值：字符串）：void；
}

声明 命名空间 ObjC  {
    // tslint:disable:no-unnecessary-qualifier

    /**
     * 当前进程是否加载了 Objective-C 运行时。不要调用任何其他 ObjC 属性或
     * 方法，除非是这种情况。
     */
    常量 可用：布尔值；

    /**
     * 直接访问大部分 Objective-C 运行时 API。
     */
    常量 API：{
        [名称：字符串]：任何；
    } ;

    /**
     * 为每个当前注册的类动态生成绑定。
     *
     * 您可以通过使用点符号和用下划线替换冒号来与对象交互，即：
     *
     *```
     * [NSString stringWithString:@"Hello World"];
     *```
     *
     * 变为：
     *
     *```
     * 常量 NSString = ObjC.classes.NSString;
     * NSString.stringWithString_("Hello World");
     *```
     *
     * 注意方法名后面的下划线。
     */
    常量 类：{
        [名称：字符串]：ObjC 。目的
    } ;

    /**
     *为每个当前注册的协议动态生成绑定。
     */
    常量 协议：{
        [名称：字符串]：协议
    } ;

    /**
     * 主线程的 GCD 队列。
     */
    const  mainQueue : NativePointer ;

    /**
     * 在 `queue` 指定的 GCD 队列上调度 JavaScript 函数 `work`。创建了一个 NSAutoreleasePool
     * 就在调用 `work` 之前，并在返回时清理。
     *
     * 例如在 macOS 上：
     *```
     * 常量 { NSSound } = ObjC.classes;
     * ObjC.schedule(ObjC.mainQueue, () => {
     * const sound = NSSound.alloc().initWithContentsOfFile_byReference_("/Users/oleavr/.Trash/test.mp3", true).autorelease();
     * sound.play();
     * });
     *```
     *
     * @param queue GCD 队列以安排"工作"。
     * @param work 调用指定 `queue` 的函数。
     */
    函数 调度（队列：NativePointerValue ， 工作：（） =>  void）：void；

    /**
     * 为任何 Objective-C 实例、类或元类动态生成的包装器。
     */
    类 对象 实现 ObjectWrapper ， ObjectMethods  {
        构造函数（句柄：NativePointer ， 协议？：协议）；

        句柄：NativePointer ；

        /**
         * 这是一个实例、类还是元类。
         */
        $种类：对象种类；

        /**
         * 用于链接到超类方法实现的实例。
         */
        $super :对象。对象；

        /**
         * 此对象类的超类。
         */
        $superClass :对象。对象；

        /**
         * 该对象是其实例的类。
         */
        $类：对象。对象；

        /**
         * 此对象的类名。
         */
        $className :字符串；

        /**
         * 实现此对象的模块名称。
         */
        $模块名称：字符串；

        /**
         * 此对象符合的协议。
         */
        $协议：{
            [名称：字符串]：协议；
        } ;

        /**
         * 此对象的类和父类公开的本机方法名称。
         */
        $方法：字符串[ ] ；

        /**
         * 此对象的类公开的本机方法名称，不包括父类。
         */
        $ownMethods :字符串[ ] ;

        /**
         * 此对象上的实例变量。支持访问和分配。
         */
        $变量：{
            [名称：字符串]：任何；
        } ;

        /**
         * 确定两个实例是否引用同一个底层对象。
         *
         * @param other 要比较的其他对象实例或地址。
         */
        等于（其他：ObjC.Object | NativePointer  ）：布尔值；_ 

        [名称：字符串]：任何；
    }

    接口 对象方法 {
        [名称：字符串]：对象方法；
    }

    接口 ObjectMethod 扩展 ObjectWrapper ， AnyFunction  {
        句柄：NativePointer ；

        /**
         * Objective-C 选择器。使用 `ObjC.selectorAsString()` 将其转换为字符串。
         */
        选择器：本地指针；

        /**
         * 当前的实施。
         *
         * 您可以通过分配给该属性来替换它。有关详细信息，请参阅`ObjC.implement()`。
         */
        实现：NativePointer ；

        /**
         * 返回类型名称。
         */
        返回类型：字符串；

        /**
         * 参数类型名称。
         */
        参数类型：字符串[ ] ；

        /**
         * 签名。
         */
        类型：字符串；

        /**
         * 使用自定义 NativeFunction 选项创建一个新的方法包装器。
         *
         * 对例如设置 `traps: "all"` 来执行执行跟踪很有用
         * 与潜行者一起使用。
         */
        克隆：（选项： NativeFunctionOptions ）= > ObjectMethod ；  
    }

    /**
     * ObjC.Object 代表什么样的对象。
     */
    类型 ObjectKind  =  "实例"  |  "类"  |  "元类" ；

    /**
     * 为任何 Objective-C 协议动态生成的语言绑定。
     */
    类 协议 实现 ObjectWrapper  {
        构造函数（句柄：NativePointer ）；

        句柄：NativePointer ；

        /**
         * 名称对 Objective-C 运行时可见。
         */
        名称：字符串；

        /**
         * 此协议符合的协议。
         */
        协议：{
            [名称：字符串]：协议
        } ;

        /**
         * 此协议声明的属性。
         */
        属性：{
            [名称：字符串]：协议属性属性；
        } ;

        /**
         * 此协议声明的方法。
         */
        方法：{
            [名称：字符串]：协议方法描述；
        } ;
    }

    接口 协议属性属性 {
        [名称：字符串]：字符串；
    }

    接口 协议方法描述 {
        /**
         * 此方法是必需的还是可选的。
         */
        必需：布尔值；

        /**
         * 方法签名。
         */
        类型：字符串；
    }

    /**
     * 为任何 Objective-C 块动态生成的语言绑定。
     *
     * 还支持通过传入一个从头开始实现一个块
     * 执行。
     */
    类 块 实现 ObjectWrapper  {
        构造函数（目标：NativePointer  |  MethodSpec < BlockImplementation > ， 选项？：NativeFunctionOptions ）；

        句柄：NativePointer ；

        /**
         * 签名，如果有的话。
         */
        类型?:字符串 |  未定义；

        /**
         * 当前的实施。您可以通过分配给此属性来替换它。
         */
        实现：AnyFunction ；

        /**
         * 声明外部定义块的签名。这是需要的
         * 当使用没有签名元数据的块时，即当
         * `block.types === 未定义`。
         *
         * @param signature 要使用的签名。
         */
        声明（签名：BlockSignature ）：无效；
    }

    类型 BlockImplementation  =  ( this : Block , ... args : any [ ] )  =>  any ;

    类型 BlockSignature  =  SimpleBlockSignature  |  详细的区块签名；

    接口 SimpleBlockSignature  {
        /**
         * 返回类型。
         */
        retType：字符串；

        /**
         * 参数类型。
         */
        argTypes :字符串[ ] ;
    }

    接口 详细块签名 {
        /**
         * 签名。
         */
        类型：字符串；
    }

    /**
     * 创建一个与 `method` 签名兼容的 JavaScript 实现，其中 `fn` 用作
     * 执行。返回一个可以分配给 ObjC 方法的 `implementation` 属性的 `NativeCallback`。
     *
     * @param method 要实现的方法。
     * @param fn 实现。
     */
    函数 实现（方法：ObjectMethod ， fn：AnyFunction ）：NativeCallback <任意， 任意> ；

    /**
     * 创建一个新类，旨在充当目标对象的代理。
     *
     * @param spec 代理规范。
     */
    函数 registerProxy ( spec : ProxySpec ) : ProxyConstructor ;

    /**
     * 创建一个新的 Objective-C 类。
     *
     * @param spec 类规范。
     */
    函数 registerClass （规范：ClassSpec ）：ObjC 。对象；

    /**
     * 创建一个新的 Objective-C 协议。
     *
     * @param spec 协议规范。
     */
    函数 registerProtocol ( spec : ProtocolSpec ) :协议；

    /**
     * 将一些 JavaScript 数据绑定到一个 Objective-C 实例。
     *
     * @param obj Objective-C 实例绑定数据。
     * @param data 要绑定的数据。
     */
    函数 绑定（obj：ObjC.Object | NativePointer  ，数据：InstanceData ）：void；_  _ 

    /**
     * 从一个 Objective-C 实例中取消绑定以前关联的 JavaScript 数据。
     *
     * @param obj Objective-C 实例来取消绑定数据。
     */
    函数 解除绑定（obj：ObjC.Object | NativePointer  ）：void；_ 

    /**
     * 从 Objective-C 对象中查找先前绑定的数据。
     *
     * @param obj Objective-C 实例来查找数据。
     */
    函数 getBoundData （obj：ObjC.Object | NativePointer  ）：任何；_  _

    /**
     * 枚举加载的类。
     *
     * @param callbacks 带有回调的对象。
     */
    函数 enumerateLoadedClasses （回调：EnumerateLoadedClassesCallbacks ）：无效；

    /**
     * 枚举加载的类。
     *
     * @param options 自定义枚举的选项。
     * @param callbacks 带有回调的对象。
     */
    函数 enumerateLoadedClasses （选项：EnumerateLoadedClassesOptions ， 回调：EnumerateLoadedClassesCallbacks ）：void；

    /**
     * `enumerateLoadedClasses()` 的同步版本。
     *
     * @param options 自定义枚举的选项。
     */
    函数 enumerateLoadedClassesSync （选项？：EnumerateLoadedClassesOptions ）：EnumerateLoadedClassesResult ；

    接口 EnumerateLoadedClassesOptions  {
        /**
         * 将枚举限制为给定模块映射中的模块。
         */
        拥有 者？：ModuleMap |  未定义；
    }

    接口 EnumerateLoadedClassesCallbacks  {
        onMatch：（名称：字符串，所有者：字符串） = > void；   
        onComplete : ( )  => 无效；
    }

    接口 EnumerateLoadedClassesResult  {
        /**
         * 类名按所有者模块的名称分组。
         */
        [所有者：字符串]：字符串[ ] ；
    }

    函数 选择（说明符：ChooseSpecifier ， 回调：EnumerateCallbacks < ObjC.Object > ）：无效；_

    /**
     * `choose()` 的同步版本。
     *
     * @param说明符要寻找什么样的对象。
     */
    函数选择同步 （说明符：选择说明符）：ObjC 。对象[ ] ;

    /**
     * 将 JavaScript 字符串 `name` 转换为选择器。
     *
     * @param name 名称变成一个选择器。
     */
    函数 选择器（名称：字符串）：NativePointer ；

    /**
     * 将选择器 `sel` 转换为 JavaScript 字符串。
     *
     * @param sel 选择器变成一个字符串。
     */
    函数 selectorAsString ( sel : NativePointerValue ) :字符串；

    接口 ProxySpec < D 扩展 ProxyData  =  ProxyData ， T  =  ObjC 。对象， S  =  ObjC 。对象>  {
        /**
         * 代理类的名称。
         *
         * 如果您不关心全局可见名称并希望运行时自动生成一个，请忽略此选项
         * 为你。
         */
        名称？：字符串 |  未定义；

        /**
         * 此代理类符合的协议。
         */
        协议？：协议[ ]  |  未定义；

        /**
         * 实施方法。
         */
        方法？：{
            [名称:字符串] : UserMethodImplementation < D ,  T ,  S >  |  MethodSpec < UserMethodImplementation < D ,  T ,  S >> ; _
        }  |  未定义；

        /**
         * 用于获取事件通知的回调。
         */
        事件？：ProxyEventCallbacks < D ， T ， S >  |  未定义；
    }

    接口 ProxyEventCallbacks < D ,  T ,  S >  {
        /**
         * 在对象被释放后立即得到通知。
         *
         * 这是您可以清理任何关联状态的地方。
         */
        解除分配？（这：UserMethodInvocation < D ， T ， S > ）：无效；

        /**
         * 获取有关我们将要转发的方法名称的通知
         * 来电。
         *
         * 这可能是您从临时回调开始的地方
         * 只记录名称以帮助您决定使用哪些方法
         * 覆盖。
         *
         * @param name 即将被调用的方法的名称。
         */
        前进？（本：UserMethodInvocation < D ,  T ,  S > ， 名称：字符串）：无效；
    }

    /**
     * 用于实例化代理对象的构造函数。
     *
     * @param target 要代理的目标对象。
     * @param data 具有任意数据的对象。
     */
    接口 代理构造器 {
        新的 （目标：ObjC 。对象 |  NativePointer ， 数据？：InstanceData ）：ProxyInstance ；
    }

    接口 代理实例 {
        句柄：NativePointer ；
    }

    接口 ProxyData 扩展 InstanceData  {
        /**
         * 此代理的目标对象。
         */
        目标：ObjC 。对象；

        /**
         * 由实现使用。
         */
        事件：{ } ；
    }

    接口 ClassSpec < D  =  InstanceData ,  T  =  ObjC 。对象， S  =  ObjC 。对象>  {
        /**
         * 班级名称。
         *
         * 如果您不关心全局可见名称并希望运行时自动生成一个，请忽略此选项
         * 为你。
         */
        名称？：字符串 |  未定义；

        /**
         * 超类，或 `null` 来创建一个新的根类。省略从 `NSObject` 继承。
         */
        超级？：ObjC 。对象 |  空 |  未定义；

        /**
         * 此类符合的协议。
         */
        协议？：协议[ ]  |  未定义；

        /**
         * 实施方法。
         */
        方法？：{
            [名称:字符串] : UserMethodImplementation < D ,  T ,  S >  |  MethodSpec < UserMethodImplementation < D ,  T ,  S >> ; _
        }  |  未定义；
    }

    type  MethodSpec < I >  =  SimpleMethodSpec < I >  |  详细方法规范< I > ；

    接口 SimpleMethodSpec < I >  {
        /**
         * 返回类型。
         */
        retType：字符串；

        /**
         * 参数类型。
         */
        argTypes :字符串[ ] ;

        /**
         * 执行。
         */
        执行：我；
    }

    接口 详细方法规范< I >  {
        /**
         * 签名。
         */
        类型：字符串；

        /**
         * 执行。
         */
        执行：我；
    }

    type  UserMethodImplementation < D ,  T ,  S >  =  ( this : UserMethodInvocation < D ,  T ,  S > , ... args : any [ ] )  =>  any ;

    接口 UserMethodInvocation < D ,  T ,  S >  {
        自我：T ；
        超级：S ；
        数据：D ；
    }

    /**
     * 可以从方法实现访问的用户定义数据。
     */
    接口 实例数据 {
        [名称：字符串]：任何；
    }

    接口 协议规范 {
        /**
         * 协议名称。
         *
         * 如果您不关心全局可见名称并希望运行时自动生成一个，请忽略此选项
         * 为你。
         */
        名称？：字符串 |  未定义；

        /**
         * 此协议符合的协议。
         */
        协议？：协议[ ]  |  未定义；

        方法？：{
            [名称：字符串]：协议方法规范；
        }  |  未定义；
    }

    类型 ProtocolMethodSpec  =  SimpleProtocolMethodSpec  |  详细协议方法规范；

    接口 SimpleProtocolMethodSpec  {
        /**
         * 返回类型。
         */
        retType：字符串；

        /**
         * 参数类型。
         */
        argTypes :字符串[ ] ;

        /**
         * 此方法是必需的还是可选的。默认为必填项。
         */
        可选？：布尔值 |  未定义；
    }

    接口 详细协议方法规范 {
        /**
         * 方法签名。
         */
        类型：字符串；

        /**
         * 此方法是必需的还是可选的。默认为必填项。
         */
        可选？：布尔值 |  未定义；
    }

    类型 ChooseSpecifier  =  SimpleChooseSpecifier  |  详细选择说明符；

    类型 SimpleChooseSpecifier  =  ObjC 。对象；

    接口 详细选择说明符 {
        /**
         * 查找哪个类的实例。例如：`ObjC.classes.UIButton`。
         */
        类：ObjC 。对象；

        /**
         * 您是否也对匹配给定类选择器的子类感兴趣。
         *
         * 默认情况下还包括子类。
         */
        子类？：布尔值 |  未定义；
    }

    // tslint:enable:no-unnecessary-qualifier
}

声明 命名空间 Java  {
    /**
     * 当前进程是否加载了 Java 运行时。不要调用任何其他 Java 属性或
     * 方法，除非是这种情况。
     */
    常量 可用：布尔值；

    /**
     * 我们运行的是哪个版本的 Android。
     */
    常量 androidVersion :字符串；

    /**
     * 在持有 `obj` 锁的情况下调用 `func`。
     *
     * @param obj 要持有其锁的实例。
     * @param fn 在持有锁的情况下调用的函数。
     */
    函数 同步（obj：包装器， fn：（） =>  void）：void；

    /**
     * 枚举加载的类。
     *
     * @param callbacks 带有回调的对象。
     */
    函数 enumerateLoadedClasses （回调：EnumerateLoadedClassesCallbacks ）：无效；

    /**
     * `enumerateLoadedClasses()` 的同步版本。
     */
    函数 enumerateLoadedClassesSync ( ) : string [ ] ;

    /**
     * 枚举类加载器。
     *
     * 你可以将这样的加载器传递给 `Java.ClassFactory.get()` 以便能够
     * `.use()` 指定类加载器上的类。
     *
     * @param callbacks 带有回调的对象。
     */
    函数 enumerateClassLoaders （回调：EnumerateClassLoadersCallbacks ）：无效；

    /**
     * `enumerateClassLoaders()` 的同步版本。
     */
    函数 enumerateClassLoadersSync ( ) : Wrapper [ ] ;

    /**
     * 枚举匹配`query`的方法。
     *
     * @param query 指定为 `class!method` 的查询，允许使用 glob。可能
     * 也可以使用 `/` 和一个或多个修饰符作为后缀：
     * - `i`：不区分大小写的匹配。
     * - `s`: 包括方法签名，所以例如`"putInt"`变成
     * `"putInt(java.lang.String, int): void"`。
     * - `u`：仅用户定义的类，忽略系统类。
     */
    函数 enumerateMethods （查询：字符串）：EnumerateMethodsMatchGroup [ ] ；

    /**
     * 在 VM 的主线程上运行 `fn`。
     *
     * @param fn 在虚拟机主线程上运行的函数。
     */
    函数 scheduleOnMainThread ( fn : ( )  =>  void ) : void ;

    /**
     * 确保当前线程附加到 VM 并调用 `fn`。
     *（这在来自 Java 的回调中不是必需的。）
     *
     * 如果应用程序的类加载器尚不可用，将推迟调用 `fn`。
     * 如果不需要访问应用程序的类，请使用 `Java.performNow()`。
     *
     * @param fn 连接到 VM 时运行的函数。
     */
    函数 执行（fn：（） =>  void）：void；

    /**
     * 确保当前线程附加到 VM 并调用 `fn`。
     *（这在来自 Java 的回调中不是必需的。）
     *
     * @param fn 连接到 VM 时运行的函数。
     */
    函数 performNow ( fn : ( )  =>  void ) : void ;

    /**
     * 为 `className` 动态生成一个 JavaScript 包装器，你可以
     * 通过调用 `$new()` 来实例化对象以调用构造函数。
     * 在实例上调用 `$dispose()` 以显式清理它，或者等待
     * 要进行垃圾收集的 JavaScript 对象，或要获取的脚本
     * 卸载。静态和非静态方法可用，你甚至可以
     * 替换方法实现。
     *
     * 使用应用程序的类加载器，但您可以访问其他加载器上的类
     * 通过调用`Java.ClassFactory.get()`。
     *
     * @param className 获取包装器的规范类名。
     */
    函数 使用< T 扩展 成员< T >  =  { } > ( className : string ) : Wrapper < T > ;

    /**
     * 在 `filePath` 打开 .dex 文件。
     *
     * @param filePath 要打开的 .dex 路径。
     */
    函数 openClassFile ( filePath : string ) : DexFile ;

    /**
     * 通过扫描 Java 枚举 `className` 类的实时实例
     * VM 的堆。
     *
     * @param className 要枚举其实例的类的名称。
     * @param callbacks 带有回调的对象。
     */
    函数 选择（类名：字符串，回调：ChooseCallbacks ）：无效； 

    /**
     * 复制一个 JavaScript 包装器，供以后在外部替换方法中使用。
     *
     * @param obj 在替换方法中从 `this` 检索到的现有包装器。
     */
    function  retain < T  extends  Members < T >  =  { } > ( obj : Wrapper < T > ) : Wrapper < T > ;

    /**
     * 在 `handle` 处给定现有实例，创建一个 JavaScript 包装器
     * 给定类 `klass` 从 `Java.use()` 返回。
     *
     * @param handle 一个现有的包装器或 JNI 句柄。
     * @param klass 要转换为的类型的类包装器。
     */
    函数 cast < From  extends  Members < From >  =  { } ,  To  extends  Members < To >  =  { } > (
        句柄：包装器<来自>  |  本机指针值，
        类：包装器<到>
    ) :包装< To > ;

    /**
     * 创建一个包含指定"类型"元素的 Java 数组，从
     * JavaScript 数组`元素`。生成的 Java 数组的行为类似于
     * 一个 JS 数组，但可以通过引用 Java API 来传递，以便
     * 允许他们修改其内容。
     *
     * @param type 元素的类型名称。
     * @param elements 用于构造的 JavaScript 值数组
     * Java 数组。
     */
    函数 数组（类型：字符串， 元素：任意[ ] ）：任意[ ] ；

    /**
     * 为当前线程生成回溯。
     *
     * @param options 自定义堆栈遍历的选项。
     */
    功能 回溯（选项？：BacktraceOptions ）：回溯；

    /**
     * 判断调用者是否在主线程上运行。
     */
    函数 isMainThread ( ) : boolean ;

    /**
     * 创建一个新的 Java 类。
     *
     * @param spec 描述要创建的类的对象。
     */
    function  registerClass ( spec : ClassSpec ) : Wrapper ;

    /**
     * 强制 VM 使用其解释器执行所有操作。有必要
     * 在某些情况下防止优化绕过方法挂钩，并且
     * 允许使用 ART 的 Instrumentation API 来跟踪运行时。
     */
    函数 deoptimizeEverything ( ) : void ;

    /**
     * 与 deoptimizeEverything 类似，但仅对启动映像代码进行反优化。
     * 最好与 `dalvik.vm.dex2oat-flags --inline-max-code-units=0` 一起使用
     * 结果。
     */
    函数 deoptimizeBootImage ( ) : void ;

    常量 虚拟机：虚拟机；

    /**
     * 用于实现例如 `Java.use()` 的默认类工厂。
     * 使用应用程序的主类加载器。
     */
    常量 类工厂：类工厂；

    接口 EnumerateLoadedClassesCallbacks  {
        /**
         * 使用每个当前加载的类的名称和一个 JNI 调用
         * 对其 Java 类对象的引用。
         *
         * 将 `name` 传递给 `Java.use()` 以获取 JavaScript 包装器。
         * 你也可以通过 `Java.cast()` 将 `handle` 转换为 `java.lang.Class`。
         */
        onMatch : (名称:字符串, 句柄: NativePointer )  =>  void ;

        /**
         * 枚举所有加载的类时调用。
         */
        onComplete : ( )  => 无效；
    }

    接口 EnumerateClassLoadersCallbacks  {
        /**
         * 使用每个类加载器的 `java.lang.ClassLoader` 包装器调用
         * 在虚拟机中找到。
         */
        onMatch : ( loader : Wrapper )  =>  void ;

        /**
         * 枚举所有类加载器时调用。
         */
        onComplete : ( )  => 无效；
    }

    /**
     * 按类加载器分组的匹配方法。
     */
    接口 EnumerateMethodsMatchGroup  {
        /**
         * 类加载器，或 `null` 用于引导类加载器。
         *
         * 通常传递给 `ClassFactory.get()` 以与
         * 兴趣。
         */
        加载器：包装器 |  空；

        /**
         * 一个或多个匹配的类有一个或多个方法匹配
         * 给定的查询。
         */
        类：[ EnumerateMethodsMatchClass ， ... EnumerateMethodsMatchClass [ ] ] ；
    }

    /**
     * 具有一种或多种匹配方法的类匹配查询。
     */
    接口 EnumerateMethodsMatchClass  {
        /**
         * 匹配给定查询的类名。
         */
        名称：字符串；

        /**
         * 一个或多个匹配的方法名，每个后跟签名时
         * 使用了 `s` 修饰符。
         */
        方法：[字符串， ...字符串[ ] ] ；
    }

    接口 ChooseCallbacks < T  extends  Members < T >  =  { } >  {
        /**
         * 调用每个使用现成的"实例"找到的实时实例
         * 就好像你会用一个原始句柄调用 `Java.cast()`
         * 这个特定的实例。
         *
         * 可能返回 `EnumerateAction.Stop` 以提前停止枚举。
         */
        onMatch : (实例: Wrapper < T > )  =>  void  |  枚举动作；

        /**
         * 枚举所有实例时调用。
         */
        onComplete : ( )  => 无效；
    }

    /**
     * 可以传递给 `Java.backtrace()` 的选项。
     */
    接口 BacktraceOptions  {
        /**
         * 限制在堆栈上走多少帧。默认为 16。
         */
        限制？：数量；
    }

    /**
     * `Java.backtrace()` 返回的回溯。
     */
    接口 回溯 {
        /**
         * 可用于对相同回溯进行重复数据删除的 ID。
         */
        id：字符串；

        /**
         * 堆栈帧。
         */
        帧：帧[ ] ；
    }

    界面 框架 {
        /**
         * 签名，例如`"Landroid/os/Looper;,loopOnce,(Landroid/os/Looper;JI)Z"`。
         */
        签名：字符串；

        /**
         * 方法所属的类名，例如`"android.os.Looper"`。
         */
        类名：字符串；

        /**
         * 方法名，例如`"loopOnce"`。
         */
        方法名：字符串；

        /**
         * 源文件名，例如`"Looper.java"`。
         */
        文件名：字符串；

        /**
         * 源行号，例如 `201`。
         */
        线号：数字；
    }

    类型 成员< T >  = 记录< keyof  T ,  MethodDispatcher  |  字段> ;

    /**
     * 为任何 Java 类、实例或接口动态生成的包装器。
     */
    type  Wrapper < T  extends  Members < T >  =  { } >  =  {
        /**
         * 自动将持有人的类型注入所有字段和方法
         */
        [ K  in  keyof  T ]：T [ K ] 扩展 字段<推断值>？字段<值， T >：MethodDispatcher < T >
    }  &  {
        /**
         * 分配并初始化给定类的新实例。
         *
         * 使用它来创建一个新实例。
         */
        $new : MethodDispatcher < T > ;

        /**
         * 分配一个新实例而不初始化它。
         *
         * 调用 `$init()` 来初始化它。
         */
        $alloc : MethodDispatcher < T > ;

        /**
         * 初始化一个已分配但尚未初始化的实例。
         * 这包装了构造函数。
         *
         * 替换 `implementation` 属性以挂钩给定的构造函数。
         */
        $init : MethodDispatcher < T > ;

        /**
         * 急切地删除底层 JNI 全局引用，而不必
         * 等待对象变得不可访问和 JavaScript
         * 运行时的垃圾收集器启动（或脚本被卸载）。
         *
         * 在循环中创建大量短期对象时很有用，并且
         * 存在全局句柄用完的风险。
         */
        $dispose ( ) :无效;

        /**
         * 检索当前类的 `java.lang.Class` 包装器。
         */
        类：包装器；

        /**
         * 被包装的类的规范名称。
         */
        $className :字符串；

        /**
         * 此对象的类公开的方法和字段名称，不包括
         * 父类。
         */
        $ownMembers :字符串[ ] ;

        /**
         * 用于链接到超类方法实现的实例。
         */
        $super :包装器；

        /**
         * 方法和字段。
         */
        [名称：字符串]：任何；
    } ;

    接口 MethodDispatcher < Holder 扩展 成员< Holder >  =  { } > 扩展 方法< Holder >  {
        /**
         * 可用的重载。
         */
        重载：数组<方法<持有者>> ；_

        /**
         * 获得特定的重载。
         *
         * @param args 要获取的重载签名。
         * 例如：`"java.lang.String"、"int"`。
         */
        重载（ ... args：字符串[ ] ）：方法< Holder > ；
    }

    接口 方法< Holder  extends  Members < Holder >  =  { } >  {
        （ ...参数：任何[ ] ）：任何；

        /**
         * 此方法的名称。
         */
        方法名：字符串；

        /**
         * 该方法所属的类。
         */
        持有人：包装<持有人> ;

        /**
         * 这是一种什么样的方法，即构造函数 vs 静态 vs 实例。
         */
        类型：方法类型；

        /**
         * 指向虚拟机底层方法对象的指针。
         */
        句柄：NativePointer ；

        /**
         * 执行。为这个属性分配一个新的实现
         * 替换原来的实现。在将来的某个时刻分配"null"
         * 恢复到原来的实现。
         */
        实现: MethodImplementation < Holder >  |  空；

        /**
         * 方法返回类型。
         */
        返回类型：类型；

        /**
         * 方法参数类型。
         */
        argumentTypes :类型[ ] ;

        /**
         * 查询是否可以使用给定的参数列表调用该方法。
         */
        canInvokeWith : ( ... args : any [ ] )  =>  boolean ;

        /**
         * 使用自定义 NativeFunction 选项创建一个新的方法包装器。
         *
         * 对例如设置 `traps: "all"` 来执行执行跟踪很有用
         * 与潜行者一起使用。
         */
        克隆：（选项： NativeFunctionOptions ）= >方法<持有者> ；  
    }

    type  MethodImplementation < This  extends  Members < This >  =  { } >  =  ( this : Wrapper < This > , ... params : any [ ] )  =>  any ;

    interface  Field < Value  =  any ,  Holder  extends  Members < Holder >  =  { } >  {
        /**
         * 该字段的当前值。分配以更新字段的值。
         */
        价值：价值；

        /**
         * 该字段所属的类。
         */
        持有人：包装<持有人> ;

        /**
         * 这是什么类型的字段，即静态与实例。
         */
        字段类型：字段类型；

        /**
         * 值的类型。
         */
        fieldReturnType：类型；
    }

    // eslint-disable-next-line no-const-enum
    常量 枚举 方法类型 {
        构造函数 =  1 ,
        静态 =  2 ,
        实例 =  3 ,
    }

    // eslint-disable-next-line no-const-enum
    常量 枚举 字段类型 {
        静态 =  1 ,
        实例 =  2 ,
    }

    接口 类型 {
        /**
         * 虚拟机类型名称。例如 `I` 代表 `int`。
         */
        名称：字符串；

        /**
         * Frida 类型名称。例如句柄的"指针"。
         */
        类型：字符串；

        /**
         * 字数。
         */
        大小：数字；

        /**
         * 大小以字节为单位。
         */
        字节大小：数字；

        /**
         * 班级名称（如果适用）。
         */
        类名？：字符串 |  未定义；

        /**
         * 检查给定的 JavaScript `value` 是否兼容。
         */
        isCompatible : ( value : any )  =>  boolean ;

        /**
         * 将 `value` 从 JNI 值转换为 JavaScript 值。
         */
        fromJni ?: ( (值: any )  =>  any )  |  未定义；

        /**
         * 将 `value` 从 JavaScript 值转换为 JNI 值。
         */
        toJni ?: ( (值: any )  =>  any )  |  未定义；

        /**
         * 从内存中读取一个值。
         */
        读？：（（地址：NativePointerValue ） => 任何） |  未定义；

        /**
         * 将值写入内存。
         */
        写？：（（地址：NativePointerValue ， 值：任何） =>  void） |  未定义；
    }

    接口 DexFile  {
        /**
         * 将包含的类加载到 VM 中。
         */
        加载（）：无效；

        /**
         * 确定可用的类名。
         */
        getClassNames ( ) :字符串[ ] ;
    }

    接口 类规范 {
        /**
         * 班级名称。
         */
        名称：字符串；

        /**
         * 超一流。省略从 `java.lang.Object` 继承。
         */
        superClass ?:包装器 |  未定义；

        /**
         * 此类实现的接口。
         */
        实现?: Wrapper [ ]  |  未定义；

        /**
         * 要公开的每个字段的名称和类型。
         */
        字段？：{
            [名称：字符串]：字符串；
        }  |  未定义；

        /**
         * 实施方法。使用特殊名称 `$init` 来定义一个或多个构造函数。
         */
        方法？：{
            [名称：字符串]：方法实现 |  方法规范 |  方法规范[ ] ;
        }  |  未定义；
    }

    接口 方法规范 {
        /**
         * 返回类型。如果省略，则默认为 `void`。
         */
        返回类型?:字符串 |  未定义；

        /**
         * 参数类型。如果省略，则默认为 `[]`。
         */
        参数类型?:字符串[ ]  |  未定义；

        /**
         * 执行。
         */
        实施：方法实施；
    }

    接口 虚拟机 {
        /**
         * 确保当前线程附加到 VM 并调用 `fn`。
         *（这在来自 Java 的回调中不是必需的。）
         *
         * @param fn 连接到 VM 时运行的函数。
         */
        执行（fn：（） =>  void）：void；

        /**
         * 获取当前线程的 `JNIEnv` 的包装器。
         *
         * 如果当前线程未附加到 VM，则引发异常。
         */
        获取环境（）：环境；

        /**
         * 尝试获取当前线程的 `JNIEnv` 的包装器。
         *
         * 如果当前线程未附加到 VM，则返回 `null`。
         */
        tryGetEnv ( ) :环境 |  空；
    }

    类型 环境 = 任何；

    类类 工厂 {
        /**
         * 获取给定类加载器的类工厂实例，或者
         * 传递 `null` 时的默认工厂。
         *
         * 后台使用的默认类工厂只进行交互
         * 使用应用程序的主类加载器。其他类加载器
         * 可以通过 API 发现，例如 `Java.enumerateMethods()` 和
         * `Java.enumerateClassLoaders()`，随后与
         * 通过这个 API。
         */
        静态 获取（类加载器：包装器 | 空）：类工厂；

        /**
         * 当前正在使用的类加载器。对于默认的类工厂，这
         * 由第一次调用 `Java.perform()` 更新。
         */
        只读 加载器：包装器 |  空；

        /**
         * 当前使用的缓存目录的路径。对于默认类
         * 工厂通过第一次调用 `Java.perform()` 来更新。
         */
        缓存目录：字符串；

        /**
         * 用于临时文件的命名约定。
         *
         * 默认为`{前缀："frida"，后缀："dat"}`。
         */
        临时文件命名：临时文件命名；

        /**
         * 为 `className` 动态生成一个 JavaScript 包装器，你可以
         * 通过调用 `$new()` 来实例化对象以调用构造函数。
         * 在实例上调用 `$dispose()` 以显式清理它，或者等待
         * 要进行垃圾收集的 JavaScript 对象，或要获取的脚本
         * 卸载。静态和非静态方法可用，你甚至可以
         * 替换方法实现。
         *
         * @param className 获取包装器的规范类名。
         */
        使用< T 扩展 成员< T >  =  { } > （类名：字符串）：包装器< T > ；

        /**
         * 在 `filePath` 打开 .dex 文件。
         *
         * @param filePath 要打开的 .dex 路径。
         */
        openClassFile ( filePath : string ) : DexFile ;

        /**
         * 通过扫描 Java 枚举 `className` 类的实时实例
         * VM 的堆。
         *
         * @param className 要枚举其实例的类的名称。
         * @param callbacks 带有回调的对象。
         */
        选择（类名：字符串，回调：ChooseCallbacks ）：无效； 

        /**
         * 复制一个 JavaScript 包装器，供以后在外部替换方法中使用。
         *
         * @param obj 在替换方法中从 `this` 检索到的现有包装器。
         */
        保留< T 扩展 成员< T >  =  { } > ( obj : Wrapper < T > ) : Wrapper < T > ;

        /**
         * 在 `handle` 处给定现有实例，创建一个 JavaScript 包装器
         * 给定类 `klass` 从 `Java.use()` 返回。
         *
         * @param handle 一个现有的包装器或 JNI 句柄。
         * @param klass 要转换为的类型的类包装器。
         */
        cast < From  extends  Members < From >  =  { } ,  To  extends  Members < To >  =  { } > (
            句柄：包装器<来自>  |  本机指针值，
            类：包装器<到>
        ) :包装< To > ;

        /**
         * 创建一个包含指定"类型"元素的 Java 数组，从
         * JavaScript 数组`元素`。生成的 Java 数组的行为类似于
         * 一个 JS 数组，但可以通过引用 Java API 来传递，以便
         * 允许他们修改其内容。
         *
         * @param type 元素的类型名称。
         * @param elements 用于构造的 JavaScript 值数组
         * Java 数组。
         */
        数组（类型：字符串， 元素：任意[ ] ）：任意[ ] ；

        /**
         * 创建一个新的 Java 类。
         *
         * @param spec 描述要创建的类的对象。
         */
        registerClass （规范：ClassSpec ）：包装器；
    }

    接口 TempFileNaming  {
        /**
         * 要使用的文件名前缀。
         *
         * 例如：`frida`。
         */
        前缀：字符串；

        /**
         * 要使用的文件名后缀。
         *
         * 例如：`dat`。
         */
        后缀：字符串；
    }
}

/**
* 为 x86 生成机器码。
*/
声明 类 X86Writer  {
    /**
     * 创建用于生成 x86 机器码的新代码编写器
     * 在 `codeAddress` 处直接写入内存。
     *
     * @param codeAddress 将生成的代码写入的内存地址。
     * @param options 用于自定义代码生成的选项。
     */
    构造函数（codeAddress：NativePointerValue ， 选项？：X86WriterOptions ）；

    /**
     * 回收实例。
     */
    重置（代码地址：NativePointerValue ，选项？：X86WriterOptions ）：无效； 

    /**
     *急切地清理内存。
     */
    处置（）：无效；

    /**
     * 解决标签引用并将待处理数据写入内存。你
     * 应始终在您完成生成代码后调用它。它
     * 通常也希望在不相关的部分之间执行此操作
     * 代码，例如在一次生成多个函数时。
     */
    冲洗（）：无效；

    /**
     * 输出第一个字节的内存位置。
     */
    基：本地指针；

    /**
     * 下一个输出字节的内存位置。
     */
    代码：本地指针；

    /**
     * 程序计数器在输出的下一个字节。
     */
    个人计算机：本地指针；

    /**
     * 当前偏移量（以字节为单位）。
     */
    偏移量：数字；

    /**
     * 在当前位置放置一个标签，其中 `id` 是一个标识符
     * 可能在过去和将来的 `put*Label()` 调用中被引用。
     */
    putLabel （id：字符串）：无效；

    /**
     * 使用指定的 `args` 放置调用 C 函数所需的代码。
     */
    putCallAddressWithArguments （函数：NativePointerValue ， 参数：X86CallArgument [ ] ）：无效；

    /**
     * 像 `putCallWithArguments()` 一样，但也
     * 确保参数列表在 16 字节边界上对齐。
     */
    putCallAddressWithAlignedArguments （函数：NativePointerValue ， 参数：X86CallArgument [ ] ）：无效；

    /**
     * 使用指定的 `args` 放置调用 C 函数所需的代码。
     */
    putCallRegWithArguments （注册：X86Register ， 参数：X86CallArgument [ ] ）：无效；

    /**
     * 像 `putCallWithArguments()` 一样，但也
     * 确保参数列表在 16 字节边界上对齐。
     */
    putCallRegWithAlignedArguments （注册：X86Register ， 参数：X86CallArgument [ ] ）：无效；

    /**
     * 使用指定的 `args` 放置调用 C 函数所需的代码。
     */
    putCallRegOffsetPtrWithArguments （注册：X86Register ， 偏移：数字 |  Int64  |  UInt64 ， 参数：X86CallArgument [ ] ）：无效；

    /**
     * 放置一个 CALL 指令。
     */
    putCallAddress （地址：NativePointerValue ）：无效；

    /**
     * 放置一个 CALL 指令。
     */
    putCallReg （注册：X86Register ）：无效；

    /**
     * 放置一个 CALL 指令。
     */
    putCallRegOffsetPtr （注册：X86Register ， 偏移：数字 |  Int64  |  UInt64 ）：无效；

    /**
     * 放置一个 CALL 指令。
     */
    putCallIndirect （地址：NativePointerValue ）：无效；

    /**
     * 放置一个引用 `labelId` 的 CALL 指令，由过去定义
     * 或未来的 `putLabel()`。
     */
    putCallIndirectLabel （labelId：字符串）：无效；

    /**
     * 放置一个引用 `labelId` 的 CALL 指令，由过去定义
     * 或未来的 `putLabel()`。
     */
    putCallNearLabel （labelId：字符串）：无效；

    /**
     * 放置一个 LEAVE 指令。
     */
    putLeave ( ) :无效;

    /**
     * 放置一个 RET 指令。
     */
    putRet ( ) :无效;

    /**
     * 放置一个 RET 指令。
     */
    putRetImm ( immValue : number ) : void ;

    /**
     * 放置 JMP 指令。
     */
    putJmpAddress （地址：NativePointerValue ）：无效；

    /**
     * 放置一个引用`labelId`的JMP指令，由过去定义
     * 或未来的 `putLabel()`。
     */
    putJmpShortLabel （labelId：字符串）：无效；

    /**
     * 放置一个引用`labelId`的JMP指令，由过去定义
     * 或未来的 `putLabel()`。
     */
    putJmpNearLabel （labelId：字符串）：无效；

    /**
     * 放置 JMP 指令。
     */
    putJmpReg （注册：X86Register ）：无效；

    /**
     * 放置 JMP 指令。
     */
    putJmpRegPtr （注册：X86Register ）：无效；

    /**
     * 放置 JMP 指令。
     */
    putJmpRegOffsetPtr （注册：X86Register ， 偏移：数字 |  Int64  |  UInt64 ）：无效；

    /**
     * 放置 JMP 指令。
     */
    putJmpNearPtr （地址：NativePointerValue ）：无效；

    /**
     * 放置一条 JCC 指令。
     */
    putJccShort （指令ID ：X86InstructionId ， 目标：NativePointerValue ， 提示：X86BranchHint ）：无效；

    /**
     * 放置一条 JCC 指令。
     */
    putJccNear （指令ID ：X86InstructionId ， 目标：NativePointerValue ， 提示：X86BranchHint ）：无效；

    /**
     * 放置一个引用`labelId`的JCC指令，由过去定义
     * 或未来的 `putLabel()`。
     */
    putJccShortLabel （指令Id ：X86InstructionId ， labelId：字符串， 提示：X86BranchHint ）：无效；

    /**
     * 放置一个引用`labelId`的JCC指令，由过去定义
     * 或未来的 `putLabel()`。
     */
    putJccNearLabel （指令Id ：X86InstructionId ， labelId：字符串， 提示：X86BranchHint ）：无效；

    /**
     * 放置一个 ADD 指令。
     */
    putAddRegImm ( reg : X86Register ,  immValue : number  |  Int64  |  UInt64 ) : void ;

    /**
     * 放置一个 ADD 指令。
     */
    putAddRegReg （dstReg：X86Register ， srcReg：X86Register ）：无效；

    /**
     * 放置一个 ADD 指令。
     */
    putAddRegNearPtr （dstReg：X86Register ， srcAddress：NativePointerValue ）：无效；

    /**
     * 放置一个 SUB 指令。
     */
    putSubRegImm ( reg : X86Register ,  immValue : number  |  Int64  |  UInt64 ) : void ;

    /**
     * 放置一个 SUB 指令。
     */
    putSubRegReg （dstReg：X86Register ， srcReg：X86Register ）：无效；

    /**
     * 放置一个 SUB 指令。
     */
    putSubRegNearPtr （dstReg：X86Register ， srcAddress：NativePointerValue ）：无效；

    /**
     * 放置一条 INC 指令。
     */
    putIncReg （注册：X86Register ）：无效；

    /**
     * 放置一个 DEC 指令。
     */
    putDecReg （注册：X86Register ）：无效；

    /**
     * 放置一条 INC 指令。
     */
    putIncRegPtr （目标：X86PointerTarget ， 注册：X86Register ）：无效；

    /**
     * 放置一个 DEC 指令。
     */
    putDecRegPtr （目标：X86PointerTarget ， 注册：X86Register ）：无效；

    /**
     * 放置一个 LOCK XADD 指令。
     */
    putLockXaddRegPtrReg （dstReg：X86Register ， srcReg：X86Register ）：无效；

    /**
     * 放置一个 LOCK CMPXCHG 指令。
     */
    putLockCmpxchgRegPtrReg （dstReg：X86Register ， srcReg：X86Register ）：无效；

    /**
     * 放置一个 LOCK INC IMM32 指令。
     */
    putLockIncImm32Ptr （目标：NativePointerValue ）：无效；

    /**
     * 放置一个 LOCK DEC IMM32 指令。
     */
    putLockDecImm32Ptr （目标：NativePointerValue ）：无效；

    /**
     * 放置一个 AND 指令。
     */
    putAndRegReg （dstReg：X86Register ， srcReg：X86Register ）：无效；

    /**
     * 放置一个 AND 指令。
     */
    putAndRegU32 （注册：X86Register ， immValue：数字）：无效；

    /**
     * 放置一条 SHL 指令。
     */
    putShlRegU8 （注册：X86Register ， immValue：数字）：无效；

    /**
     * 放置 SHR 指令。
     */
    putShrRegU8 （注册：X86Register ， immValue：数字）：无效；

    /**
     * 放置一个 XOR 指令。
     */
    putXorRegReg （dstReg：X86Register ， srcReg：X86Register ）：无效；

    /**
     * 放置一条 MOV 指令。
     */
    putMovRegReg （dstReg：X86Register ， srcReg：X86Register ）：无效；

    /**
     * 放置一条 MOV 指令。
     */
    putMovRegU32 （dstReg：X86Register ， immValue：数字）：无效；

    /**
     * 放置一条 MOV 指令。
     */
    putMovRegU64 （dstReg：X86Register ， immValue：数字 |  UInt64 ）：无效；

    /**
     * 放置一条 MOV 指令。
     */
    putMovRegAddress （dstReg：X86Register ， 地址：NativePointerValue ）：无效；

    /**
     * 放置一条 MOV 指令。
     */
    putMovRegPtrU32 （dstReg：X86Register ， immValue：数字）：无效；

    /**
     * 放置一条 MOV 指令。
     */
    putMovRegOffsetPtrU32 ( dstReg : X86Register ,  dstOffset : number  |  Int64  |  UInt64 ,  immValue : number ) : void ;

    /**
     * 放置一条 MOV 指令。
     */
    putMovRegPtrReg （dstReg：X86Register ， srcReg：X86Register ）：无效；

    /**
     * 放置一条 MOV 指令。
     */
    putMovRegOffsetPtrReg ( dstReg : X86Register ,  dstOffset : number  |  Int64  |  UInt64 ,  srcReg : X86Register ) : void ;

    /**
     * 放置一条 MOV 指令。
     */
    putMovRegRegPtr （dstReg：X86Register ， srcReg：X86Register ）：无效；

    /**
     * 放置一条 MOV 指令。
     */
    putMovRegRegOffsetPtr ( dstReg : X86Register ,  srcReg : X86Register ,  srcOffset : number  |  Int64  |  UInt64 ) : void ;

    /**
     * 放置一条 MOV 指令。
     */
    putMovRegBaseIndexScaleOffsetPtr ( dstReg : X86Register ,  baseReg : X86Register ,  indexReg : X86Register ,  scale : number ,  offset : number  |  Int64  |  UInt64 ) : void ;

    /**
     * 放置一条 MOV 指令。
     */
    putMovRegNearPtr （dstReg：X86Register ， srcAddress：NativePointerValue ）：无效；

    /**
     * 放置一条 MOV 指令。
     */
    putMovNearPtrReg （dstAddress：NativePointerValue ， srcReg：X86Register ）：无效；

    /**
     * 放置一条 MOV FS 指令。
     */
    putMovFsU32PtrReg （fsOffset：数字， srcReg：X86Register ）：无效；

    /**
     * 放置一条 MOV FS 指令。
     */
    putMovRegFsU32Ptr （dstReg：X86Register ， fsOffset：数字）：无效；

    /**
     * 放置一条 MOV GS 指令。
     */
    putMovGsU32PtrReg （fsOffset：数字， srcReg：X86Register ）：无效；

    /**
     * 放置一条 MOV GS 指令。
     */
    putMovRegGsU32Ptr （dstReg：X86Register ， fsOffset：数字）：无效；

    /**
     * 放置一条 MOVQ XMM0 ESP 指令。
     */
    putMovqXmm0EspOffsetPtr （偏移量：数字）：无效；

    /**
     * 放置一条 MOVQ EAX XMM0 指令。
     */
    putMovqEaxOffsetPtrXmm0 （偏移量：数字）：无效；

    /**
     * 放置一条 MOVDQU XMM0 ESP 指令。
     */
    putMovdquXmm0EspOffsetPtr （偏移量：数字）：无效；

    /**
     * 放置一条 MOVDQU EAX XMM0 指令。
     */
    putMovdquEaxOffsetPtrXmm0 （偏移量：数字）：无效；

    /**
     * 放置 LEA 指令。
     */
    putLeaRegRegOffset ( dstReg : X86Register ,  srcReg : X86Register ,  srcOffset : number  |  Int64  |  UInt64 ) : void ;

    /**
     * 放置一条 XCHG 指令。
     */
    putXchgRegRegPtr （leftReg：X86Register ， rightReg：X86Register ）：无效；

    /**
     * 放置一个 PUSH 指令。
     */
    putPushU32 （immValue：数字）：无效；

    /**
     * 放置一个 PUSH 指令。
     */
    putPushNearPtr （地址：NativePointerValue ）：无效；

    /**
     * 放置一个 PUSH 指令。
     */
    putPushReg （注册：X86Register ）：无效；

    /**
     * 放置 POP 指令。
     */
    putPopReg （注册：X86Register ）：无效；

    /**
     * 放置一个 PUSH 指令。
     */
    putPushImmPtr ( immPtr : NativePointerValue ) :无效;

    /**
     * 放置一个 PUSHAX 指令。
     */
    putPushax ( ) :无效;

    /**
     * 放置一个 POPAX 指令。
     */
    putPopax ( ) :无效;

    /**
     * 放置一个 PUSHFX 指令。
     */
    putPushfx ( ) :无效;

    /**
     * 放置一个 POPFX 指令。
     */
    putPopfx ( ) :无效;

    /**
     * 放置一个 SAHF 指令。
     */
    putSahf ( ) :无效;

    /**
     * 放置一个 LAHF 指令。
     */
    putLahf ( ) :无效;

    /**
     * 放置一个 TEST 指令。
     */
    putTestRegReg （regA：X86Register ， regB：X86Register ）：无效；

    /**
     * 放置一个 TEST 指令。
     */
    putTestRegU32 （注册：X86Register ， immValue：数字）：无效；

    /**
     * 放置 CMP 指令。
     */
    putCmpRegI32 （注册：X86Register ， immValue：数字）：无效；

    /**
     * 放置 CMP 指令。
     */
    putCmpRegOffsetPtrReg （regA：X86Register ， 偏移量：数字 |  Int64  |  UInt64 ， regB：X86Register ）：无效；

    /**
     * 放置 CMP 指令。
     */
    putCmpImmPtrImmU32 （immPtr：NativePointerValue ， immValue：数字）：无效；

    /**
     * 放置 CMP 指令。
     */
    putCmpRegReg （regA：X86Register ， regB：X86Register ）：无效；

    /**
     * 放置一条 CLC 指令。
     */
    putClc ( ) :无效;

    /**
     * 放置一个 STC 指令。
     */
    putStc ( ) :无效;

    /**
     * 放置 CLD 指令。
     */
    putCld ( ) :无效;

    /**
     * 放置 STD 指令。
     */
    putStd ( ) :无效;

    /**
     * 放置一条 CPUID 指令。
     */
    putCpuid ( ) :无效;

    /**
     * 放置一条 LFENCE 指令。
     */
    putLfence ( ) :无效;

    /**
     * 放置 RDTSC 指令。
     */
    putRdtsc ( ) :无效;

    /**
     * 放一条暂停指令。
     */
    putPause ( ) :无效;

    /**
     * 放置一个 NOP 指令。
     */
    putNop ( ) :无效;

    /**
     * 放置特定于操作系统/架构的断点指令。
     */
    putBreakpoint ( ) :无效;

    /**
     * 放置 `n` 保护指令。
     */
    putPadding （n：数字）：无效；

    /**
     * 放 `n` NOP 指令。
     */
    putNopPadding （n：数字）：无效；

    /**
     * 放置一个 FXSAVE 指令。
     */
    putFxsaveRegPtr （注册：X86Register ）：无效；

    /**
     * 放置一个 FXRSTOR 指令。
     */
    putFxrstorRegPtr （注册：X86Register ）：无效；

    /**
     * 放置一个 uint8。
     */
    putU8 （值：数字）：无效；

    /**
     * 放置一个 int8。
     */
    putS8 （值：数字）：无效；

    /**
     * 放置原始数据。
     */
    putBytes (数据: ArrayBuffer  |  number [ ]  |  string ) : void ;
}

接口 X86WriterOptions  {
    /**
     * 指定初始程序计数器，当
     * 将代码生成到暂存缓冲区。这在使用时是必不可少的
     * iOS 上的 `Memory.patchCode()`，它可能会为您提供一个
     * 临时位置，稍后被映射到内存中
     * 预期的内存位置。
     */
    pc ?: NativePointer  |  未定义；
}

类型 X86CallArgument  =  X86Register  |  号码 |  UInt64  |  整数64  |  本机指针值；

/**
* 重新定位 x86 的机器代码。
*/
声明 类 X86Relocator  {
    /**
     * 创建一个新的代码重定位器用于复制 x86 指令
     * 从一个内存位置到另一个位置，注意调整
     * 相应的位置相关指令。
     *
     * @param inputCode 复制指令的源地址。
     * @param output X86Writer 指向所需的目标内存
     * 地址。
     */
    构造函数（输入代码：NativePointerValue ，输出：X86Writer ）； 

    /**
     * 回收实例。
     */
    重置（输入代码：NativePointerValue ，输出：X86Writer ）：无效； 

    /**
     *急切地清理内存。
     */
    处置（）：无效；

    /**
     * 迄今为止阅读的最新"说明"。从 `null` 开始并更改
     * 在每次调用 `readOne()` 时。
     */
    输入：指令 |  空；

    /**
     * 表示是否已经到达块尾，即我们已经
     * 到达任何类型的分支，例如 CALL、JMP、BL、RET。
     */
    eob：布尔值；

    /**
     * 表示是否已经到达输入结束，例如我们已经
     * 到达 JMP/B/RET，一条指令之后可能或可能
     * 不是有效代码。
     */
    eoi：布尔值；

    /**
     * 将下一条指令读入重定位器的内部缓冲区
     * 并返回到目前为止读取的字节数，包括以前的
     * 来电。
     *
     * 你可以继续调用这个方法来保持缓冲，或者立即
     * 调用 `writeOne()` 或 `skipOne()`。或者，您可以缓冲
     * 直到所需的点，然后调用 `writeAll()`。
     *
     * 到达输入结束时返回零，这意味着 `eoi`
     * 属性现在是 `true`。
     */
    readOne ( )：数字；

    /**
     * 查看下一个要写入或跳过的"指令"。
     */
    peekNextWriteInsn ( ) :指令 |  空；

    /**
     * 查看下一条要写入或跳过的指令的地址。
     */
    peekNextWriteSource ( ) : NativePointer ;

    /**
     * 跳过接下来要编写的指令。
     */
    skipOne ( ) :无效;

    /**
     * 跳过接下来要写的指令，
     * 但没有内部使用的标签。这打破了分支机构的搬迁到
     * 重定位范围内的位置，并且是针对用例的优化
     * 所有分支都被重写（例如Frida's Stalker）。
     */
    skipOneNoLabel ( ) :无效;

    /**
     * 写入下一条缓冲指令。
     */
    writeOne ( )：布尔值；

    /**
     * 写入下一条缓冲指令，但没有
     * 内部使用标签。这打破了分支机构重新定位到位置
     * 在重新定位的范围内，并且是针对所有用例的优化
     * 分支被重写（例如Frida's Stalker）。
     */
    writeOneNoLabel ( ) : boolean ;

    /**
     * 写入所有缓冲指令。
     */
    writeAll ( ) :无效;
}

输入 X86Register  =
    |  "xax"
    |  "xcx"
    |  "xdx"
    |  "xbx"
    |  "xsp"
    |  "xbp"
    |  "xsi"
    |  "xdi"
    |  "eax"
    |  "ecx"
    |  "edx"
    |  "ebx"
    |  "特别"
    |  "ebp"
    |  "esi"
    |  "编辑"
    |  "拉克斯"
    |  "rcx"
    |  "rdx"
    |  "rbx"
    |  "回复"
    |  "rbp"
    |  "rsi"
    |  "rdi"
    |  "r8"
    |  "r9"
    |  "r10"
    |  "r11"
    |  "r12"
    |  "r13"
    |  "r14"
    |  "r15"
    |  "r8d"
    |  "r9d"
    |  "r10d"
    |  "r11d"
    |  "r12d"
    |  "r13d"
    |  "r14d"
    |  "r15d"
    |  "西普"
    |  "eip"
    |  "撕裂"
    ;

输入 X86InstructionId  =
    |  "乔"
    |  "杰诺"
    |  "jb"
    |  "杰"
    |  "杰"
    |  "杰尼"
    |  "杰贝"
    |  "贾"
    |  "js"
    |  "jns"
    |  "J.P"
    |  "jnp"
    |  "jl"
    |  "杰哥"
    |  "杰勒"
    |  "jg"
    |  "jcxz"
    |  "jecxz"
    |  "jrcxz"
    ;

类型 X86BranchHint  =  "无提示"  |  "可能"  |  "不太可能" ；

类型 X86PointerTarget  =  "字节"  |  "双字"  |  "qword" ;

/**
* 为 arm 生成机器代码。
*/
声明 类 ArmWriter  {
    /**
     * 创建用于生成 ARM 机器代码的新代码编写器
     * 在 `codeAddress` 处直接写入内存。
     *
     * @param codeAddress 将生成的代码写入的内存地址。
     * @param options 用于自定义代码生成的选项。
     */
    构造函数（codeAddress：NativePointerValue ， 选项？：ArmWriterOptions ）；

    /**
     * 回收实例。
     */
    重置（代码地址：NativePointerValue ，选项？：ArmWriterOptions ）：无效； 

    /**
     *急切地清理内存。
     */
    处置（）：无效；

    /**
     * 解决标签引用并将待处理数据写入内存。你
     * 应始终在您完成生成代码后调用它。它
     * 通常也希望在不相关的部分之间执行此操作
     * 代码，例如在一次生成多个函数时。
     */
    冲洗（）：无效；

    /**
     * 输出第一个字节的内存位置。
     */
    基：本地指针；

    /**
     * 下一个输出字节的内存位置。
     */
    代码：本地指针；

    /**
     * 程序计数器在输出的下一个字节。
     */
    个人计算机：本地指针；

    /**
     * 当前偏移量（以字节为单位）。
     */
    偏移量：数字；

    /**
     * 跳过 `nBytes`。
     */
    跳过（nBytes：数字）：无效；

    /**
     * 在当前位置放置一个标签，其中 `id` 是一个标识符
     * 可能在过去和将来的 `put*Label()` 调用中被引用。
     */
    putLabel （id：字符串）：无效；

    /**
     * 使用指定的 `args` 放置调用 C 函数所需的代码。
     */
    putCallAddressWithArguments （函数：NativePointerValue ， 参数：ArmCallArgument [ ] ）：无效；

    /**
     * 放置一个 CALL 指令。
     */
    putCallReg ( reg : ArmRegister ) : void ;

    /**
     * 使用指定的 `args` 放置调用 C 函数所需的代码。
     */
    putCallRegWithArguments ( reg : ArmRegister ,  args : ArmCallArgument [ ] ) : void ;

    /**
     * 将分支/跳转所需的代码放入给定地址。
     */
    putBranchAddress （地址：NativePointerValue ）：无效；

    /**
     * 判断两者之间是否可以直接分支
     * 给定的内存位置。
     */
    canBranchDirectlyBetween （从：NativePointerValue ， 到：NativePointerValue ）：布尔值；

    /**
     * 放置 B 指令。
     */
    putBImm （目标：NativePointerValue ）：无效；

    /**
     * 放置一个 B COND 指令。
     */
    putBCondImm （cc：ArmConditionCode ， 目标：NativePointerValue ）：void；

    /**
     * 放置一个 B 指令引用 `labelId`，由过去定义
     * 或未来的 `putLabel()`。
     */
    putBLabel （labelId：字符串）：无效；

    /**
     * 放置一个 B COND 指令引用 `labelId`，由过去定义
     * 或未来的 `putLabel()`。
     */
    putBCondLabel ( cc : ArmConditionCode ,  labelId : string ) : void ;

    /**
     * 放置 BL 指令。
     */
    putBlImm （目标：NativePointerValue ）：无效；

    /**
     * 放置一条 BLX 指令。
     */
    putBlxImm （目标：NativePointerValue ）：无效；

    /**
     * 放置一个引用 `labelId` 的 BL 指令，由过去定义
     * 或未来的 `putLabel()`。
     */
    putBlLabel （标签标识：字符串）：无效；

    /**
     * 放置一个 BX 指令。
     */
    putBxReg ( reg : ArmRegister ) : void ;

    /**
     * 放置 BL 指令。
     */
    putBlReg ( reg : ArmRegister ) : void ;

    /**
     * 放置一条 BLX 指令。
     */
    putBlxReg ( reg : ArmRegister ) : void ;

    /**
     * 放置一个 RET 指令。
     */
    putRet ( ) :无效;

    /**
     * 放置一个 VPUSH RANGE 指令。
     */
    putVpushRange （firstReg：ArmRegister ， lastReg：ArmRegister ）：无效；

    /**
     * 放置一个 VPOP RANGE 指令。
     */
    putVpopRange （firstReg：ArmRegister ， lastReg：ArmRegister ）：无效；

    /**
     * 放置一条 LDR 指令。
     */
    putLdrRegAddress （注册：ArmRegister ， 地址：NativePointerValue ）：无效；

    /**
     * 放置一条 LDR 指令。
     */
    putLdrRegU32 ( reg : ArmRegister ,  val : number ) : void ;

    /**
     * 放置一条 LDR 指令。
     */
    putLdrRegReg ( dstReg : ArmRegister ,  srcReg : ArmRegister ) :无效;

    /**
     * 放置一条 LDR 指令。
     */
    putLdrRegRegOffset ( dstReg : ArmRegister ,  srcReg : ArmRegister ,  srcOffset : number  |  Int64  |  UInt64 ) : void ;

    /**
     * 放置一条 LDR COND 指令。
     */
    putLdrCondRegRegOffset ( cc : ArmConditionCode ,  dstReg : ArmRegister ,  srcReg : ArmRegister ,  srcOffset : number  |  Int64  |  UInt64 ) : void ;

    /**
     * 放置一个 LDMIA MASK 指令。
     */
    putLdmiaRegMask （注册：ArmRegister ， 掩码：数字）：无效；

    /**
     * 放置一个 STR 指令。
     */
    putStrRegReg ( srcReg : ArmRegister ,  dstReg : ArmRegister ) :无效;

    /**
     * 放置一个 STR 指令。
     */
    putStrRegRegOffset ( srcReg : ArmRegister ,  dstReg : ArmRegister ,  dstOffset : number  |  Int64  |  UInt64 ) : void ;

    /**
     * 放置一个 STR COND 指令。
     */
    putStrCondRegRegOffset ( cc : ArmConditionCode ,  srcReg : ArmRegister ,  dstReg : ArmRegister ,  dstOffset : number  |  Int64  |  UInt64 ) : void ;

    /**
     * 放置一条 MOV 指令。
     */
    putMovRegReg ( dstReg : ArmRegister ,  srcReg : ArmRegister ) :无效;

    /**
     * 放置一个 MOV SHIFT 指令。
     */
    putMovRegRegShift ( dstReg : ArmRegister ,  srcReg : ArmRegister ,  shift : ArmShifter ,  shiftValue : number ) : void ;

    /**
     * 放置一条 MOV CPSR 指令。
     */
    putMovRegCpsr ( reg : ArmRegister ) : void ;

    /**
     * 放置一条 MOV CPSR 指令。
     */
    putMovCpsrReg ( reg : ArmRegister ) : void ;

    /**
     * 放置一个 ADD U16 指令。
     */
    putAddRegU16 ( dstReg : ArmRegister ,  val : number ) : void ;

    /**
     * 放置一个 ADD 指令。
     */
    putAddRegU32 ( dstReg : ArmRegister ,  val : number ) : void ;

    /**
     * 放置一个 ADD 指令。
     */
    putAddRegRegImm （dstReg：ArmRegister ， srcReg：ArmRegister ， immVal：数字）：无效；

    /**
     * 放置一个 ADD 指令。
     */
    putAddRegRegReg （dstReg：ArmRegister ， srcReg1：ArmRegister ， srcReg2：ArmRegister ）：无效；

    /**
     * 放置一个 ADD SHIFT 指令。
     */
    putAddRegRegRegShift ( dstReg : ArmRegister ,  srcReg1 : ArmRegister ,  srcReg2 : ArmRegister ,  shift : ArmShifter ,  shiftValue : number ) : void ;

    /**
     * 放置一个 SUB U16 指令。
     */
    putSubRegU16 ( dstReg : ArmRegister ,  val : number ) :无效;

    /**
     * 放置一个 SUB 指令。
     */
    putSubRegU32 ( dstReg : ArmRegister ,  val : number ) :无效;

    /**
     * 放置一个 SUB 指令。
     */
    putSubRegRegImm （dstReg：ArmRegister ， srcReg：ArmRegister ， immVal：数字）：无效；

    /**
     * 放置一个 SUB 指令。
     */
    putSubRegRegReg （dstReg：ArmRegister ， srcReg1：ArmRegister ， srcReg2：ArmRegister ）：无效；

    /**
     * 放置一个 RSB 指令。
     */
    putRsbRegRegImm （dstReg：ArmRegister ， srcReg：ArmRegister ， immVal：数字）：无效；

    /**
     * 放置一个 ANDS 指令。
     */
    putAndsRegRegImm ( dstReg : ArmRegister ,  srcReg : ArmRegister ,  immVal : number ) : void ;

    /**
     * 放置 CMP 指令。
     */
    putCmpRegImm （dstReg：ArmRegister ， immVal：数字）：无效；

    /**
     * 放置一个 NOP 指令。
     */
    putNop ( ) :无效;

    /**
     * 放置特定于操作系统/架构的断点指令。
     */
    putBreakpoint ( ) :无效;

    /**
     * 放置一个 BRK 指令。
     */
    putBrkImm （imm：数字）：无效；

    /**
     * 放置一个原始指令。
     */
    putInstruction （insn：数字）：无效；

    /**
     * 放置原始数据。
     */
    putBytes (数据: ArrayBuffer  |  number [ ]  |  string ) : void ;
}

接口 ArmWriterOptions  {
    /**
     * 指定初始程序计数器，当
     * 将代码生成到暂存缓冲区。这在使用时是必不可少的
     * iOS 上的 `Memory.patchCode()`，它可能会为您提供一个
     * 临时位置，稍后被映射到内存中
     * 预期的内存位置。
     */
    pc ?: NativePointer  |  未定义；
}

类型 ArmCallArgument  =  ArmRegister  |  号码 |  UInt64  |  整数64  |  本机指针值；

/**
* 重新定位 arm 的机器代码。
*/
声明 类 ArmRelocator  {
    /**
     * 创建一个新的代码重定位器用于复制 ARM 指令
     * 从一个内存位置到另一个位置，注意调整
     * 相应的位置相关指令。
     *
     * @param inputCode 复制指令的源地址。
     * @param output ArmWriter 指向所需的目标内存
     * 地址。
     */
    构造函数（输入代码：NativePointerValue ，输出：ArmWriter ）； 

    /**
     * 回收实例。
     */
    重置（输入代码：NativePointerValue ，输出：ArmWriter ）：无效； 

    /**
     *急切地清理内存。
     */
    处置（）：无效；

    /**
     * 迄今为止阅读的最新"说明"。从 `null` 开始并更改
     * 在每次调用 `readOne()` 时。
     */
    输入：指令 |  空；

    /**
     * 表示是否已经到达块尾，即我们已经
     * 到达任何类型的分支，例如 CALL、JMP、BL、RET。
     */
    eob：布尔值；

    /**
     * 表示是否已经到达输入结束，例如我们已经
     * 到达 JMP/B/RET，一条指令之后可能或可能
     * 不是有效代码。
     */
    eoi：布尔值；

    /**
     * 将下一条指令读入重定位器的内部缓冲区
     * 并返回到目前为止读取的字节数，包括以前的
     * 来电。
     *
     * 你可以继续调用这个方法来保持缓冲，或者立即
     * 调用 `writeOne()` 或 `skipOne()`。或者，您可以缓冲
     * 直到所需的点，然后调用 `writeAll()`。
     *
     * 到达输入结束时返回零，这意味着 `eoi`
     * 属性现在是 `true`。
     */
    readOne ( )：数字；

    /**
     * 查看下一个要写入或跳过的"指令"。
     */
    peekNextWriteInsn ( ) :指令 |  空；

    /**
     * 查看下一条要写入或跳过的指令的地址。
     */
    peekNextWriteSource ( ) : NativePointer ;

    /**
     * 跳过接下来要编写的指令。
     */
    skipOne ( ) :无效;

    /**
     * 写入下一条缓冲指令。
     */
    writeOne ( )：布尔值；

    /**
     * 写入所有缓冲指令。
     */
    writeAll ( ) :无效;
}

/**
* 为 arm 生成机器代码。
*/
声明 类 ThumbWriter  {
    /**
     * 创建用于生成 ARM 机器代码的新代码编写器
     * 在 `codeAddress` 处直接写入内存。
     *
     * @param codeAddress 将生成的代码写入的内存地址。
     * @param options 用于自定义代码生成的选项。
     */
    构造函数（codeAddress：NativePointerValue ， 选项？：ThumbWriterOptions ）；

    /**
     * 回收实例。
     */
    重置（代码地址：NativePointerValue ，选项？：ThumbWriterOptions ）：无效； 

    /**
     *急切地清理内存。
     */
    处置（）：无效；

    /**
     * 解决标签引用并将待处理数据写入内存。你
     * 应始终在您完成生成代码后调用它。它
     * 通常也希望在不相关的部分之间执行此操作
     * 代码，例如在一次生成多个函数时。
     */
    冲洗（）：无效；

    /**
     * 输出第一个字节的内存位置。
     */
    基：本地指针；

    /**
     * 下一个输出字节的内存位置。
     */
    代码：本地指针；

    /**
     * 程序计数器在输出的下一个字节。
     */
    个人计算机：本地指针；

    /**
     * 当前偏移量（以字节为单位）。
     */
    偏移量：数字；

    /**
     * 跳过 `nBytes`。
     */
    跳过（nBytes：数字）：无效；

    /**
     * 在当前位置放置一个标签，其中 `id` 是一个标识符
     * 可能在过去和将来的 `put*Label()` 调用中被引用。
     */
    putLabel （id：字符串）：无效；

    /**
     * 提交对给定标签的第一个挂起引用，返回
     * `true` 成功。如果给定的标签还没有，则返回 `false`
     * 尚未定义，或者没有更多待处理的引用。
     */
    commitLabel ( id : string ) : boolean ;

    /**
     * 使用指定的 `args` 放置调用 C 函数所需的代码。
     */
    putCallAddressWithArguments （函数：NativePointerValue ， 参数：ArmCallArgument [ ] ）：无效；

    /**
     * 使用指定的 `args` 放置调用 C 函数所需的代码。
     */
    putCallRegWithArguments ( reg : ArmRegister ,  args : ArmCallArgument [ ] ) : void ;

    /**
     * 将分支/跳转所需的代码放入给定地址。
     */
    putBranchAddress （地址：NativePointerValue ）：无效；

    /**
     * 判断两者之间是否可以直接分支
     * 给定的内存位置。
     */
    canBranchDirectlyBetween （从：NativePointerValue ， 到：NativePointerValue ）：布尔值；

    /**
     * 放置 B 指令。
     */
    putBImm （目标：NativePointerValue ）：无效；

    /**
     * 放置一个 B 指令引用 `labelId`，由过去定义
     * 或未来的 `putLabel()`。
     */
    putBLabel （labelId：字符串）：无效；

    /**
     * 放置一个 B WIDE 指令。
     */
    putBLabelWide ( labelId : string ) : void ;

    /**
     * 放置一个 BX 指令。
     */
    putBxReg ( reg : ArmRegister ) : void ;

    /**
     * 放置 BL 指令。
     */
    putBlImm （目标：NativePointerValue ）：无效；

    /**
     * 放置一个引用 `labelId` 的 BL 指令，由过去定义
     * 或未来的 `putLabel()`。
     */
    putBlLabel （标签标识：字符串）：无效；

    /**
     * 放置一条 BLX 指令。
     */
    putBlxImm （目标：NativePointerValue ）：无效；

    /**
     * 放置一条 BLX 指令。
     */
    putBlxReg ( reg : ArmRegister ) : void ;

    /**
     * 放置 CMP 指令。
     */
    putCmpRegImm ( reg : ArmRegister ,  immValue : number ) : void ;

    /**
     * 放置一个 BEQ 指令引用 `labelId`，由过去定义
     * 或未来的 `putLabel()`。
     */
    putBeqLabel （labelId：字符串）：无效；

    /**
     * 放置一个 BNE 指令引用 `labelId`，由过去定义
     * 或未来的 `putLabel()`。
     */
    putBneLabel （labelId：字符串）：无效；

    /**
     * 放置一个 B COND 指令引用 `labelId`，由过去定义
     * 或未来的 `putLabel()`。
     */
    putBCondLabel ( cc : ArmConditionCode ,  labelId : string ) : void ;

    /**
     * 放置一个 B COND WIDE 指令。
     */
    putBCondLabelWide ( cc : ArmConditionCode ,  labelId : string ) : void ;

    /**
     * 放置一个引用 `labelId` 的 CBZ 指令，由过去定义
     * 或未来的 `putLabel()`。
     */
    putCbzRegLabel （注册：ArmRegister ， labelId：字符串）：无效；

    /**
     * 放置一个引用 `labelId` 的 CBNZ 指令，由过去定义
     * 或未来的 `putLabel()`。
     */
    putCbnzRegLabel ( reg : ArmRegister ,  labelId : string ) : void ;

    /**
     * 使用指定的寄存器放置一个 PUSH 指令。
     */
    putPushRegs ( regs : ArmRegister [ ] ) : void ;

    /**
     * 使用指定的寄存器放置一条 POP 指令。
     */
    putPopRegs ( regs : ArmRegister [ ] ) : void ;

    /**
     * 放置一个 VPUSH RANGE 指令。
     */
    putVpushRange （firstReg：ArmRegister ， lastReg：ArmRegister ）：无效；

    /**
     * 放置一个 VPOP RANGE 指令。
     */
    putVpopRange （firstReg：ArmRegister ， lastReg：ArmRegister ）：无效；

    /**
     * 放置一条 LDR 指令。
     */
    putLdrRegAddress （注册：ArmRegister ， 地址：NativePointerValue ）：无效；

    /**
     * 放置一条 LDR 指令。
     */
    putLdrRegU32 ( reg : ArmRegister ,  val : number ) : void ;

    /**
     * 放置一条 LDR 指令。
     */
    putLdrRegReg ( dstReg : ArmRegister ,  srcReg : ArmRegister ) :无效;

    /**
     * 放置一条 LDR 指令。
     */
    putLdrRegRegOffset ( dstReg : ArmRegister ,  srcReg : ArmRegister ,  srcOffset : number  |  Int64  |  UInt64 ) : void ;

    /**
     * 放置一个 LDRB 指令。
     */
    putLdrbRegReg ( dstReg : ArmRegister ,  srcReg : ArmRegister ) :无效;

    /**
     * 放置一条 VLDR 指令。
     */
    putVldrRegRegOffset ( dstReg : ArmRegister ,  srcReg : ArmRegister ,  srcOffset : number  |  Int64  |  UInt64 ) : void ;

    /**
     * 放置一个 LDMIA MASK 指令。
     */
    putLdmiaRegMask （注册：ArmRegister ， 掩码：数字）：无效；

    /**
     * 放置一个 STR 指令。
     */
    putStrRegReg ( srcReg : ArmRegister ,  dstReg : ArmRegister ) :无效;

    /**
     * 放置一个 STR 指令。
     */
    putStrRegRegOffset ( srcReg : ArmRegister ,  dstReg : ArmRegister ,  dstOffset : number  |  Int64  |  UInt64 ) : void ;

    /**
     * 放置一条 MOV 指令。
     */
    putMovRegReg ( dstReg : ArmRegister ,  srcReg : ArmRegister ) :无效;

    /**
     * 放置一条 MOV 指令。
     */
    putMovRegU8 （dstReg：ArmRegister ， immValue：数字）：无效；

    /**
     * 放置一条 MOV CPSR 指令。
     */
    putMovRegCpsr ( reg : ArmRegister ) : void ;

    /**
     * 放置一条 MOV CPSR 指令。
     */
    putMovCpsrReg ( reg : ArmRegister ) : void ;

    /**
     * 放置一个 ADD 指令。
     */
    putAddRegImm ( dstReg : ArmRegister ,  immValue : number  |  Int64  |  UInt64 ) : void ;

    /**
     * 放置一个 ADD 指令。
     */
    putAddRegReg ( dstReg : ArmRegister ,  srcReg : ArmRegister ) :无效;

    /**
     * 放置一个 ADD 指令。
     */
    putAddRegRegReg （dstReg：ArmRegister ， leftReg：ArmRegister ， rightReg：ArmRegister ）：无效；

    /**
     * 放置一个 ADD 指令。
     */
    putAddRegRegImm ( dstReg : ArmRegister ,  leftReg : ArmRegister ,  rightValue : number  |  Int64  |  UInt64 ) : void ;

    /**
     * 放置一个 SUB 指令。
     */
    putSubRegImm ( dstReg : ArmRegister ,  immValue : number  |  Int64  |  UInt64 ) : void ;

    /**
     * 放置一个 SUB 指令。
     */
    putSubRegReg ( dstReg : ArmRegister ,  srcReg : ArmRegister ) :无效;

    /**
     * 放置一个 SUB 指令。
     */
    putSubRegRegReg （dstReg：ArmRegister ， leftReg：ArmRegister ， rightReg：ArmRegister ）：无效；

    /**
     * 放置一个 SUB 指令。
     */
    putSubRegRegImm ( dstReg : ArmRegister ,  leftReg : ArmRegister ,  rightValue : number  |  Int64  |  UInt64 ) : void ;

    /**
     * 放置一个 AND 指令。
     */
    putAndRegRegImm ( dstReg : ArmRegister ,  leftReg : ArmRegister ,  rightValue : number  |  Int64  |  UInt64 ) : void ;

    /**
     * 放置一个 OR 指令。
     */
    putOrRegRegImm ( dstReg : ArmRegister ,  leftReg : ArmRegister ,  rightValue : number  |  Int64  |  UInt64 ) : void ;

    /**
     * 放置 LSL 指令。
     */
    putLslRegRegImm ( dstReg : ArmRegister ,  leftReg : ArmRegister ,  rightValue : number ) : void ;

    /**
     * 放置 LSLS 指令。
     */
    putLslsRegRegImm ( dstReg : ArmRegister ,  leftReg : ArmRegister ,  rightValue : number ) : void ;

    /**
     * 放置 LSRS 指令。
     */
    putLsrsRegRegImm ( dstReg : ArmRegister ,  leftReg : ArmRegister ,  rightValue : number ) : void ;

    /**
     * 放一条 MRS 指令。
     */
    putMrsRegReg （dstReg：ArmRegister ， srcReg：ArmSystemRegister ）：无效；

    /**
     * 放置一条 MSR 指令。
     */
    putMsrRegReg （dstReg：ArmSystemRegister ， srcReg：ArmRegister ）：无效；

    /**
     * 放置一个 NOP 指令。
     */
    putNop ( ) :无效;

    /**
     * 放置一个 BKPT 指令。
     */
    putBkptImm ( imm : number ) : void ;

    /**
     * 放置特定于操作系统/架构的断点指令。
     */
    putBreakpoint ( ) :无效;

    /**
     * 放置一个原始指令。
     */
    putInstruction （insn：数字）：无效；

    /**
     * 放置一个原始的 Thumb-2 指令。
     */
    putInstructionWide （上：数字， 下：数字）：无效；

    /**
     * 放置原始数据。
     */
    putBytes (数据: ArrayBuffer  |  number [ ]  |  string ) : void ;
}

接口 ThumbWriterOptions  {
    /**
     * 指定初始程序计数器，当
     * 将代码生成到暂存缓冲区。这在使用时是必不可少的
     * iOS 上的 `Memory.patchCode()`，它可能会为您提供一个
     * 临时位置，稍后被映射到内存中
     * 预期的内存位置。
     */
    pc ?: NativePointer  |  未定义；
}

/**
* 重新定位 arm 的机器代码。
*/
声明 类 ThumbRelocator  {
    /**
     * 创建一个新的代码重定位器用于复制 ARM 指令
     * 从一个内存位置到另一个位置，注意调整
     * 相应的位置相关指令。
     *
     * @param inputCode 复制指令的源地址。
     * @param output ThumbWriter 指向所需的目标内存
     * 地址。
     */
    构造函数（输入代码：NativePointerValue ，输出：ThumbWriter ）； 

    /**
     * 回收实例。
     */
    重置（输入代码：NativePointerValue ，输出：ThumbWriter ）：无效； 

    /**
     *急切地清理内存。
     */
    处置（）：无效；

    /**
     * 迄今为止阅读的最新"说明"。从 `null` 开始并更改
     * 在每次调用 `readOne()` 时。
     */
    输入：指令 |  空；

    /**
     * 表示是否已经到达块尾，即我们已经
     * 到达任何类型的分支，例如 CALL、JMP、BL、RET。
     */
    eob：布尔值；

    /**
     * 表示是否已经到达输入结束，例如我们已经
     * 到达 JMP/B/RET，一条指令之后可能或可能
     * 不是有效代码。
     */
    eoi：布尔值；

    /**
     * 将下一条指令读入重定位器的内部缓冲区
     * 并返回到目前为止读取的字节数，包括以前的
     * 来电。
     *
     * 你可以继续调用这个方法来保持缓冲，或者立即
     * 调用 `writeOne()` 或 `skipOne()`。或者，您可以缓冲
     * 直到所需的点，然后调用 `writeAll()`。
     *
     * 到达输入结束时返回零，这意味着 `eoi`
     * 属性现在是 `true`。
     */
    readOne ( )：数字；

    /**
     * 查看下一个要写入或跳过的"指令"。
     */
    peekNextWriteInsn ( ) :指令 |  空；

    /**
     * 查看下一条要写入或跳过的指令的地址。
     */
    peekNextWriteSource ( ) : NativePointer ;

    /**
     * 跳过接下来要编写的指令。
     */
    skipOne ( ) :无效;

    /**
     * 写入下一条缓冲指令。
     */
    writeOne ( )：布尔值；

    /**
     * 复制下一条缓冲指令而不推进
     * 输出游标，允许写出相同的指令
     * 多次。
     */
    copyOne ( )：布尔值；

    /**
     * 写入所有缓冲指令。
     */
    writeAll ( ) :无效;
}

输入 ArmRegister  =
    |  "r0"
    |  "r1"
    |  "r2"
    |  "r3"
    |  "r4"
    |  "r5"
    |  "r6"
    |  "r7"
    |  "r8"
    |  "r9"
    |  "r10"
    |  "r11"
    |  "r12"
    |  "r13"
    |  "r14"
    |  "r15"
    |  "sp"
    |  "lr"
    |  "某人"
    |  "sl"
    |  "fp"
    |  "IP"
    |  "个人电脑"
    |  "s0"
    |  "s1"
    |  "s2"
    |  "s3"
    |  "s4"
    |  "s5"
    |  "s6"
    |  "s7"
    |  "s8"
    |  "s9"
    |  "s10"
    |  "s11"
    |  "s12"
    |  "s13"
    |  "s14"
    |  "s15"
    |  "s16"
    |  "s17"
    |  "s18"
    |  "s19"
    |  "s20"
    |  "s21"
    |  "s22"
    |  "s23"
    |  "s24"
    |  "s25"
    |  "s26"
    |  "s27"
    |  "s28"
    |  "s29"
    |  "s30"
    |  "s31"
    |  "d0"
    |  "d1"
    |  "d2"
    |  "d3"
    |  "d4"
    |  "d5"
    |  "d6"
    |  "d7"
    |  "d8"
    |  "d9"
    |  "d10"
    |  "d11"
    |  "d12"
    |  "d13"
    |  "d14"
    |  "d15"
    |  "d16"
    |  "d17"
    |  "d18"
    |  "d19"
    |  "d20"
    |  "d21"
    |  "d22"
    |  "d23"
    |  "d24"
    |  "d25"
    |  "d26"
    |  "d27"
    |  "d28"
    |  "d29"
    |  "d30"
    |  "d31"
    |  "q0"
    |  "q1"
    |  "q2"
    |  "q3"
    |  "q4"
    |  "q5"
    |  "q6"
    |  "q7"
    |  "q8"
    |  "q9"
    |  "q10"
    |  "q11"
    |  "q12"
    |  "q13"
    |  "q14"
    |  "q15"
    ;

类型 ArmSystemRegister  =  "apsr-nzcvq" ;

输入 ArmConditionCode  =
    |  "当量"
    |  "ne"
    |  "hs"
    |  "洛"
    |  "咪"
    |  "请"
    |  "对"
    |  "vc"
    |  "你好"
    |  "ls"
    |  "格"
    |  "lt"
    |  "gt"
    |  "乐"
    |  "阿尔"
    ;

类型 ArmShifter  =
    |  "asr"
    |  "lsl"
    |  "lsr"
    |  "罗"
    |  "rrx"
    |  "asr-reg"
    |  "lsl 注册"
    |  "lsr-reg"
    |  "反注册"
    |  "rrx-reg"
    ;

/**
* 为 arm64 生成机器代码。
*/
声明 类 Arm64Writer  {
    /**
     * 创建用于生成 AArch64 机器代码的新代码编写器
     * 在 `codeAddress` 处直接写入内存。
     *
     * @param codeAddress 将生成的代码写入的内存地址。
     * @param options 用于自定义代码生成的选项。
     */
    构造函数（codeAddress：NativePointerValue ， 选项？：Arm64WriterOptions ）；

    /**
     * 回收实例。
     */
    重置（代码地址：NativePointerValue ，选项？：Arm64WriterOptions ）：无效； 

    /**
     *急切地清理内存。
     */
    处置（）：无效；

    /**
     * 解决标签引用并将待处理数据写入内存。你
     * 应始终在您完成生成代码后调用它。它
     * 通常也希望在不相关的部分之间执行此操作
     * 代码，例如在一次生成多个函数时。
     */
    冲洗（）：无效；

    /**
     * 输出第一个字节的内存位置。
     */
    基：本地指针；

    /**
     * 下一个输出字节的内存位置。
     */
    代码：本地指针；

    /**
     * 程序计数器在输出的下一个字节。
     */
    个人计算机：本地指针；

    /**
     * 当前偏移量（以字节为单位）。
     */
    偏移量：数字；

    /**
     * 跳过 `nBytes`。
     */
    跳过（nBytes：数字）：无效；

    /**
     * 在当前位置放置一个标签，其中 `id` 是一个标识符
     * 可能在过去和将来的 `put*Label()` 调用中被引用。
     */
    putLabel （id：字符串）：无效；

    /**
     * 使用指定的 `args` 放置调用 C 函数所需的代码。
     */
    putCallAddressWithArguments （函数：NativePointerValue ， 参数：Arm64CallArgument [ ] ）：无效；

    /**
     * 使用指定的 `args` 放置调用 C 函数所需的代码。
     */
    putCallRegWithArguments （注册：Arm64Register ， 参数：Arm64CallArgument [ ] ）：无效；

    /**
     * 将分支/跳转所需的代码放入给定地址。
     */
    putBranchAddress （地址：NativePointerValue ）：无效；

    /**
     * 判断两者之间是否可以直接分支
     * 给定的内存位置。
     */
    canBranchDirectlyBetween （从：NativePointerValue ， 到：NativePointerValue ）：布尔值；

    /**
     * 放置 B 指令。
     */
    putBImm （地址：NativePointerValue ）：无效；

    /**
     * 放置一个 B 指令引用 `labelId`，由过去定义
     * 或未来的 `putLabel()`。
     */
    putBLabel （labelId：字符串）：无效；

    /**
     * 放置一个 B COND 指令引用 `labelId`，由过去定义
     * 或未来的 `putLabel()`。
     */
    putBCondLabel ( cc : Arm64ConditionCode ,  labelId : string ) : void ;

    /**
     * 放置 BL 指令。
     */
    putBlImm （地址：NativePointerValue ）：无效；

    /**
     * 放置一个引用 `labelId` 的 BL 指令，由过去定义
     * 或未来的 `putLabel()`。
     */
    putBlLabel （标签标识：字符串）：无效；

    /**
     * 放置一个 BR 指令。
     */
    putBrReg （注册：Arm64Register ）：无效；

    /**
     * 放置一个期望原始指针的 BR 指令
     *任何身份验证位。
     */
    putBrRegNoAuth （注册：Arm64Register ）：无效；

    /**
     * 放置一条 BLR 指令。
     */
    putBlrReg （注册：Arm64Register ）：无效；

    /**
     * 放置一个期望原始指针的 BLR 指令
     *任何身份验证位。
     */
    putBlrRegNoAuth （注册：Arm64Register ）：无效；

    /**
     * 放置一个 RET 指令。
     */
    putRet ( ) :无效;

    /**
     * 放置一条 CBZ 指令。
     */
    putCbzRegImm （注册：Arm64Register ， 目标：NativePointerValue ）：无效；

    /**
     * 放置一条 CBNZ 指令。
     */
    putCbnzRegImm （注册：Arm64Register ， 目标：NativePointerValue ）：无效；

    /**
     * 放置一个引用 `labelId` 的 CBZ 指令，由过去定义
     * 或未来的 `putLabel()`。
     */
    putCbzRegLabel （注册：Arm64Register ， labelId：字符串）：无效；

    /**
     * 放置一个引用 `labelId` 的 CBNZ 指令，由过去定义
     * 或未来的 `putLabel()`。
     */
    putCbnzRegLabel （注册：Arm64Register ， labelId：字符串）：无效；

    /**
     * 放置一个 TBZ 指令。
     */
    putTbzRegImmImm （注册：Arm64Register ， 位：数字， 目标：NativePointerValue ）：无效；

    /**
     * 放置一个 TBNZ 指令。
     */
    putTbnzRegImmImm ( reg : Arm64Register ,  bit : number ,  target : NativePointerValue ) : void ;

    /**
     * 放置一个引用 `labelId` 的 TBZ 指令，由过去定义
     * 或未来的 `putLabel()`。
     */
    putTbzRegImmLabel ( reg : Arm64Register ,  bit : number ,  labelId : string ) : void ;

    /**
     * 放置一个引用 `labelId` 的 TBNZ 指令，由过去定义
     * 或未来的 `putLabel()`。
     */
    putTbnzRegImmLabel ( reg : Arm64Register ,  bit : number ,  labelId : string ) : void ;

    /**
     * 放置一个 PUSH 指令。
     */
    putPushRegReg （regA：Arm64Register ， regB：Arm64Register ）：无效；

    /**
     * 放置 POP 指令。
     */
    putPopRegReg （regA：Arm64Register ， regB：Arm64Register ）：无效；

    /**
     * 将推送所有 X 寄存器所需的代码放入堆栈。
     */
    putPushAllXRegisters ( ) :无效;

    /**
     * 将所有 X 寄存器弹出堆栈所需的代码。
     */
    putPopAllXRegisters ( ) :无效;

    /**
     * 将推送所有 Q 寄存器所需的代码放入堆栈。
     */
    putPushAllQRegisters ( ) :无效;

    /**
     * 将所有 Q 寄存器弹出堆栈所需的代码。
     */
    putPopAllQRegisters ( ) :无效;

    /**
     * 放置一条 LDR 指令。
     */
    putLdrRegAddress （注册：Arm64Register ， 地址：NativePointerValue ）：无效；

    /**
     * 放置一条 LDR 指令。
     */
    putLdrRegU32 ( reg : Arm64Register ,  val : number ) : void ;

    /**
     * 放置一条 LDR 指令。
     */
    putLdrRegU64 ( reg : Arm64Register ,  val : number  |  UInt64 ) : void ;

    /**
     * 放置一条 LDR 指令。
     */
    putLdrRegU32Ptr （注册：Arm64Register ， srcAddress：NativePointerValue ）：无效；

    /**
     * 放置一条 LDR 指令。
     */
    putLdrRegU64Ptr （注册：Arm64Register ， srcAddress：NativePointerValue ）：无效；

    /**
     * 放置一个带有悬空数据引用的 LDR 指令，
     * 返回一个不透明的 ref 值，应该传递给 `putLdrRegValue()`
     * 在所需的位置。
     */
    putLdrRegRef ( reg : Arm64Register ) : number ;

    /**
     * 放入值并更新 LDR 指令
     * 来自之前的 `putLdrRegRef()`。
     */
    putLdrRegValue （参考：数字， 值：NativePointerValue ）：无效；

    /**
     * 放置一条 LDR 指令。
     */
    putLdrRegReg ( dstReg : Arm64Register ,  srcReg : Arm64Register ) :无效;

    /**
     * 放置一条 LDR 指令。
     */
    putLdrRegRegOffset ( dstReg : Arm64Register ,  srcReg : Arm64Register ,  srcOffset : number  |  Int64  |  UInt64 ) : void ;

    /**
     * 放置一个 LDR MODE 指令。
     */
    putLdrRegRegOffsetMode ( dstReg : Arm64Register ,  srcReg : Arm64Register ,  srcOffset : number  |  Int64  |  UInt64 ,  mode : Arm64IndexMode ) : void ;

    /**
     * 放置一条 LDRSW 指令。
     */
    putLdrswRegRegOffset ( dstReg : Arm64Register ,  srcReg : Arm64Register ,  srcOffset : number  |  Int64  |  UInt64 ) : void ;

    /**
     * 放置一个 ADRP 指令。
     */
    putAdrpRegAddress （注册：Arm64Register ， 地址：NativePointerValue ）：无效；

    /**
     * 放置一个 STR 指令。
     */
    putStrRegReg （srcReg：Arm64Register ， dstReg：Arm64Register ）：无效；

    /**
     * 放置一个 STR 指令。
     */
    putStrRegRegOffset ( srcReg : Arm64Register ,  dstReg : Arm64Register ,  dstOffset : number  |  Int64  |  UInt64 ) : void ;

    /**
     * 放置一个 STR MODE 指令。
     */
    putStrRegRegOffsetMode ( srcReg : Arm64Register ,  dstReg : Arm64Register ,  dstOffset : number  |  Int64  |  UInt64 ,  mode : Arm64IndexMode ) : void ;

    /**
     * 放置一个 LDP 指令。
     */
    putLdpRegRegRegOffset ( regA : Arm64Register ,  regB : Arm64Register ,  regSrc : Arm64Register ,  srcOffset : number  |  Int64  |  UInt64 ,  mode : Arm64IndexMode ) : void ;

    /**
     * 放置一条 STP 指令。
     */
    putStpRegRegRegOffset ( regA : Arm64Register ,  regB : Arm64Register ,  regDst : Arm64Register ,  dstOffset : number  |  Int64  |  UInt64 ,  mode : Arm64IndexMode ) : void ;

    /**
     * 放置一条 MOV 指令。
     */
    putMovRegReg ( dstReg : Arm64Register ,  srcReg : Arm64Register ) :无效;

    /**
     * 放置一条 MOV NZCV 指令。
     */
    putMovRegNzcv （注册：Arm64Register ）：无效；

    /**
     * 放置一条 MOV NZCV 指令。
     */
    putMovNzcvReg （注册：Arm64Register ）：无效；

    /**
     * 放置一个 UXTW 指令。
     */
    putUxtwRegReg ( dstReg : Arm64Register ,  srcReg : Arm64Register ) :无效;

    /**
     * 放置一个 ADD 指令。
     */
    putAddRegRegImm ( dstReg : Arm64Register ,  leftReg : Arm64Register ,  rightValue : number  |  Int64  |  UInt64 ) : void ;

    /**
     * 放置一个 ADD 指令。
     */
    putAddRegRegReg （dstReg：Arm64Register ， leftReg：Arm64Register ， rightReg：Arm64Register ）：无效；

    /**
     * 放置一个 SUB 指令。
     */
    putSubRegRegImm ( dstReg : Arm64Register ,  leftReg : Arm64Register ,  rightValue : number  |  Int64  |  UInt64 ) : void ;

    /**
     * 放置一个 SUB 指令。
     */
    putSubRegRegReg （dstReg：Arm64Register ， leftReg：Arm64Register ， rightReg：Arm64Register ）：无效；

    /**
     * 放置一个 AND 指令。
     */
    putAndRegRegImm ( dstReg : Arm64Register ,  leftReg : Arm64Register ,  rightValue : number  |  UInt64 ) : void ;

    /**
     * 放置 TST 指令。
     */
    putTstRegImm ( reg : Arm64Register ,  immValue : number  |  UInt64 ) : void ;

    /**
     * 放置 CMP 指令。
     */
    putCmpRegReg （regA：Arm64Register ， regB：Arm64Register ）：无效；

    /**
     * 放置一条 XPACI 指令。
     */
    putXpaciReg （注册：Arm64Register ）：无效；

    /**
     * 放置一个 NOP 指令。
     */
    putNop ( ) :无效;

    /**
     * 放置一个 BRK 指令。
     */
    putBrkImm （imm：数字）：无效；

    /**
     * 放置一个原始指令。
     */
    putInstruction （insn：数字）：无效；

    /**
     * 放置原始数据。
     */
    putBytes (数据: ArrayBuffer  |  number [ ]  |  string ) : void ;

    /**
     * 对给定的指针值进行签名。
     */
    符号（值：NativePointerValue ）：NativePointer ；
}

接口 Arm64WriterOptions  {
    /**
     * 指定初始程序计数器，当
     * 将代码生成到暂存缓冲区。这在使用时是必不可少的
     * iOS 上的 `Memory.patchCode()`，它可能会为您提供一个
     * 临时位置，稍后被映射到内存中
     * 预期的内存位置。
     */
    pc ?: NativePointer  |  未定义；
}

类型 Arm64CallArgument  =  Arm64Register  |  号码 |  UInt64  |  整数64  |  本机指针值；

/**
* 重新定位 arm64 的机器代码。
*/
声明 类 Arm64Relocator  {
    /**
     * 创建一个新的代码重定位器来复制 AArch64 指令
     * 从一个内存位置到另一个位置，注意调整
     * 相应的位置相关指令。
     *
     * @param inputCode 复制指令的源地址。
     * @param output Arm64Writer 指向所需的目标内存
     * 地址。
     */
    构造函数（输入代码：NativePointerValue ，输出：Arm64Writer ）； 

    /**
     * 回收实例。
     */
    重置（输入代码：NativePointerValue ，输出：Arm64Writer ）：无效； 

    /**
     *急切地清理内存。
     */
    处置（）：无效；

    /**
     * 迄今为止阅读的最新"说明"。从 `null` 开始并更改
     * 在每次调用 `readOne()` 时。
     */
    输入：指令 |  空；

    /**
     * 表示是否已经到达块尾，即我们已经
     * 到达任何类型的分支，例如 CALL、JMP、BL、RET。
     */
    eob：布尔值；

    /**
     * 表示是否已经到达输入结束，例如我们已经
     * 到达 JMP/B/RET，一条指令之后可能或可能
     * 不是有效代码。
     */
    eoi：布尔值；

    /**
     * 将下一条指令读入重定位器的内部缓冲区
     * 并返回到目前为止读取的字节数，包括以前的
     * 来电。
     *
     * 你可以继续调用这个方法来保持缓冲，或者立即
     * 调用 `writeOne()` 或 `skipOne()`。或者，您可以缓冲
     * 直到所需的点，然后调用 `writeAll()`。
     *
     * 到达输入结束时返回零，这意味着 `eoi`
     * 属性现在是 `true`。
     */
    readOne ( )：数字；

    /**
     * 查看下一个要写入或跳过的"指令"。
     */
    peekNextWriteInsn ( ) :指令 |  空；

    /**
     * 查看下一条要写入或跳过的指令的地址。
     */
    peekNextWriteSource ( ) : NativePointer ;

    /**
     * 跳过接下来要编写的指令。
     */
    skipOne ( ) :无效;

    /**
     * 写入下一条缓冲指令。
     */
    writeOne ( )：布尔值；

    /**
     * 写入所有缓冲指令。
     */
    writeAll ( ) :无效;
}

类型 Arm64Register  =
    |  "x0"
    |  "x1"
    |  "x2"
    |  "x3"
    |  "x4"
    |  "x5"
    |  "x6"
    |  "x7"
    |  "x8"
    |  "x9"
    |  "x10"
    |  "x11"
    |  "x12"
    |  "x13"
    |  "x14"
    |  "x15"
    |  "x16"
    |  "x17"
    |  "x18"
    |  "x19"
    |  "x20"
    |  "x21"
    |  "x22"
    |  "x23"
    |  "x24"
    |  "x25"
    |  "x26"
    |  "x27"
    |  "x28"
    |  "x29"
    |  "x30"
    |  "w0"
    |  "w1"
    |  "w2"
    |  "w3"
    |  "w4"
    |  "w5"
    |  "w6"
    |  "w7"
    |  "w8"
    |  "w9"
    |  "w10"
    |  "w11"
    |  "w12"
    |  "w13"
    |  "w14"
    |  "w15"
    |  "w16"
    |  "w17"
    |  "w18"
    |  "w19"
    |  "w20"
    |  "w21"
    |  "w22"
    |  "w23"
    |  "w24"
    |  "w25"
    |  "w26"
    |  "w27"
    |  "w28"
    |  "w29"
    |  "w30"
    |  "sp"
    |  "lr"
    |  "fp"
    |  "wsp"
    |  "wz"
    |  "xz"
    |  "NZCV"
    |  "ip0"
    |  "ip1"
    |  "s0"
    |  "s1"
    |  "s2"
    |  "s3"
    |  "s4"
    |  "s5"
    |  "s6"
    |  "s7"
    |  "s8"
    |  "s9"
    |  "s10"
    |  "s11"
    |  "s12"
    |  "s13"
    |  "s14"
    |  "s15"
    |  "s16"
    |  "s17"
    |  "s18"
    |  "s19"
    |  "s20"
    |  "s21"
    |  "s22"
    |  "s23"
    |  "s24"
    |  "s25"
    |  "s26"
    |  "s27"
    |  "s28"
    |  "s29"
    |  "s30"
    |  "s31"
    |  "d0"
    |  "d1"
    |  "d2"
    |  "d3"
    |  "d4"
    |  "d5"
    |  "d6"
    |  "d7"
    |  "d8"
    |  "d9"
    |  "d10"
    |  "d11"
    |  "d12"
    |  "d13"
    |  "d14"
    |  "d15"
    |  "d16"
    |  "d17"
    |  "d18"
    |  "d19"
    |  "d20"
    |  "d21"
    |  "d22"
    |  "d23"
    |  "d24"
    |  "d25"
    |  "d26"
    |  "d27"
    |  "d28"
    |  "d29"
    |  "d30"
    |  "d31"
    |  "q0"
    |  "q1"
    |  "q2"
    |  "q3"
    |  "q4"
    |  "q5"
    |  "q6"
    |  "q7"
    |  "q8"
    |  "q9"
    |  "q10"
    |  "q11"
    |  "q12"
    |  "q13"
    |  "q14"
    |  "q15"
    |  "q16"
    |  "q17"
    |  "q18"
    |  "q19"
    |  "q20"
    |  "q21"
    |  "q22"
    |  "q23"
    |  "q24"
    |  "q25"
    |  "q26"
    |  "q27"
    |  "q28"
    |  "q29"
    |  "q30"
    |  "q31"
    ;

输入 Arm64ConditionCode  =
    |  "当量"
    |  "ne"
    |  "hs"
    |  "洛"
    |  "咪"
    |  "请"
    |  "对"
    |  "vc"
    |  "你好"
    |  "ls"
    |  "格"
    |  "lt"
    |  "gt"
    |  "乐"
    |  "阿尔"
    |  "nv"
    ;

类型 Arm64IndexMode  =  "后调整"  |  "有符号偏移"  |  "预调整" ；

/**
* 为 mips 生成机器码。
*/
声明 类 MipsWriter  {
    /**
     * 创建用于生成 MIPS 机器代码的新代码编写器
     * 在 `codeAddress` 处直接写入内存。
     *
     * @param codeAddress 将生成的代码写入的内存地址。
     * @param options 用于自定义代码生成的选项。
     */
    构造函数（codeAddress：NativePointerValue ， 选项？：MipsWriterOptions ）；

    /**
     * 回收实例。
     */
    重置（代码地址：NativePointerValue ，选项？：MipsWriterOptions ）：无效； 

    /**
     *急切地清理内存。
     */
    处置（）：无效；

    /**
     * 解决标签引用并将待处理数据写入内存。你
     * 应始终在您完成生成代码后调用它。它
     * 通常也希望在不相关的部分之间执行此操作
     * 代码，例如在一次生成多个函数时。
     */
    冲洗（）：无效；

    /**
     * 输出第一个字节的内存位置。
     */
    基：本地指针；

    /**
     * 下一个输出字节的内存位置。
     */
    代码：本地指针；

    /**
     * 程序计数器在输出的下一个字节。
     */
    个人计算机：本地指针；

    /**
     * 当前偏移量（以字节为单位）。
     */
    偏移量：数字；

    /**
     * 跳过 `nBytes`。
     */
    跳过（nBytes：数字）：无效；

    /**
     * 在当前位置放置一个标签，其中 `id` 是一个标识符
     * 可能在过去和将来的 `put*Label()` 调用中被引用。
     */
    putLabel （id：字符串）：无效；

    /**
     * 使用指定的 `args` 放置调用 C 函数所需的代码。
     */
    putCallAddressWithArguments （函数：NativePointerValue ， 参数：MipsCallArgument [ ] ）：无效；

    /**
     * 使用指定的 `args` 放置调用 C 函数所需的代码。
     */
    putCallRegWithArguments ( reg : MipsRegister ,  args : MipsCallArgument [ ] ) : void ;

    /**
     * 放置 J 指令。
     */
    putJAddress （地址：NativePointerValue ）：无效；

    /**
     * 放置一个 J WITHOUT NOP 指令。
     */
    putJAddressWithoutNop （地址：NativePointerValue ）：无效；

    /**
     * 放置一条引用`labelId`的J指令，由过去定义
     * 或未来的 `putLabel()`。
     */
    putJLabel （标签标识：字符串）：无效；

    /**
     * 放置 JR 指令。
     */
    putJrReg ( reg : MipsRegister ) : void ;

    /**
     * 放置 JAL 指令。
     */
    putJalAddress （地址：数字）：无效；

    /**
     * 放置一条 JALR 指令。
     */
    putJalrReg ( reg : MipsRegister ) : void ;

    /**
     * 放置 B 指令。
     */
    putBOffset （偏移量：数字）：无效；

    /**
     * 放置一个 BEQ 指令引用 `labelId`，由过去定义
     * 或未来的 `putLabel()`。
     */
    putBeqRegRegLabel ( rightReg : MipsRegister ,  leftReg : MipsRegister ,  labelId : string ) : void ;

    /**
     * 放置一个 RET 指令。
     */
    putRet ( ) :无效;

    /**
     * 放置 LA 指令。
     */
    putLaRegAddress （注册：MipsRegister ， 地址：NativePointerValue ）：无效；

    /**
     * 放置一个 LUI 指令。
     */
    putLuiRegImm ( reg : MipsRegister ,  imm : number ) : void ;

    /**
     * 放置一个DSLL指令。
     */
    putDsllRegReg ( dstReg : MipsRegister ,  srcReg : MipsRegister , 数量:数量) : void ;

    /**
     * 放置一条 ORI 指令。
     */
    putOriRegRegImm ( rt : MipsRegister ,  rs : MipsRegister ,  imm : number ) : void ;

    /**
     * 放置一个 LD 指令。
     */
    putLdRegRegOffset ( dstReg : MipsRegister ,  srcReg : MipsRegister ,  srcOffset : number  |  Int64  |  UInt64 ) : void ;

    /**
     * 放置一条 LW 指令。
     */
    putLwRegRegOffset ( dstReg : MipsRegister ,  srcReg : MipsRegister ,  srcOffset : number  |  Int64  |  UInt64 ) : void ;

    /**
     * 放置一个 SW 指令。
     */
    putSwRegRegOffset ( srcReg : MipsRegister ,  dstReg : MipsRegister ,  dstOffset : number  |  Int64  |  UInt64 ) : void ;

    /**
     * 放置一条 MOVE 指令。
     */
    putMoveRegReg （dstReg：MipsRegister ， srcReg：MipsRegister ）：无效；

    /**
     * 放置一个 ADDU 指令。
     */
    putAdduRegRegReg ( dstReg : MipsRegister ,  leftReg : MipsRegister ,  rightReg : MipsRegister ) : void ;

    /**
     * 放置一个 ADDI 指令。
     */
    putAddiRegRegImm ( dstReg : MipsRegister ,  leftReg : MipsRegister ,  imm : number ) : void ;

    /**
     * 放置一个 ADDI 指令。
     */
    putAddiRegImm ( dstReg : MipsRegister ,  imm : number ) :无效;

    /**
     * 放置一个 SUB 指令。
     */
    putSubRegRegImm ( dstReg : MipsRegister ,  leftReg : MipsRegister ,  imm : number ) : void ;

    /**
     * 放置一个 PUSH 指令。
     */
    putPushReg ( reg : MipsRegister ) : void ;

    /**
     * 放置 POP 指令。
     */
    putPopReg ( reg : MipsRegister ) : void ;

    /**
     * 放置一条 MFHI 指令。
     */
    putMfhiReg ( reg : MipsRegister ) : void ;

    /**
     * 放置一个 MFLO 指令。
     */
    putMfloReg ( reg : MipsRegister ) : void ;

    /**
     * 放置一个 MTHI 指令。
     */
    putMthiReg ( reg : MipsRegister ) : void ;

    /**
     * 放置一个 MTLO 指令。
     */
    putMtloReg ( reg : MipsRegister ) : void ;

    /**
     * 放置一个 NOP 指令。
     */
    putNop ( ) :无效;

    /**
     * 放置一个 BREAK 指令。
     */
    putBreak ( ) :无效;

    /**
     * 放置一个最小尺寸的蹦床，用于引导到给定地址。
     */
    putPrologueTrampoline （注册：MipsRegister ， 地址：NativePointerValue ）：无效；

    /**
     * 放置一个原始指令。
     */
    putInstruction （insn：数字）：无效；

    /**
     * 放置原始数据。
     */
    putBytes (数据: ArrayBuffer  |  number [ ]  |  string ) : void ;
}

接口 MipsWriterOptions  {
    /**
     * 指定初始程序计数器，当
     * 将代码生成到暂存缓冲区。这在使用时是必不可少的
     * iOS 上的 `Memory.patchCode()`，它可能会为您提供一个
     * 临时位置，稍后被映射到内存中
     * 预期的内存位置。
     */
    pc ?: NativePointer  |  未定义；
}

类型 MipsCallArgument  =  MipsRegister  |  号码 |  UInt64  |  整数64  |  本机指针值；

/**
* 重新定位 mips 的机器代码。
*/
声明 类 MipsRelocator  {
    /**
     * 创建一个新的代码重定位器用于复制 MIPS 指令
     * 从一个内存位置到另一个位置，注意调整
     * 相应的位置相关指令。
     *
     * @param inputCode 复制指令的源地址。
     * @param output MipsWriter 指向所需的目标内存
     * 地址。
     */
    构造函数（输入代码：NativePointerValue ，输出：MipsWriter ）； 

    /**
     * 回收实例。
     */
    重置（输入代码：NativePointerValue ，输出：MipsWriter ）：无效； 

    /**
     *急切地清理内存。
     */
    处置（）：无效；

    /**
     * 迄今为止阅读的最新"说明"。从 `null` 开始并更改
     * 在每次调用 `readOne()` 时。
     */
    输入：指令 |  空；

    /**
     * 表示是否已经到达块尾，即我们已经
     * 到达任何类型的分支，例如 CALL、JMP、BL、RET。
     */
    eob：布尔值；

    /**
     * 表示是否已经到达输入结束，例如我们已经
     * 到达 JMP/B/RET，一条指令之后可能或可能
     * 不是有效代码。
     */
    eoi：布尔值；

    /**
     * 将下一条指令读入重定位器的内部缓冲区
     * 并返回到目前为止读取的字节数，包括以前的
     * 来电。
     *
     * 你可以继续调用这个方法来保持缓冲，或者立即
     * 调用 `writeOne()` 或 `skipOne()`。或者，您可以缓冲
     * 直到所需的点，然后调用 `writeAll()`。
     *
     * 到达输入结束时返回零，这意味着 `eoi`
     * 属性现在是 `true`。
     */
    readOne ( )：数字；

    /**
     * 查看下一个要写入或跳过的"指令"。
     */
    peekNextWriteInsn ( ) :指令 |  空；

    /**
     * 查看下一条要写入或跳过的指令的地址。
     */
    peekNextWriteSource ( ) : NativePointer ;

    /**
     * 跳过接下来要编写的指令。
     */
    skipOne ( ) :无效;

    /**
     * 写入下一条缓冲指令。
     */
    writeOne ( )：布尔值；

    /**
     * 写入所有缓冲指令。
     */
    writeAll ( ) :无效;
}

输入 MipsRegister  =
    |  "v0"
    |  "v1"
    |  "a0"
    |  "a1"
    |  "a2"
    |  "a3"
    |  "t0"
    |  "t1"
    |  "t2"
    |  "t3"
    |  "t4"
    |  "t5"
    |  "t6"
    |  "t7"
    |  "s0"
    |  "s1"
    |  "s2"
    |  "s3"
    |  "s4"
    |  "s5"
    |  "s6"
    |  "s7"
    |  "t8"
    |  "t9"
    |  "k0"
    |  "k1"
    |  "GP"
    |  "sp"
    |  "fp"
    |  "s8"
    |  "拉"
    |  "你好"
    |  "洛"
    |  "零"
    |  "在"
    |  "0"
    |  "1"
    |  "2"
    |  "3"
    |  "4"
    |  "5"
    |  "6"
    |  "7"
    |  "8"
    |  "9"
    |  "10"
    |  "11"
    |  "12"
    |  "13"
    |  "14"
    |  "15"
    |  "16"
    |  "17"
    |  "18"
    |  "19"
    |  "20"
    |  "21"
    |  "22"
    |  "23"
    |  "24"
    |  "25"
    |  "26"
    |  "27"
    |  "28"
    |  "29"
    |  "30"
    |  "31"
    ;